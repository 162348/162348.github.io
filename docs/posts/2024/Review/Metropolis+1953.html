<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="司馬 博文">

<title>Hirofumi Shiba - Metropolis+ (1953) Equation of State Calculations by Fast Computing Machines</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../profile.jpg" rel="icon" type="image/jpeg">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-36GX2G6GLL"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-36GX2G6GLL', { 'anonymize_ip': true});
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="Hirofumi Shiba - Metropolis+ (1953) Equation of State Calculations by Fast Computing Machines">
<meta property="og:description" content="A Blog by a Bayesian Computation Researcher">
<meta property="og:image" content="https://162348.github.io/posts/2024/Review/anomaths.png">
<meta property="og:site_name" content="Hirofumi Shiba">
<meta name="twitter:title" content="Hirofumi Shiba - Metropolis+ (1953) Equation of State Calculations by Fast Computing Machines">
<meta name="twitter:description" content="(Metropolis et al., 1953) は初の MCMC（乱歩 Metropolis 法）を，対称分布を Gibbs の正準分布として，“modified Monte Carlo scheme” という名前の下で提案した論文である．重点サンプリングを “Monte Carlo method” と呼び，「目標分布から直接サンプルを生成できるために提案分布と目標分布とのズレによる性能劣化がない」ことを美点として挙げている．この手法は後の (Hastings, 1970) による改良と併せて，Metropolis-Hastings 法と呼ばれるようになる．">
<meta name="twitter:image" content="https://162348.github.io/posts/2024/Review/anomaths.png">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">Hirofumi Shiba</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../static/Sessions.html"> 
<span class="menu-text">Sessions</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../static/Slides.html"> 
<span class="menu-text">Slides</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../../static/Japanese.html"> 
<span class="menu-text">自己紹介</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Metropolis+ (1953) Equation of State Calculations by Fast Computing Machines</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Review</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>司馬 博文 </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">4/18/2024</p>
      </div>
    </div>
    
      
    </div>
    
  <div>
    <div class="abstract">
      <div class="block-title">概要</div>
      <p><span class="citation" data-cites="Metropolis+1953">(<a href="#ref-Metropolis+1953" role="doc-biblioref">Metropolis et al., 1953</a>)</span> は初の MCMC（乱歩 Metropolis 法）を，対称分布を Gibbs の正準分布として，“modified Monte Carlo scheme” という名前の下で提案した論文である．重点サンプリングを “Monte Carlo method” と呼び，「目標分布から直接サンプルを生成できるために提案分布と目標分布とのズレによる性能劣化がない」ことを美点として挙げている．この手法は後の <span class="citation" data-cites="Hastings1970">(<a href="#ref-Hastings1970" role="doc-biblioref">Hastings, 1970</a>)</span> による改良と併せて，Metropolis-Hastings 法と呼ばれるようになる．</p>
    </div>
  </div>
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#概要" id="toc-概要" class="nav-link active" data-scroll-target="#概要"><span class="header-section-number">1</span> 概要</a></li>
  <li><a href="#背景" id="toc-背景" class="nav-link" data-scroll-target="#背景"><span class="header-section-number">2</span> 背景</a>
  <ul class="collapse">
  <li><a href="#monte-carlo-法の起源について" id="toc-monte-carlo-法の起源について" class="nav-link" data-scroll-target="#monte-carlo-法の起源について"><span class="header-section-number">2.1</span> Monte Carlo 法の起源について</a></li>
  <li><a href="#monte-carlo-法とはなんだろうか" id="toc-monte-carlo-法とはなんだろうか" class="nav-link" data-scroll-target="#monte-carlo-法とはなんだろうか"><span class="header-section-number">2.2</span> Monte Carlo 法とはなんだろうか</a></li>
  <li><a href="#他のコメント" id="toc-他のコメント" class="nav-link" data-scroll-target="#他のコメント"><span class="header-section-number">2.3</span> 他のコメント</a></li>
  </ul></li>
  <li><a href="#本論" id="toc-本論" class="nav-link" data-scroll-target="#本論"><span class="header-section-number">3</span> 本論</a>
  <ul class="collapse">
  <li><a href="#設定" id="toc-設定" class="nav-link" data-scroll-target="#設定"><span class="header-section-number">3.1</span> 設定</a></li>
  <li><a href="#アルゴリズムの記述" id="toc-アルゴリズムの記述" class="nav-link" data-scroll-target="#アルゴリズムの記述"><span class="header-section-number">3.2</span> アルゴリズムの記述</a></li>
  <li><a href="#アルゴリズムの有効性の検証" id="toc-アルゴリズムの有効性の検証" class="nav-link" data-scroll-target="#アルゴリズムの有効性の検証"><span class="header-section-number">3.3</span> アルゴリズムの有効性の検証</a></li>
  <li><a href="#附言" id="toc-附言" class="nav-link" data-scroll-target="#附言"><span class="header-section-number">3.4</span> 附言</a></li>
  </ul></li>
  <li><a href="#実験" id="toc-実験" class="nav-link" data-scroll-target="#実験"><span class="header-section-number">4</span> 実験</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="hidden">
$$
<p>%%% 演算子 </p>
%%% 線型代数学
<p>%%% 複素解析学 %%% 集合と位相 </p>
<p>%%% 形式言語理論 %%% Graph Theory </p>
%%% 多様体 %%% 代数 %%% 代数的位相幾何学 %%% 微分幾何学
%%% 函数解析
%%% 積分論
<p>%%% Fourier解析 %%% 数値解析 </p>
%%% 確率論
<p>%%% 情報理論 %%% 量子論 %%% 最適化 %%% 数理ファイナンス </p>
<p>%%% 偏微分方程式 %%% 常微分方程式 %%% 統計力学 %%% 解析力学 </p>
%%% 統計的因果推論 %%% 応用統計学 %%% 数理統計
<p>%%% 計量経済学 </p>
%%% 無限次元統計模型の理論
<p>%%% Banach Lattices </p>
<p>%%% 圏 %代数の圏 %Metric space &amp; Contraction maps %確率空間とMarkov核の圏 %Sober space &amp; continuous map %Category of open subsets %Category of sheave %Category of presheave, PSh(C)=[C^op,set]のこと %Convergence spaceの圏 %一様空間と一様連続写像の圏 %フレームとフレームの射 %その反対圏 %滑らかな多様体の圏 %Quiverの圏 </p>
%%% SMC
%%% 括弧類
<p>%%% 予約語 </p>
<p>%%% 略記 </p>
<p>%%% 矢印類 $$</p>
</div>
<section id="概要" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="概要"><span class="header-section-number">1</span> 概要</h2>
<p>相互作用する分子系からなる物質の状態方程式などの性質を調べるために使える汎用手法（ fast computing machine にぴったり！）を提案する．この手法は配置空間上の，提案分布を正確にした「修正版 Monte Carlo 積分法」だと捉えられる．MANIAC を用いて，２次元剛体球の場合のシミュレーション結果を付した．その結果を，自由体積状態方程式と，４項ビリアル係数展開と比較した．</p>
</section>
<section id="背景" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="背景"><span class="header-section-number">2</span> 背景</h2>
<p>むしろ cell method などの計算手法との類似で捉えており，<span class="citation" data-cites="Hastings1970">(<a href="#ref-Hastings1970" role="doc-biblioref">Hastings, 1970</a>)</span> に取り上げられるまで全く別個の，広く抽象的に応用されるポテンシャルを持つ技術であるという抽象的な観点とは離れた泥臭い探索を感じる．</p>
<p>まだ Markov 連鎖という単語も使われていない．</p>
<p>話の展開は，分子系のシミュレーションの問題を，Gibbs 分布に関する積分計算の問題に帰着し，Monte Carlo 法を用いるところまで還元するが，そこで不適当な提案分布による重点サンプリングを実行するよりかは，系の Gibbs 分布を直接シミュレーションすれば良い，というものである．</p>
<p>よってここでいう修正 Monte Carlo 法とは，Monte Carlo 法（ここでは重点サンプリングと同義，（一様）乱数を用いた数値計算，くらいの意味）による乱数生成過程を，少しだけ MD 法の考え方を取り入れて，より Gibbs 分布に則した乱数生成をする，くらいの提案である．</p>
<p>後世では次のようにも説明されている始末である：</p>
<blockquote class="blockquote">
<p>The Monte Carlo method addresses the sampling problem more abstractly than molecular dynamics, as it samples (obtains samples <span class="math inline">\(x\)</span> from) the distribution <span class="math inline">\(\pi_{24}(x)\)</span> without simulating a physical process. <span class="citation" data-cites="Tartero-Krauth2023">(<a href="#ref-Tartero-Krauth2023" role="doc-biblioref">Tartero &amp; Krauth, 2023</a>)</span></p>
</blockquote>
<p>もはや，愚直な Monte Carlo 法が MD 法で，運動方程式を解かない MD 法が Monte Carlo 法，という具合である．</p>
<p>なお，Monte Carlo 法の提案者として <a href="https://en.wikipedia.org/wiki/Joseph_Edward_Mayer">Joseph Edward Mayer</a> と <a href="https://en.wikipedia.org/wiki/Stanis%C5%82aw_Ulam">Stanisław Ulam</a> の名前を挙げている．</p>
<p>ここで <a href="https://en.wikipedia.org/wiki/Berni_Alder">Berni Alder</a> の名前が上がっており，やはり MCMC の開発は MD と極めて深い関係にあることが伺える．</p>
<blockquote class="blockquote">
<p>This method has been proposed independently by J. E. Mayer and by S. Ulam. Mayer suggested the method as a tool to deal with the problem of the liquid state, while Ulam proposed it as a procedure of general usefulness. B. Alder, J. Kirkwood, S. Frankel, and V. Lewinson discussed an application very similar to ours.</p>
</blockquote>
<section id="monte-carlo-法の起源について" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="monte-carlo-法の起源について"><span class="header-section-number">2.1</span> Monte Carlo 法の起源について</h3>
<p>John von Neumann は Edward Teller と同郷であり，戦時中の ENIAC の開発にも関わっていたことから，偉い人たちを説得して最初の ENIAC のテストに熱核融合反応の計算問題を用いることにした．</p>
<p>計算可能なモデルの構築をしたのが Metropolis である．これが完成し，実際にテストが行われたのは戦後の 1946 年であったが．</p>
<p>そのお披露目会に居合わせた Stanislaw Ulam が，統計的サンプリング技術を電子計算機で復活させることを提案し，Johnny がすぐさまその重要性を理解した．これがモンテカルロ法の始まりとなった，という <span class="citation" data-cites="Metropolis1987">(<a href="#ref-Metropolis1987" role="doc-biblioref">Metropolis, 1987</a>)</span>．</p>
<p>Metropolis は Ulam が着想を得た理由として，数学的な背景を持っていたために，統計的サンプリング技術が計算の難しさのために歴史に埋没したことを知っており，ENIAC のポテンシャルを見てこれと関連づけることに成功したのではないかと示唆している．</p>
<p>そして Johnny の熱の入り用が周りも刺激した．1947 年には統計的サンプリングの中でも特に中性子の拡散問題を取り上げて当時の Los Alamos の理論部リーダーであった Robert Richtmyer に手紙を送った <span class="citation" data-cites="Eckhardt1987">(<a href="#ref-Eckhardt1987" role="doc-biblioref">Eckhardt, 1987</a>)</span>．こうして周りを巻き込んで大ごとになっていった．Monte Carlo 法という命名も 1947 年だったという</p>
<blockquote class="blockquote">
<p>It was at that time that I suggested an obvious name for the statistical method—a suggestion not unrelated to the fact that Stan had an uncle who would borrow money from relatives because he “just had to go to Monte Carlo.”</p>
</blockquote>
<blockquote class="blockquote">
<p>On a less grand scale these events brought about a renascence of a mathematical technique known to the old guard as statistical sampling; in its new surroundings and owing to its nature, there was no denying its new name of the Monte Carlo method. <span class="citation" data-cites="Metropolis1987">(<a href="#ref-Metropolis1987" role="doc-biblioref">Metropolis, 1987</a>)</span></p>
</blockquote>
<p>特に戦時中の関心もあり，核分裂時の <strong>中性子の拡散</strong> のシミュレーションが問題であった．Monte Carlo 法と呼んでいるが本質的に MD 法チックであり，ここの中性子の散乱・吸収・分裂の系譜をシミュレートすることで全体の統計的性質がわかる，というだけの話であった．</p>
<p>その後 1952 年には後続機の MANIAC が開発され，nucleaer cascade と状態方程式も射程に入った．</p>
<p>この状態方程式を取り扱う際に <span class="citation" data-cites="Metropolis+1953">(<a href="#ref-Metropolis+1953" role="doc-biblioref">Metropolis et al., 1953</a>)</span> がさらに効率的な「モンテカルロ法」を発明したのである．これは Gibbs 分布を直接シミュレーションできるというブレイクスルーであり，「一般の確率分布からサンプリングできる」という今の理解とは大きく異なる文脈の中で発見されたと言うべきである．</p>
</section>
<section id="monte-carlo-法とはなんだろうか" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="monte-carlo-法とはなんだろうか"><span class="header-section-number">2.2</span> Monte Carlo 法とはなんだろうか</h3>
<p>思うに，「ランダムな方法を使って計算する」というのは外道に思えるかもしれない．</p>
<p>だが，実はランダムな系の <span class="math inline">\(\mathcal{P}(E)\)</span> 上のダイナミクスの決定論的な計算になっているのかもしれない．</p>
<p>そう思わせるだけの透徹性が測度論にはある．</p>
<p>ただ，<span class="citation" data-cites="Metropolis1987">(<a href="#ref-Metropolis1987" role="doc-biblioref">Metropolis, 1987</a>)</span> は Monte Carlo 法を <strong>実験数学</strong> (experimental mathematics) と呼んでおり，極めて物理学的な見方で評している：</p>
<blockquote class="blockquote">
<p>At long last, mathematics achieved a certain parity–the twofold aspect of experiment and theory–that all other sciences enjoy.</p>
</blockquote>
</section>
<section id="他のコメント" class="level3" data-number="2.3">
<h3 data-number="2.3" class="anchored" data-anchor-id="他のコメント"><span class="header-section-number">2.3</span> 他のコメント</h3>
<blockquote class="blockquote">
<p>Note that <span class="citation" data-cites="Metropolis+1953">(<a href="#ref-Metropolis+1953" role="doc-biblioref">Metropolis et al., 1953</a>)</span> move one particle at a time, rather than moving all of them together, which makes the initial algorithm appear a primitive kind of Gibbs sampler! <span class="citation" data-cites="Robert-Casella2011">(<a href="#ref-Robert-Casella2011" role="doc-biblioref">Robert &amp; Casella, 2011</a>)</span></p>
</blockquote>
</section>
</section>
<section id="本論" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="本論"><span class="header-section-number">3</span> 本論</h2>
<section id="設定" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="設定"><span class="header-section-number">3.1</span> 設定</h3>
<p>古典統計を仮定し，２体間相互作用のみを考え，ポテンシャルは球対称であるとする（流体力学では通常の仮定である）．だが，温度や密度には全く仮定を置かない．<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<p>実際の計算のために，粒子数 <span class="math inline">\(N\)</span> は several hundred に取る．そして正方形の中にいれ，境界条件を最小化するために同様の系が２次元に無限に連なっているとする．２つの粒子 <span class="math inline">\(A\)</span> の他の粒子 <span class="math inline">\(B\)</span> との最短距離を <span class="math inline">\(d_{A,B}\)</span> とし，これのみが粒子 <span class="math inline">\(A\)</span> にかかる主な力になるとする．</p>
<p>仮に <span class="math inline">\(N=1\)</span> だとしたら，これは <a href="https://ja.wikipedia.org/wiki/Particle-in-Cell%E6%B3%95">cell method</a> と呼ばれるモデルでもある．こうして粒子を増やすことで，単一相のシステムに対するより良いモデルになるだろうが，二相以上のシステムには限界がある．</p>
<p>以上の仮定から，系のエネルギーが次のように与えられる： <span class="math display">\[
E=\frac{1}{2}\sum_{i\ne j\in[N]}V(d_{ij}).
\]</span></p>
<p>この系の平衡状態の性質を計算するには，Gibbs の正準分布を利用し，計算したい物理量 <span class="math inline">\(F\)</span> に対して <span class="math display">\[
\overline{F}=\frac{\int Fe^{-\frac{E}{kT}}d^{2N}pd^{2N}q}{\int e^{-\frac{E}{kT}}d^{2N}pd^{2N}q}
\]</span> を計算すれば良い．ただし，<span class="math inline">\(d^{2n}pd^{2n}q\)</span> は <span class="math inline">\(4N\)</span> 次元相空間上の体積要素である．</p>
<p>加えて，ここではポテンシャル <span class="math inline">\(V\)</span> は位置のみの引数としているから，<span class="math inline">\(2N\)</span> 次元上でのみ計算すれば良い．</p>
<p>このような数百次元上での積分を数値的方法で実行するのは明らかに実行可能でないから，Monte Carlo 法に頼らざるを得ない．と言っても，決定論的な点で値を計算する代わりに，ランダムに点をうつ，というだけの違いではある．</p>
<p>最も簡単な実装としては，ランダムに <span class="math inline">\(N\)</span> 粒子を配置してエネルギーを計算し（重点荷重），これにウェイトをつけて足していくということが考えられる（重点サンプリングだ！）．しかし，高エネルギーの配置もたくさん生成してしまうから，これによる効率の低減が避けられない（提案分布が悪いのだ！）．</p>
<p>そこで我々は <strong>modified Monte Carlo method</strong> を考える．<strong>そもそも確率 <span class="math inline">\(e^{-\frac{E}{kT}}\)</span> からサンプルを生成し，荷重を一様にすることを目指す</strong>．</p>
</section>
<section id="アルゴリズムの記述" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="アルゴリズムの記述"><span class="header-section-number">3.2</span> アルゴリズムの記述</h3>
<p>これは次のようにする．まず適当に初期分布を決める（格子点上に <span class="math inline">\(N\)</span> 粒子を配置するなど）．そしてこれをアップデートしていく： <span class="math display">\[
X\mapsto X+\alpha\xi_1
\]</span> <span class="math display">\[
Y\mapsto Y+\alpha\xi_2
\]</span> <span class="math inline">\(\alpha&gt;0\)</span> は一度にどれくらい動かすかを調節するパラメータであり，<span class="math inline">\(\xi_1,\xi_2\in(0,1)\)</span> は一様乱数とする．<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<p>すなわち，<span class="math inline">\((X,Y)\)</span> を中心とした一辺 <span class="math inline">\(2\alpha\)</span> の正方形の中で，新たな位置をランダムに決めるのである．<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>この動きによるエネルギーの変化量 <span class="math inline">\(\Delta E\)</span> を計算し，<span class="math inline">\(\Delta E&lt;0\)</span> ならばこれを実行するが，<span class="math inline">\(\Delta E&gt;0\)</span> ならば確率 <span class="math inline">\(e^{-\frac{\Delta E}{kT}}\)</span> によって採択する．</p>
<p>仮に棄却されたとしても，そのポジションから新たな Monte Carlo 標本を取り，最終的に <span class="math display">\[
\overline{F}=\frac{1}{M}\sum_{j=1}^MF_j
\]</span> を推定量とする．</p>
</section>
<section id="アルゴリズムの有効性の検証" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="アルゴリズムの有効性の検証"><span class="header-section-number">3.3</span> アルゴリズムの有効性の検証</h3>
<p>まずこの系はエルゴードであると主張しているが，その論証は「任意の粒子が任意の位置に行くポテンシャルがあるため，この手法はエルゴード的である」で終わっている．エルゴードという単語を「任意の状態からもう一つの任意の状態に遷移可能である」という意味で使っている．これは現代的には既約性という．<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<p>続いて，この系をたくさんコピーしてアンサンブルを考えたとき，状態 <span class="math inline">\(r\)</span> にいるアンサンブルの数 <span class="math inline">\(\nu_r\)</span> は <span class="math display">\[
\nu_r\,\propto\,e^{-\frac{E_r}{kT}}
\]</span> を満たすことを示したい．その論証は，上の比率から崩れていたら，平衡に至る方向へ移動が起こるということを具体的に議論している．</p>
<p>以上の２点から，提案されたアルゴリズムは正準分布に収束することの根拠としている．</p>
<p>このアンサンブルによる考え方は極めて直感的に訴える．実際，この語彙を用いて，棄却された場合は元々の状態を Monte Carlo サンプルとしてダブルカウントすべきであることを説明している．これをしなければ，低エネルギー状態のアンサンブルの数を不当に低く評価してしまう，という説明である．</p>
<p>ただし，<strong>このアンサンブルによる考え方は自然に我々の思考を詳細釣り合い条件に絞っている</strong>．</p>
</section>
<section id="附言" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="附言"><span class="header-section-number">3.4</span> 附言</h3>
<p>収束の速さについて注意喚起しているのみで，ステップサイズ <span class="math inline">\(\alpha&gt;0\)</span> は大きすぎても棄却率が高まり，小さすぎても攪拌が遅くなるということ以外具体的なことは触れていない．</p>
</section>
</section>
<section id="実験" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="実験"><span class="header-section-number">4</span> 実験</h2>
<blockquote class="blockquote">
<p>In the case of two-dimensional rigid spheres, runs made with 56 particles and with 224 particles agreed within statistical error. For a computing time of a few hours with presently available electronic computers, it seems possible to obtain the pressure for a given volume and temperature to an accuracy of a few percent. In the case of two-dimensional rigid spheres our results are in agreement with the free volume approximation for <span class="math inline">\(A/A_0&lt; 1.8\)</span> and with a five-term virial expansion for <span class="math inline">\(A/A_0&gt; 2.5\)</span>. There is no indication of a phase transition.</p>
</blockquote>
<p>16 step を焼き入れとし，48-64 いてレーションを実行するのに，MANIAC で 4-5時間かかったという．</p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" data-line-spacing="2" role="list">
<div id="ref-Eckhardt1987" class="csl-entry" role="listitem">
Eckhardt, R. (1987). <span class="nocase">Stan Ulam, John von Neumann, and the Monte Carlo Method</span>. <em>Los Alamos Science Special Issue</em>, <em>15</em>, 131–143. <a href="http://www-star.st-and.ac.uk/~kw25/teaching/mcrt/MC_history_3.pdf">http://www-star.st-and.ac.uk/~kw25/teaching/mcrt/MC_history_3.pdf</a>
</div>
<div id="ref-Hastings1970" class="csl-entry" role="listitem">
Hastings, W. K. (1970). Monte carlo sampling methods using markov chains and their applications. <em>Biometrika</em>, <em>57</em>(1), 97–109. <a href="https://www.jstor.org/stable/2334940">https://www.jstor.org/stable/2334940</a>
</div>
<div id="ref-Metropolis1987" class="csl-entry" role="listitem">
Metropolis, N. (1987). The beginning of the monte carlo method. <em>Los Alamos Science Special Issue</em>, <em>15</em>, 125–130. <a href="https://library.lanl.gov/cgi-bin/getfile?00326866.pdf">https://library.lanl.gov/cgi-bin/getfile?00326866.pdf</a>
</div>
<div id="ref-Metropolis+1953" class="csl-entry" role="listitem">
Metropolis, N., Rosenbluth, A. W., Rosenbluth, M. N., Teller, A. H., &amp; Teller, E. (1953). Equation of state calculations by fast computing machines. <em>The Journal of Chemical Physics</em>, <em>21</em>(6), 1087–1092. <a href="https://doi.org/10.1063/1.1699114">https://doi.org/10.1063/1.1699114</a>
</div>
<div id="ref-Robert-Casella2011" class="csl-entry" role="listitem">
Robert, C., &amp; Casella, G. (2011). A short history of markov chain monte carlo: Subjective recollections from incomplete data. <em>Statistical Science</em>, <em>26</em>(1), 102–115. <a href="http://www.jstor.org/stable/23059158">http://www.jstor.org/stable/23059158</a>
</div>
<div id="ref-Tartero-Krauth2023" class="csl-entry" role="listitem">
Tartero, G., &amp; Krauth, W. (2023). <em>Concepts in monte carlo sampling</em>. <a href="https://arxiv.org/abs/2309.03136">https://arxiv.org/abs/2309.03136</a>
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>さらに，Lennard-Jones ポテンシャルについての２次元のケースも考えており，次のレポートで報告される予定であるという．<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>ここで乱数生成法に関して注記されている．これは <strong>middle square process</strong> で生成する，としている．<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>なお，periodic assumption をしているため（長方形の系の外には同様の系が無数に並んでいるとしたため），境界の外に出ようとした場合は衝突するのではなく，反対側の辺から入ってくるものとする．<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><span class="citation" data-cites="Robert-Casella2011">(<a href="#ref-Robert-Casella2011" role="doc-biblioref">Robert &amp; Casella, 2011</a>)</span> も指摘している．<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://utteranc.es/client.js" repo="quarto-dev/quarto-web" issue-term="pathname" theme="github-light" crossorigin="anonymous" async="">
</script>
</div> <!-- /content -->




</body></html>