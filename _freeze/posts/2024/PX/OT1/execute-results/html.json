{
  "hash": "fdf8c8cd21a664d90fbe61dbece1971d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"最適輸送とそのエントロピー緩和\"\nsubtitle: \"Iterative Proportional Fitting / Sinkhorn-Knopp Algorithm\"\nauthor: \"司馬 博文\"\ndate: 3/13/2024\ndate-modified: 10/11/2024\ncategories: [Computation, P(X), Python]\nabstract: |\n  Python で最適輸送写像を計算する方法を解説する．\n  直接最適輸送問題を `POT` (Python Optimal Transport) で解く．この方法は原子の数 $N$ に対して $O(N^3\\log N)$ の複雑性を持つ．\n  一方で，エントロピー正則化項 $\\epsilon\\operatorname{Ent}(\\pi)$ を導入したエントロピー最適輸送問題は Sinkhorn アルゴリズムで高速に解くことができる．\n  これには `OTT-JAX` パッケージを用いる．\n  $\\epsilon\\to0$ の極限で元の最適輸送問題の解を得る．\nexecute:\n    cache: true\ncode-fold: false\nbibliography: \n    - ../../../assets/mathematics.bib\n    - ../../../assets/bib.bib\ncsl: ../../../assets/apalike.csl\nlisting: \n    -   id: ot-listing\n        type: grid\n        sort: false\n        contents:\n            - \"OT.qmd\"\n            - \"../Bridges/SB1.qmd\"\n        date-format: iso\n        fields: [title,image,date,subtitle]\n---\n\n## 関連記事一覧 {.unnumbered .unlisted}\n\n::: {#ot-listing}\n:::\n\n::: {.hidden}\n\n::: {.content-visible when-format=\"html\"}\n\nA Blog Entry on Bayesian Computation by an Applied Mathematician\n\n$$\n\n\\renewcommand{\\P}{\\operatorname{P}}\\newcommand{\\E}{\\operatorname{E}}\n\\newcommand{\\R}{\\mathbb{R}}\\newcommand{\\F}{\\mathcal{F}}\n\\newcommand{\\abs}[1]{\\lvert#1\\rvert}\\newcommand{\\Abs}[1]{\\left|#1\\right|}\\newcommand{\\ABs}[1]{\\biggl|#1\\biggr|}\\newcommand{\\norm}[1]{\\|#1\\|}\\newcommand{\\Norm}[1]{\\left\\|#1\\right\\|}\\newcommand{\\NOrm}[1]{\\biggl\\|#1\\biggr\\|}\\newcommand{\\Brace}[1]{\\left\\{#1\\right\\}}\\newcommand{\\BRace}[1]{\\biggl\\{#1\\biggr\\}}\\newcommand{\\paren}[1]{\\left(#1\\right)}\\newcommand{\\Paren}[1]{\\biggr(#1\\biggl)}\\newcommand{\\brac}[1]{\\langle#1\\rangle}\\newcommand{\\Brac}[1]{\\left\\langle#1\\right\\rangle}\\newcommand{\\BRac}[1]{\\biggl\\langle#1\\biggr\\rangle}\\newcommand{\\bra}[1]{\\left\\langle#1\\right|}\\newcommand{\\ket}[1]{\\left|#1\\right\\rangle}\\newcommand{\\Square}[1]{\\left[#1\\right]}\\newcommand{\\SQuare}[1]{\\biggl[#1\\biggr]}\\newcommand{\\rN}{\\mathrm{N}}\\newcommand{\\ov}[1]{\\overline{#1}}\\newcommand{\\un}[1]{\\underline{#1}}\\newcommand{\\wt}[1]{\\widetilde{#1}}\\newcommand{\\wh}[1]{\\widehat{#1}}\\newcommand{\\pp}[2]{\\frac{\\partial #1}{\\partial #2}}\\newcommand{\\ppp}[3]{\\frac{\\partial #1}{\\partial #2\\partial #3}}\\newcommand{\\dd}[2]{\\frac{d #1}{d #2}}\\newcommand{\\floor}[1]{\\lfloor#1\\rfloor}\\newcommand{\\Floor}[1]{\\left\\lfloor#1\\right\\rfloor}\\newcommand{\\ceil}[1]{\\lceil#1\\rceil}\\newcommand{\\ocinterval}[1]{(#1]}\\newcommand{\\cointerval}[1]{[#1)}\\newcommand{\\COinterval}[1]{\\left[#1\\right)}\\newcommand{\\iso}{\\overset{\\sim}{\\to}}\n\n\n\n\\newcommand{\\y}{\\b{y}}\\newcommand{\\mi}{\\,|\\,}\\newcommand{\\Mark}{\\mathrm{Mark}}\n\\newcommand{\\argmax}{\\operatorname*{argmax}}\\newcommand{\\argmin}{\\operatorname*{argmin}}\n\n\\newcommand{\\pr}{\\mathrm{pr}}\\newcommand{\\Conv}{\\operatorname{Conv}}\\newcommand{\\cU}{\\mathcal{U}}\n\\newcommand{\\Map}{\\mathrm{Map}}\\newcommand{\\dom}{\\mathrm{Dom}\\;}\\newcommand{\\cod}{\\mathrm{Cod}\\;}\\newcommand{\\supp}{\\mathrm{supp}\\;}\n\\newcommand{\\grad}{\\operatorname{grad}}\\newcommand{\\rot}{\\operatorname{rot}}\\renewcommand{\\div}{\\operatorname{div}}\\newcommand{\\tr}{\\operatorname{tr}}\\newcommand{\\Tr}{\\operatorname{Tr}}\\newcommand{\\KL}{\\operatorname{KL}}\\newcommand{\\JS}{\\operatorname{JS}}\\newcommand{\\ESS}{\\operatorname{ESS}}\\newcommand{\\MSE}{\\operatorname{MSE}}\\newcommand{\\erf}{\\operatorname{erf}}\\newcommand{\\arctanh}{\\operatorname{arctanh}}\\newcommand{\\pl}{\\operatorname{pl}}\\newcommand{\\minimize}{\\operatorname{minimize}}\\newcommand{\\subjectto}{\\operatorname{subject to}}\\newcommand{\\sinc}{\\operatorname{sinc}}\\newcommand{\\Ent}{\\operatorname{Ent}}\\newcommand{\\Polya}{\\operatorname{Polya}}\\newcommand{\\Exp}{\\operatorname{Exp}}\\newcommand{\\codim}{\\operatorname{codim}}\\newcommand{\\sgn}{\\operatorname{sgn}}\\newcommand{\\rank}{\\operatorname{rank}}\n\n\\newcommand{\\vctr}[2]{\\begin{pmatrix}#1\\\\#2\\end{pmatrix}}\\newcommand{\\vctrr}[3]{\\begin{pmatrix}#1\\\\#2\\\\#3\\end{pmatrix}}\\newcommand{\\mtrx}[4]{\\begin{pmatrix}#1&#2\\\\#3&#4\\end{pmatrix}}\\newcommand{\\smtrx}[4]{\\paren{\\begin{smallmatrix}#1&#2\\\\#3&#4\\end{smallmatrix}}}\\newcommand{\\Ker}{\\mathrm{Ker}\\;}\\newcommand{\\Coker}{\\mathrm{Coker}\\;}\\newcommand{\\Coim}{\\mathrm{Coim}\\;}\\newcommand{\\lcm}{\\mathrm{lcm}}\\newcommand{\\GL}{\\mathrm{GL}}\\newcommand{\\SL}{\\mathrm{SL}}\\newcommand{\\alt}{\\mathrm{alt}}\n\n\\renewcommand{\\Re}{\\mathrm{Re}\\;}\\renewcommand{\\Im}{\\mathrm{Im}\\,}\\newcommand{\\Gal}{\\mathrm{Gal}}\\newcommand{\\PGL}{\\mathrm{PGL}}\\newcommand{\\PSL}{\\mathrm{PSL}}\\newcommand{\\Log}{\\mathrm{Log}\\,}\\newcommand{\\Res}{\\mathrm{Res}\\,}\\newcommand{\\on}{\\mathrm{on}\\;}\\newcommand{\\hatC}{\\widehat{\\C}}\\newcommand{\\hatR}{\\hat{\\R}}\\newcommand{\\PV}{\\mathrm{P.V.}}\\newcommand{\\diam}{\\mathrm{diam}}\\newcommand{\\Area}{\\mathrm{Area}}\\newcommand{\\Lap}{\\Laplace}\\newcommand{\\f}{\\mathbf{f}}\\newcommand{\\cR}{\\mathcal{R}}\\newcommand{\\const}{\\mathrm{const.}}\\newcommand{\\Om}{\\Omega}\\newcommand{\\Cinf}{C^\\infty}\\newcommand{\\ep}{\\epsilon}\\newcommand{\\dist}{\\mathrm{dist}}\\newcommand{\\opart}{\\o{\\partial}}\\newcommand{\\Length}{\\mathrm{Length}}\n\n\\newcommand{\\cA}{\\mathcal{A}}\\newcommand{\\cO}{\\mathcal{O}}\\newcommand{\\cW}{\\mathcal{W}}\\renewcommand{\\O}{\\mathcal{O}}\\renewcommand{\\S}{\\mathcal{S}}\\newcommand{\\U}{\\mathcal{U}}\\newcommand{\\V}{\\mathrm{V}}\\newcommand{\\N}{\\mathbb{N}}\\newcommand{\\bN}{\\mathbb{N}}\\newcommand{\\C}{\\mathrm{C}}\\newcommand{\\bC}{\\mathbb{C}}\\newcommand{\\Z}{\\mathcal{Z}}\\newcommand{\\Q}{\\mathbb{Q}}\\newcommand{\\bQ}{\\mathbb{Q}}\\newcommand{\\TV}{\\mathrm{TV}}\\newcommand{\\ORD}{\\mathrm{ORD}}\\newcommand{\\Card}{\\mathrm{Card}\\,}\\newcommand{\\Top}{\\mathrm{Top}}\\newcommand{\\Disc}{\\mathrm{Disc}}\\newcommand{\\Codisc}{\\mathrm{Codisc}}\\newcommand{\\CoDisc}{\\mathrm{CoDisc}}\\newcommand{\\Ult}{\\mathrm{Ult}}\\newcommand{\\ord}{\\mathrm{ord}}\\newcommand{\\bS}{\\mathbb{S}}\\newcommand{\\PConn}{\\mathrm{PConn}}\\newcommand{\\mult}{\\mathrm{mult}}\\newcommand{\\inv}{\\mathrm{inv}}\n\n\\newcommand{\\Der}{\\mathrm{Der}}\\newcommand{\\osub}{\\overset{\\mathrm{open}}{\\subset}}\\newcommand{\\osup}{\\overset{\\mathrm{open}}{\\supset}}\\newcommand{\\al}{\\alpha}\\newcommand{\\K}{\\mathbb{K}}\\newcommand{\\Sp}{\\mathrm{Sp}}\\newcommand{\\g}{\\mathfrak{g}}\\newcommand{\\h}{\\mathfrak{h}}\\newcommand{\\Imm}{\\mathrm{Imm}}\\newcommand{\\Imb}{\\mathrm{Imb}}\\newcommand{\\Gr}{\\mathrm{Gr}}\n\n\\newcommand{\\Ad}{\\mathrm{Ad}}\\newcommand{\\finsupp}{\\mathrm{fin\\;supp}}\\newcommand{\\SO}{\\mathrm{SO}}\\newcommand{\\SU}{\\mathrm{SU}}\\newcommand{\\acts}{\\curvearrowright}\\newcommand{\\mono}{\\hookrightarrow}\\newcommand{\\epi}{\\twoheadrightarrow}\\newcommand{\\Stab}{\\mathrm{Stab}}\\newcommand{\\nor}{\\mathrm{nor}}\\newcommand{\\T}{\\mathbb{T}}\\newcommand{\\Aff}{\\mathrm{Aff}}\\newcommand{\\rsup}{\\triangleright}\\newcommand{\\subgrp}{\\overset{\\mathrm{subgrp}}{\\subset}}\\newcommand{\\Ext}{\\mathrm{Ext}}\\newcommand{\\sbs}{\\subset}\\newcommand{\\sps}{\\supset}\\newcommand{\\In}{\\mathrm{in}\\;}\\newcommand{\\Tor}{\\mathrm{Tor}}\\newcommand{\\p}{\\b{p}}\\newcommand{\\q}{\\mathfrak{q}}\\newcommand{\\m}{\\mathfrak{m}}\\newcommand{\\cS}{\\mathcal{S}}\\newcommand{\\Frac}{\\mathrm{Frac}\\,}\\newcommand{\\Spec}{\\mathrm{Spec}\\,}\\newcommand{\\bA}{\\mathbb{A}}\\newcommand{\\Sym}{\\mathrm{Sym}}\\newcommand{\\Ann}{\\mathrm{Ann}}\\newcommand{\\Her}{\\mathrm{Her}}\\newcommand{\\Bil}{\\mathrm{Bil}}\\newcommand{\\Ses}{\\mathrm{Ses}}\\newcommand{\\FVS}{\\mathrm{FVS}}\n\n\\newcommand{\\Ho}{\\mathrm{Ho}}\\newcommand{\\CW}{\\mathrm{CW}}\\newcommand{\\lc}{\\mathrm{lc}}\\newcommand{\\cg}{\\mathrm{cg}}\\newcommand{\\Fib}{\\mathrm{Fib}}\\newcommand{\\Cyl}{\\mathrm{Cyl}}\\newcommand{\\Ch}{\\mathrm{Ch}}\n\\newcommand{\\rP}{\\mathrm{P}}\\newcommand{\\rE}{\\mathrm{E}}\\newcommand{\\e}{\\b{e}}\\renewcommand{\\k}{\\b{k}}\\newcommand{\\Christ}[2]{\\begin{Bmatrix}#1\\\\#2\\end{Bmatrix}}\\renewcommand{\\Vec}[1]{\\overrightarrow{\\mathrm{#1}}}\\newcommand{\\hen}[1]{\\mathrm{#1}}\\renewcommand{\\b}[1]{\\boldsymbol{#1}}\n\n\\newcommand{\\Inc}{\\mathrm{Inc}}\\newcommand{\\aInc}{\\mathrm{aInc}}\\newcommand{\\HS}{\\mathrm{HS}}\\newcommand{\\loc}{\\mathrm{loc}}\\newcommand{\\Lh}{\\mathrm{L.h.}}\\newcommand{\\Epi}{\\mathrm{Epi}}\\newcommand{\\slim}{\\mathrm{slim}}\\newcommand{\\Ban}{\\mathrm{Ban}}\\newcommand{\\Hilb}{\\mathrm{Hilb}}\\newcommand{\\Ex}{\\mathrm{Ex}}\\newcommand{\\Co}{\\mathrm{Co}}\\newcommand{\\sa}{\\mathrm{sa}}\\newcommand{\\nnorm}[1]{{\\left\\vert\\kern-0.25ex\\left\\vert\\kern-0.25ex\\left\\vert #1 \\right\\vert\\kern-0.25ex\\right\\vert\\kern-0.25ex\\right\\vert}}\\newcommand{\\dvol}{\\mathrm{dvol}}\\newcommand{\\Sconv}{\\mathrm{Sconv}}\\newcommand{\\I}{\\mathcal{I}}\\newcommand{\\nonunital}{\\mathrm{nu}}\\newcommand{\\cpt}{\\mathrm{cpt}}\\newcommand{\\lcpt}{\\mathrm{lcpt}}\\newcommand{\\com}{\\mathrm{com}}\\newcommand{\\Haus}{\\mathrm{Haus}}\\newcommand{\\proper}{\\mathrm{proper}}\\newcommand{\\infinity}{\\mathrm{inf}}\\newcommand{\\TVS}{\\mathrm{TVS}}\\newcommand{\\ess}{\\mathrm{ess}}\\newcommand{\\ext}{\\mathrm{ext}}\\newcommand{\\Index}{\\mathrm{Index}\\;}\\newcommand{\\SSR}{\\mathrm{SSR}}\\newcommand{\\vs}{\\mathrm{vs.}}\\newcommand{\\fM}{\\mathfrak{M}}\\newcommand{\\EDM}{\\mathrm{EDM}}\\newcommand{\\Tw}{\\mathrm{Tw}}\\newcommand{\\fC}{\\mathfrak{C}}\\newcommand{\\bn}{\\boldsymbol{n}}\\newcommand{\\br}{\\boldsymbol{r}}\\newcommand{\\Lam}{\\Lambda}\\newcommand{\\lam}{\\lambda}\\newcommand{\\one}{\\mathbf{1}}\\newcommand{\\dae}{\\text{-a.e.}}\\newcommand{\\das}{\\text{-a.s.}}\\newcommand{\\td}{\\text{-}}\\newcommand{\\RM}{\\mathrm{RM}}\\newcommand{\\BV}{\\mathrm{BV}}\\newcommand{\\normal}{\\mathrm{normal}}\\newcommand{\\lub}{\\mathrm{lub}\\;}\\newcommand{\\Graph}{\\mathrm{Graph}}\\newcommand{\\Ascent}{\\mathrm{Ascent}}\\newcommand{\\Descent}{\\mathrm{Descent}}\\newcommand{\\BIL}{\\mathrm{BIL}}\\newcommand{\\fL}{\\mathfrak{L}}\\newcommand{\\De}{\\Delta}\n\n\\newcommand{\\calA}{\\mathcal{A}}\\newcommand{\\calB}{\\mathcal{B}}\\newcommand{\\D}{\\mathcal{D}}\\newcommand{\\Y}{\\mathcal{Y}}\\newcommand{\\calC}{\\mathcal{C}}\\renewcommand{\\ae}{\\mathrm{a.e.}\\;}\\newcommand{\\cZ}{\\mathcal{Z}}\\newcommand{\\fF}{\\mathfrak{F}}\\newcommand{\\fI}{\\mathfrak{I}}\\newcommand{\\rV}{\\mathrm{V}}\\newcommand{\\cE}{\\mathcal{E}}\\newcommand{\\sMap}{\\sigma\\textrm{-}\\mathrm{Map}}\\newcommand{\\cC}{\\mathcal{C}}\\newcommand{\\comp}{\\complement}\\newcommand{\\J}{\\mathcal{J}}\\newcommand{\\sumN}[1]{\\sum_{#1\\in\\N}}\\newcommand{\\cupN}[1]{\\cup_{#1\\in\\N}}\\newcommand{\\capN}[1]{\\cap_{#1\\in\\N}}\\newcommand{\\Sum}[1]{\\sum_{#1=1}^\\infty}\\newcommand{\\sumn}{\\sum_{n=1}^\\infty}\\newcommand{\\summ}{\\sum_{m=1}^\\infty}\\newcommand{\\sumk}{\\sum_{k=1}^\\infty}\\newcommand{\\sumi}{\\sum_{i=1}^\\infty}\\newcommand{\\sumj}{\\sum_{j=1}^\\infty}\\newcommand{\\cupn}{\\cup_{n=1}^\\infty}\\newcommand{\\capn}{\\cap_{n=1}^\\infty}\\newcommand{\\cupk}{\\cup_{k=1}^\\infty}\\newcommand{\\cupi}{\\cup_{i=1}^\\infty}\\newcommand{\\cupj}{\\cup_{j=1}^\\infty}\\newcommand{\\limn}{\\lim_{n\\to\\infty}}\\renewcommand{\\L}{\\mathcal{L}}\\newcommand{\\cL}{\\mathcal{L}}\\newcommand{\\Cl}{\\mathrm{Cl}}\\newcommand{\\cN}{\\mathcal{N}}\\newcommand{\\Ae}{\\textrm{-a.e.}\\;}\\renewcommand{\\csub}{\\overset{\\textrm{closed}}{\\subset}}\\renewcommand{\\csup}{\\overset{\\textrm{closed}}{\\supset}}\\newcommand{\\wB}{\\wt{B}}\\newcommand{\\cG}{\\mathcal{G}}\\newcommand{\\Lip}{\\mathrm{Lip}}\\newcommand{\\AC}{\\mathrm{AC}}\\newcommand{\\Mol}{\\mathrm{Mol}}\n\n\\newcommand{\\Pe}{\\mathrm{Pe}}\\newcommand{\\wR}{\\wh{\\mathbb{\\R}}}\\newcommand*{\\Laplace}{\\mathop{}\\!\\mathbin\\bigtriangleup}\\newcommand*{\\DAlambert}{\\mathop{}\\!\\mathbin\\Box}\\newcommand{\\bT}{\\mathbb{T}}\\newcommand{\\dx}{\\dslash x}\\newcommand{\\dt}{\\dslash t}\\newcommand{\\ds}{\\dslash s}\n\n\\newcommand{\\round}{\\mathrm{round}}\\newcommand{\\cond}{\\mathrm{cond}}\\newcommand{\\diag}{\\mathrm{diag}}\n\\newcommand{\\Adj}{\\mathrm{Adj}}\\newcommand{\\Pf}{\\mathrm{Pf}}\\newcommand{\\Sg}{\\mathrm{Sg}}\n\n\n\\newcommand{\\aseq}{\\overset{\\text{a.s.}}{=}}\\newcommand{\\deq}{\\overset{\\text{d}}{=}}\\newcommand{\\cV}{\\mathcal{V}}\\newcommand{\\FM}{\\mathrm{FM}}\\newcommand{\\KR}{\\mathrm{KR}}\\newcommand{\\rba}{\\mathrm{rba}}\\newcommand{\\rca}{\\mathrm{rca}}\\newcommand{\\Prob}{\\mathrm{Prob}}\\newcommand{\\X}{\\mathcal{X}}\\newcommand{\\Meas}{\\mathrm{Meas}}\\newcommand{\\as}{\\;\\text{a.s.}}\\newcommand{\\io}{\\;\\mathrm{i.o.}}\\newcommand{\\fe}{\\;\\text{f.e.}}\\newcommand{\\bF}{\\mathbb{F}}\\newcommand{\\W}{\\mathcal{W}}\\newcommand{\\Pois}{\\mathrm{Pois}}\\newcommand{\\iid}{\\text{i.i.d.}}\\newcommand{\\wconv}{\\rightsquigarrow}\\newcommand{\\Var}{\\mathrm{Var}}\\newcommand{\\xrightarrown}{\\xrightarrow{n\\to\\infty}}\\newcommand{\\au}{\\mathrm{au}}\\newcommand{\\cT}{\\mathcal{T}}\\newcommand{\\wto}{\\overset{\\text{w}}{\\to}}\\newcommand{\\dto}{\\overset{\\text{d}}{\\to}}\\newcommand{\\sto}{\\overset{\\text{s}}{\\to}}\\newcommand{\\pto}{\\overset{\\text{p}}{\\to}}\\newcommand{\\mto}{\\overset{\\text{m}}{\\to}}\\newcommand{\\vto}{\\overset{v}{\\to}}\\newcommand{\\Cont}{\\mathrm{Cont}}\\newcommand{\\stably}{\\mathrm{stably}}\\newcommand{\\Np}{\\mathbb{N}^+}\\newcommand{\\oM}{\\overline{\\mathcal{M}}}\\newcommand{\\fP}{\\mathfrak{P}}\\newcommand{\\sign}{\\mathrm{sign}}\n\\newcommand{\\Borel}{\\mathrm{Borel}}\\newcommand{\\Mid}{\\,|\\,}\\newcommand{\\middleMid}{\\;\\middle|\\;}\\newcommand{\\CP}{\\mathrm{CP}}\\newcommand{\\bD}{\\mathbb{D}}\\newcommand{\\bL}{\\mathbb{L}}\\newcommand{\\fW}{\\mathfrak{W}}\\newcommand{\\DL}{\\mathcal{D}\\mathcal{L}}\\renewcommand{\\r}[1]{\\mathrm{#1}}\\newcommand{\\rC}{\\mathrm{C}}\\newcommand{\\qqquad}{\\qquad\\quad}\n\n\\newcommand{\\bit}{\\mathrm{bit}}\n\n\\newcommand{\\err}{\\mathrm{err}}\n\n\\newcommand{\\varparallel}{\\mathbin{\\!/\\mkern-5mu/\\!}}\\newcommand{\\Ri}{\\mathrm{Ri}}\\newcommand{\\Cone}{\\mathrm{Cone}}\\newcommand{\\Int}{\\mathrm{Int}}\n\n\\newcommand{\\pre}{\\mathrm{pre}}\\newcommand{\\om}{\\omega}\n\n\n\\newcommand{\\del}{\\partial}\n\\newcommand{\\LHS}{\\mathrm{LHS}}\\newcommand{\\RHS}{\\mathrm{RHS}}\\newcommand{\\bnu}{\\boldsymbol{\\nu}}\\newcommand{\\interior}{\\mathrm{in}\\;}\\newcommand{\\SH}{\\mathrm{SH}}\\renewcommand{\\v}{\\boldsymbol{\\nu}}\\newcommand{\\n}{\\mathbf{n}}\\newcommand{\\ssub}{\\Subset}\\newcommand{\\curl}{\\mathrm{curl}}\n\n\\newcommand{\\Ei}{\\mathrm{Ei}}\\newcommand{\\sn}{\\mathrm{sn}}\\newcommand{\\wgamma}{\\widetilde{\\gamma}}\n\n\\newcommand{\\Ens}{\\mathrm{Ens}}\n\n\\newcommand{\\cl}{\\mathrm{cl}}\\newcommand{\\x}{\\boldsymbol{x}}\n\n\\newcommand{\\Do}{\\mathrm{Do}}\\newcommand{\\IV}{\\mathrm{IV}}\n\n\\newcommand{\\AIC}{\\mathrm{AIC}}\\newcommand{\\mrl}{\\mathrm{mrl}}\\newcommand{\\dotx}{\\dot{x}}\\newcommand{\\UMV}{\\mathrm{UMV}}\\newcommand{\\BLU}{\\mathrm{BLU}}\n\n\\newcommand{\\comb}[2]{\\begin{pmatrix}#1\\\\#2\\end{pmatrix}}\\newcommand{\\bP}{\\mathbb{P}}\\newcommand{\\compsub}{\\overset{\\textrm{cpt}}{\\subset}}\\newcommand{\\lip}{\\textrm{lip}}\\newcommand{\\BL}{\\mathrm{BL}}\\newcommand{\\G}{\\mathbb{G}}\\newcommand{\\NB}{\\mathrm{NB}}\\newcommand{\\oR}{\\ov{\\R}}\\newcommand{\\liminfn}{\\liminf_{n\\to\\infty}}\\newcommand{\\limsupn}{\\limsup_{n\\to\\infty}}\\newcommand{\\esssup}{\\mathrm{ess.sup}}\\newcommand{\\asto}{\\xrightarrow{\\as}}\\newcommand{\\Cov}{\\mathrm{Cov}}\\newcommand{\\cQ}{\\mathcal{Q}}\\newcommand{\\VC}{\\mathrm{VC}}\\newcommand{\\mb}{\\mathrm{mb}}\\newcommand{\\Avar}{\\mathrm{Avar}}\\newcommand{\\bB}{\\mathbb{B}}\\newcommand{\\bW}{\\mathbb{W}}\\newcommand{\\sd}{\\mathrm{sd}}\\newcommand{\\w}[1]{\\widehat{#1}}\\newcommand{\\bZ}{\\mathbb{Z}}\\newcommand{\\Bernoulli}{\\mathrm{Ber}}\\newcommand{\\Ber}{\\mathrm{Ber}}\\newcommand{\\Mult}{\\mathrm{Mult}}\\newcommand{\\BPois}{\\mathrm{BPois}}\\newcommand{\\fraks}{\\mathfrak{s}}\\newcommand{\\frakk}{\\mathfrak{k}}\\newcommand{\\IF}{\\mathrm{IF}}\\newcommand{\\bX}{\\boldsymbol{X}}\\newcommand{\\bx}{\\boldsymbol{x}}\\newcommand{\\indep}{\\perp\\!\\!\\!\\perp}\\newcommand{\\IG}{\\mathrm{IG}}\\newcommand{\\Levy}{\\mathrm{Levy}}\\newcommand{\\MP}{\\mathrm{MP}}\\newcommand{\\Hermite}{\\mathrm{Hermite}}\\newcommand{\\Skellam}{\\mathrm{Skellam}}\\newcommand{\\Dirichlet}{\\mathrm{Dirichlet}}\\renewcommand{\\Beta}{\\operatorname{Beta}}\\newcommand{\\bE}{\\mathbb{E}}\\newcommand{\\bG}{\\mathbb{G}}\\newcommand{\\MISE}{\\mathrm{MISE}}\\newcommand{\\logit}{\\mathtt{logit}}\\newcommand{\\expit}{\\mathtt{expit}}\\newcommand{\\cK}{\\mathcal{K}}\\newcommand{\\dl}{\\dot{l}}\\newcommand{\\dotp}{\\dot{p}}\\newcommand{\\wl}{\\wt{l}}\\newcommand{\\Gauss}{\\mathrm{Gauss}}\\newcommand{\\fA}{\\mathfrak{A}}\\newcommand{\\under}{\\mathrm{under}\\;}\\newcommand{\\whtheta}{\\wh{\\theta}}\\newcommand{\\Em}{\\mathrm{Em}}\\newcommand{\\ztheta}{{\\theta_0}}\n\\newcommand{\\rO}{\\mathrm{O}}\\newcommand{\\Bin}{\\mathrm{Bin}}\\newcommand{\\rW}{\\mathrm{W}}\\newcommand{\\rG}{\\mathrm{G}}\\newcommand{\\rB}{\\mathrm{B}}\\newcommand{\\rU}{\\mathrm{U}}\\newcommand{\\HG}{\\mathrm{HG}}\\newcommand{\\GAMMA}{\\mathrm{Gamma}}\\newcommand{\\Cauchy}{\\mathrm{Cauchy}}\\newcommand{\\rt}{\\mathrm{t}}\\newcommand{\\rF}{\\mathrm{F}}\n\\newcommand{\\FE}{\\mathrm{FE}}\\newcommand{\\bV}{\\boldsymbol{V}}\\newcommand{\\GLS}{\\mathrm{GLS}}\\newcommand{\\be}{\\boldsymbol{e}}\\newcommand{\\POOL}{\\mathrm{POOL}}\\newcommand{\\GMM}{\\mathrm{GMM}}\\newcommand{\\MM}{\\mathrm{MM}}\\newcommand{\\SSIV}{\\mathrm{SSIV}}\\newcommand{\\JIV}{\\mathrm{JIV}}\\newcommand{\\AR}{\\mathrm{AR}}\\newcommand{\\ILS}{\\mathrm{ILS}}\\newcommand{\\SLS}{\\mathrm{SLS}}\\newcommand{\\LIML}{\\mathrm{LIML}}\n\n\\newcommand{\\Rad}{\\mathrm{Rad}}\\newcommand{\\bY}{\\boldsymbol{Y}}\\newcommand{\\pone}{{(1)}}\\newcommand{\\ptwo}{{(2)}}\\newcommand{\\ps}[1]{{(#1)}}\\newcommand{\\fsub}{\\overset{\\text{finite}}{\\subset}}\n\n\n\\newcommand{\\varlim}{\\varprojlim}\\newcommand{\\Hom}{\\mathrm{Hom}}\\newcommand{\\Iso}{\\mathrm{Iso}}\\newcommand{\\Mor}{\\mathrm{Mor}}\\newcommand{\\Isom}{\\mathrm{Isom}}\\newcommand{\\Aut}{\\mathrm{Aut}}\\newcommand{\\End}{\\mathrm{End}}\\newcommand{\\op}{\\mathrm{op}}\\newcommand{\\ev}{\\mathrm{ev}}\\newcommand{\\Ob}{\\mathrm{Ob}}\\newcommand{\\Ar}{\\mathrm{Ar}}\\newcommand{\\Arr}{\\mathrm{Arr}}\\newcommand{\\Set}{\\mathrm{Set}}\\newcommand{\\Grp}{\\mathrm{Grp}}\\newcommand{\\Cat}{\\mathrm{Cat}}\\newcommand{\\Mon}{\\mathrm{Mon}}\\newcommand{\\Ring}{\\mathrm{Ring}}\\newcommand{\\CRing}{\\mathrm{CRing}}\\newcommand{\\Ab}{\\mathrm{Ab}}\\newcommand{\\Pos}{\\mathrm{Pos}}\\newcommand{\\Vect}{\\mathrm{Vect}}\\newcommand{\\FinVect}{\\mathrm{FinVect}}\\newcommand{\\FinSet}{\\mathrm{FinSet}}\\newcommand{\\FinMeas}{\\mathrm{FinMeas}}\\newcommand{\\OmegaAlg}{\\Omega\\text{-}\\mathrm{Alg}}\\newcommand{\\OmegaEAlg}{(\\Omega,E)\\text{-}\\mathrm{Alg}}\\newcommand{\\Fun}{\\mathrm{Fun}}\\newcommand{\\Func}{\\mathrm{Func}}\n\n\\newcommand{\\Stoch}{\\mathrm{Stoch}}\\newcommand{\\FinStoch}{\\mathrm{FinStoch}}\\newcommand{\\Copy}{\\mathrm{copy}}\\newcommand{\\Delete}{\\mathrm{delete}}\n\\newcommand{\\Bool}{\\mathrm{Bool}}\\newcommand{\\CABool}{\\mathrm{CABool}}\\newcommand{\\CompBoolAlg}{\\mathrm{CompBoolAlg}}\\newcommand{\\BoolAlg}{\\mathrm{BoolAlg}}\\newcommand{\\BoolRng}{\\mathrm{BoolRng}}\\newcommand{\\HeytAlg}{\\mathrm{HeytAlg}}\\newcommand{\\CompHeytAlg}{\\mathrm{CompHeytAlg}}\\newcommand{\\Lat}{\\mathrm{Lat}}\\newcommand{\\CompLat}{\\mathrm{CompLat}}\\newcommand{\\SemiLat}{\\mathrm{SemiLat}}\\newcommand{\\Stone}{\\mathrm{Stone}}\\newcommand{\\Mfd}{\\mathrm{Mfd}}\\newcommand{\\LieAlg}{\\mathrm{LieAlg}}\n\\newcommand{\\Op}{\\mathrm{Op}}\n\\newcommand{\\Sh}{\\mathrm{Sh}}\n\\newcommand{\\Diff}{\\mathrm{Diff}}\n\\newcommand{\\B}{\\mathcal{B}}\\newcommand{\\cB}{\\mathcal{B}}\\newcommand{\\Span}{\\mathrm{Span}}\\newcommand{\\Corr}{\\mathrm{Corr}}\\newcommand{\\Decat}{\\mathrm{Decat}}\\newcommand{\\Rep}{\\mathrm{Rep}}\\newcommand{\\Grpd}{\\mathrm{Grpd}}\\newcommand{\\sSet}{\\mathrm{sSet}}\\newcommand{\\Mod}{\\mathrm{Mod}}\\newcommand{\\SmoothMnf}{\\mathrm{SmoothMnf}}\\newcommand{\\coker}{\\mathrm{coker}}\\newcommand{\\Ord}{\\mathrm{Ord}}\\newcommand{\\eq}{\\mathrm{eq}}\\newcommand{\\coeq}{\\mathrm{coeq}}\\newcommand{\\act}{\\mathrm{act}}\n\n\\newcommand{\\apf}{\\mathrm{apf}}\\newcommand{\\opt}{\\mathrm{opt}}\\newcommand{\\IS}{\\mathrm{IS}}\\newcommand{\\IR}{\\mathrm{IR}}\\newcommand{\\iidsim}{\\overset{\\text{iid}}{\\sim}}\\newcommand{\\propt}{\\,\\propto\\,}\\newcommand{\\bM}{\\mathbb{M}}\\newcommand{\\cX}{\\mathcal{X}}\\newcommand{\\cY}{\\mathcal{Y}}\\newcommand{\\cP}{\\mathcal{P}}\\newcommand{\\ola}[1]{\\overleftarrow{#1}}\n\n\\renewcommand{\\iff}{\\;\\mathrm{iff}\\;}\n\\newcommand{\\False}{\\mathrm{False}}\\newcommand{\\True}{\\mathrm{True}}\n\\newcommand{\\otherwise}{\\mathrm{otherwise}}\n\\newcommand{\\suchthat}{\\;\\mathrm{s.t.}\\;}\n\n\\newcommand{\\cM}{\\mathcal{M}}\\newcommand{\\M}{\\mathbb{M}}\\newcommand{\\cF}{\\mathcal{F}}\\newcommand{\\cD}{\\mathcal{D}}\\newcommand{\\fX}{\\mathfrak{X}}\\newcommand{\\fY}{\\mathfrak{Y}}\\newcommand{\\fZ}{\\mathfrak{Z}}\\renewcommand{\\H}{\\mathcal{H}}\\newcommand{\\cH}{\\mathcal{H}}\\newcommand{\\fH}{\\mathfrak{H}}\\newcommand{\\bH}{\\mathbb{H}}\\newcommand{\\id}{\\mathrm{id}}\\newcommand{\\A}{\\mathcal{A}}\n\\newcommand{\\lmd}{\\lambda}\n\\newcommand{\\Lmd}{\\Lambda}\n\\newcommand{\\cI}{\\mathcal{I}}\n\n\\newcommand{\\Lrarrow}{\\;\\;\\Leftrightarrow\\;\\;}\n\\DeclareMathOperator{\\des}{des}\n\\DeclareMathOperator{\\nd}{nd}\n\\DeclareMathOperator{\\dsep}{d-sep}\n\\DeclareMathOperator{\\sep}{sep}\n\\newcommand{\\rLL}{\\mathrm{LL}}\\newcommand{\\HT}{\\mathrm{HT}}\\newcommand{\\PS}{\\mathrm{PS}}\\newcommand{\\rI}{\\mathrm{I}}\n$$\n\n:::\n\n:::\n\n::: {#2270da41 .cell execution_count=2}\n``` {.python .cell-code code-fold=\"true\" code-summary=\"プロット用の関数の準備\"}\ndef plot_weighted_points(\n    ax,\n    x, a,\n    y, b,\n    title=None, x_label=None, y_label=None\n):\n  ax.scatter(x[:,0], x[:,1], s=5000*a, c='r', edgecolors='k', label=x_label)\n  ax.scatter(y[:,0], y[:,1], s=5000*b, c='b', edgecolors='k', label=y_label)\n  for i in range(np.shape(x)[0]):\n      ax.annotate(str(i+1), (x[i,0], x[i,1]),fontsize=30,color='black')\n  for i in range(np.shape(y)[0]):\n      ax.annotate(str(i+1), (y[i,0], y[i,1]),fontsize=30,color='black')\n  if x_label is not None or y_label is not None:\n    ax.legend(fontsize=20)\n  ax.axis('off')\n  ax.set_title(title, fontsize=25)\n\ndef plot_assignement(\n    ax,\n    x, a,\n    y, b,\n    optimal_plan,\n    title=None, x_label=None, y_label=None\n):\n  plot_weighted_points(\n    ax=ax,\n    x=x, a=a,\n    y=y, b=b,\n    title=None,\n    x_label=x_label, y_label=y_label\n  )\n  for i in range(optimal_plan.shape[0]):\n      for j in range(optimal_plan.shape[1]):\n          ax.plot([x[i,0], y[j,0]], [x[i,1], y[j,1]], c='k', lw=30*optimal_plan[i,j], alpha=0.8)\n  ax.axis('off')\n  ax.set_title(title, fontsize=30)\n\ndef plot_assignement_1D(\n    ax,\n    x, y,\n    title=None\n):\n  plot_points_1D(\n    ax,\n    x, y,\n    title=None\n  )\n  x_sorted = np.sort(x)\n  y_sorted = np.sort(y)\n  assert len(x) == len(y), \"x and y must have the same shape.\"\n  for i in range(len(x)):\n    ax.hlines(\n        y=0,\n        xmin=min(x_sorted[i], y_sorted[i]),\n        xmax=max(x_sorted[i], y_sorted[i]),\n        color='k',\n        lw=10\n    )\n  ax.axis('off')\n  ax.set_title(title, fontsize=30)\n\ndef plot_points_1D(\n    ax,\n    x, y,\n    title=None\n):\n  n = len(x)\n  a = np.ones(n) / n\n  ax.scatter(x, np.zeros(n), s=1000*a, c='r')\n  ax.scatter(y, np.zeros(n), s=1000*b, c='b')\n  min_val = min(np.min(x), np.min(y))\n  max_val = max(np.max(x), np.max(y))\n  for i in range(n):\n      ax.annotate(str(i+1), xy=(x[i], 0.005), size=30, color='r', ha='center')\n  for j in range(n):\n      ax.annotate(str(j+1), xy=(y[j], 0.005), size=30, color='b', ha='center')\n  ax.axis('off')\n  ax.plot(np.linspace(min_val, max_val, 10), np.zeros(10))\n  ax.set_title(title, fontsize=30)\n\ndef plot_consistency(\n    ax,\n    reg_strengths,\n    plan_diff, distance_diff\n):\n  ax[0].loglog(reg_strengths, plan_diff, lw=4)\n  ax[0].set_ylabel('$||P^* - P_\\epsilon^*||_F$', fontsize=25)\n  ax[1].tick_params(which='both', size=20)\n  ax[0].grid(ls='--')\n  ax[1].loglog(reg_strengths, distance_diff, lw=4)\n  ax[1].set_xlabel('Regularization Strength $\\epsilon$', fontsize=25)\n  ax[1].set_ylabel(r'$ 100 \\cdot \\frac{\\langle C, P^*_\\epsilon \\rangle - \\langle C, P^* \\rangle}{\\langle C, P^* \\rangle} $', fontsize=25)\n  ax[1].tick_params(which='both', size=20)\n  ax[1].grid(ls='--')\n```\n:::\n\n\n## 最適輸送\n\n### はじめに\n\nPOT パッケージ（[Docs](https://pythonot.github.io/) / [GitHub](https://github.com/PythonOT/POT)）を用いる．\n\n```zsh\npip install POT\npip install cloudpickle\n```\n\n::: {#37142bbc .cell execution_count=3}\n``` {.python .cell-code}\nimport ot\nimport numpy as np\nimport os\nfrom typing import Callable\nimport matplotlib.pyplot as plt\n```\n:::\n\n\n### 最適輸送問題\n\nWe will solve the Bakeries/Cafés problem of transporting croissants from a number of Bakeries to Cafés.\n\nWe use fictional positions, production and sale numbers. We impose that the total croissant production is equal to the number of croissants sold, so that Bakeries and Cafés can be represented as measures with the same total mass. Then, up to normalization, they can be processed as probability measures.\n\nMathematically, we have acess to the position of the $m$ Bakeries as points in $\\mathbb{R}^2$ via $x \\in \\mathbb{R}^{n \\times 2}$ and their respective production via $a \\in \\mathbb{R}^m$ which describe the source point cloud. The Cafés where the croissants are sold are also defined by their position $y \\in \\mathbb{R}^{m \\times 2}$ and the quantity of croissants sold by $b \\in \\mathbb{R}^{m}$.\n\nAfterwards, the Bakeries are represented by the probability measure $\\mu = \\sum_{i=1}^n a_i \\delta_{x_i}$ and the Cafés by $\\nu = \\sum_{j=1}^n b_j \\delta_{y_j}$. Calculating the optimal assignment of the croissants delivered by the Bakeries to the Cafés remains to calculating the optimal transport between the probability measures $\\mu$ and $\\nu$.\n\nLet's download the data and check that the total croissant production is equal to the number of croissants sold.\n\n::: {#b282aef6 .cell execution_count=4}\n``` {.python .cell-code}\n# Load the data\nimport pickle\nfrom urllib.request import urlopen\nimport cloudpickle as cp\n\ncroissants = cp.load(urlopen('https://marcocuturi.net/data/croissants.pickle'))\n\nbakery_pos = croissants['bakery_pos']\nbakery_prod = croissants['bakery_prod']\ncafe_pos = croissants['cafe_pos']\ncafe_prod = croissants['cafe_prod']\n\nprint('Bakery productions =', bakery_prod)\nprint('Total number of croissants =', bakery_prod.sum())\nprint(\"\")\nprint('Café sales =', cafe_prod)\nprint('Total number of croissants sold =', cafe_prod.sum())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBakery productions = [31. 48. 82. 30. 40. 48. 89. 73.]\nTotal number of croissants = 441.0\n\nCafé sales = [82. 88. 92. 88. 91.]\nTotal number of croissants sold = 441.0\n```\n:::\n:::\n\n\nWe now normalize the weight vectors $a$ and $b$, i.e. the production and the sales, to deal with probability measures.\n\n::: {#3b21b7ad .cell executionInfo='{\"elapsed\":11,\"status\":\"error\",\"timestamp\":1702203316439,\"user\":{\"displayName\":\"Mahmoud Hegazy\",\"userId\":2035046206960435200},\"user_tz\":-60}' outputId='5ce2d95f-8a07-4576-ba50-94c1db2e9093' execution_count=5}\n``` {.python .cell-code}\nbakery_prod = bakery_prod / bakery_prod.sum()\ncafe_prod = cafe_prod / cafe_prod.sum()\n```\n:::\n\n\nThen, we plot the probability measures (the weighted point clouds) in $\\mathbb{R}^2$.\n\n::: {#d689bddb .cell executionInfo='{\"elapsed\":9,\"status\":\"aborted\",\"timestamp\":1702203316439,\"user\":{\"displayName\":\"Mahmoud Hegazy\",\"userId\":2035046206960435200},\"user_tz\":-60}' execution_count=6}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(10, 8))\nplot_weighted_points(\n    ax,\n    x=bakery_pos,\n    a=bakery_prod,\n    x_label=\"Bakeries\",\n    y=cafe_pos,\n    y_label=\"Cafés\",\n    b=cafe_prod,\n    title=\"Bakeries and Cafés\"\n)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-6-output-1.png){width=763 height=645}\n:::\n:::\n\n\n### Solving the problem\n\n\nTo compute the optimal transport, we will consider three different costs:\n\n* $\\ell_1$: $c(x, y) = \\|x - y\\|_1$ , (Manhattan distance)\n* $\\ell_2$: $c(x, y) = \\|x - y\\|_2$, (Euclidean distance)\n* $\\ell_2^2$: $c(x, y) = \\|x - y\\|_2^2$ (Squared-Euclidean distance)\n\nNote that we expect different optimal transport plans for different costs.\n\n***\n**Question:**\n\n * Complete the following function that computes a cost matrix $C$ from two set of points $x, y$ and a cost function $c$. Compute the three costs matrices $C_{\\ell_1}, C_{\\ell_2}, C_{\\ell_2^2}\\in \\mathbb{R}^{n \\times m}$ using that function.\n * What cost should be used to minimize the total distance traveled by the driver that delivers croissants from Bakeries to Cafés?\n\n**Answer:**\n\n::: {#44e09e75 .cell execution_count=7}\n``` {.python .cell-code}\nbakery_pos\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\narray([[184.86464733, 201.8163543 ],\n       [449.3486663 , 168.40784664],\n       [245.41756746, 288.12166576],\n       [273.95400109, 364.68282915],\n       [494.58935376, 336.8424061 ],\n       [738.19305545, 238.70491485],\n       [736.10502372, 375.12298779],\n       [537.74200949, 482.30861653]])\n```\n:::\n:::\n\n\n::: {#f0aa734a .cell execution_count=8}\n``` {.python .cell-code}\ncafe_pos\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\narray([[302.08410452, 442.78633642],\n       [345.1162221 , 368.52123027],\n       [449.226184  , 201.94529124],\n       [454.08464888, 387.95508982],\n       [627.60125204, 408.7770822 ]])\n```\n:::\n:::\n\n\n::: {#a287cbdc .cell executionInfo='{\"elapsed\":6,\"status\":\"error\",\"timestamp\":1702200757600,\"user\":{\"displayName\":\"Mahmoud Hegazy\",\"userId\":2035046206960435200},\"user_tz\":-60}' outputId='9e68a2b2-34bb-4a79-fdb8-941a02bd63a8' execution_count=9}\n``` {.python .cell-code}\ndef get_cost_matrix(\n    x: np.ndarray,\n    y: np.ndarray,\n    cost_fn: Callable\n) -> np.ndarray:\n  \"\"\"\n  Compute the pairwise cost matrix between the n points in ``x`` and the m points in ``y``.\n  It should output a matrix of size n x m.\n  \"\"\"\n  return np.array([cost_fn(x_,y_) for x_ in x for y_ in y]).reshape(x.shape[0],y.shape[0])\n\n\n# compute cost matrices for different costs\nC_l1 = get_cost_matrix(\n    x=bakery_pos, y=cafe_pos,\n    cost_fn= lambda x,y : sum(np.abs(x-y))\n  )\n\nC_l2 = get_cost_matrix(\n    x=bakery_pos, y=cafe_pos,\n    cost_fn= lambda x,y : sum((x-y)**2)\n)\nC_l2_sq = get_cost_matrix(\n    x=bakery_pos, y=cafe_pos,\n    cost_fn= lambda x,y : sum(np.sqrt((x-y)**2))\n)\n\n# print shapes of cost matrices\nprint(\n    f\"Shape of C_l1: {C_l1.shape}\\n\"\n    f\"Shape of C_l2: {C_l2.shape}\\n\"\n    f\"Shape of C_l2_sq: {C_l2_sq.shape}\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nShape of C_l1: (8, 5)\nShape of C_l2: (8, 5)\nShape of C_l2_sq: (8, 5)\n```\n:::\n:::\n\n\n***\n\nWe can now compute the Optimal Transport plan to transport the croissants from the bakeries to the cafés, for the three different costs.\n\n\n***\n**Question:**\n\n* Complete the following fuction that takes as input the cost matrix $C$ and the weights vectors $a$ and $b$ and outputs the optimal transport plan and the optimal transport cost using the `ot.emd` function. It has an option to display the results.\n* Use that function to compute and display the optiaml plan and the optimal cost for $\\ell_1, \\ell_2$ and $\\ell_2^2$ geometries.\n\n**Remark:** See https://pythonot.github.io/ for informations on the `ot.emd` function.\n\n**Answer:**\n\n::: {#06c24488 .cell execution_count=10}\n``` {.python .cell-code}\ndef compute_transport(\n    C: np.ndarray,\n    a: np.ndarray,\n    b: np.ndarray,\n    verbose: bool = False,\n):\n  \"\"\"\n  Compute the optimal transport plan and the optimal transport cost\n  for cost matrix ``C`` and weight vectors $a$ and $b$.\n  If ``verbose`` is set to True, it displays the results.\n  \"\"\"\n  optimal_plan = ot.emd(a,b,C)\n  optimal_cost = np.sum(optimal_plan * C)\n  if verbose:\n    print(\n        f\"optimal transport plan: \\n{optimal_plan}\"\n    )\n    print(\n        f\"transport cost: {optimal_cost}\"\n    )\n  return optimal_plan, optimal_cost\n```\n:::\n\n\n::: {#dfcb78d6 .cell execution_count=11}\n``` {.python .cell-code}\n# l1 geometry\nprint(\"l1 geometry:\")\noptimal_plan_l1_croissant, optimal_cost_l1_croissant = compute_transport(\n    C=C_l1,\n    a=bakery_prod,\n    b=cafe_prod,\n    verbose=True\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nl1 geometry:\noptimal transport plan: \n[[0.07029478 0.         0.         0.         0.        ]\n [0.         0.         0.10884354 0.         0.        ]\n [0.05442177 0.13151927 0.         0.         0.        ]\n [0.         0.06802721 0.         0.         0.        ]\n [0.         0.         0.         0.09070295 0.        ]\n [0.         0.         0.09977324 0.00453515 0.00453515]\n [0.         0.         0.         0.         0.20181406]\n [0.06122449 0.         0.         0.10430839 0.        ]]\ntransport cost: 177.28420815406028\n```\n:::\n:::\n\n\n::: {#32a196cb .cell execution_count=12}\n``` {.python .cell-code}\n# l2 geometry\nprint(\"l2 geometry:\")\noptimal_plan_l2_croissant, optimal_cost_l2_croissant = compute_transport(\n    C=C_l2,\n    a=bakery_prod,\n    b=cafe_prod,\n    verbose=True\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nl2 geometry:\noptimal transport plan: \n[[0.         0.07029478 0.         0.         0.        ]\n [0.         0.         0.10884354 0.         0.        ]\n [0.11791383 0.06802721 0.         0.         0.        ]\n [0.06802721 0.         0.         0.         0.        ]\n [0.         0.06122449 0.         0.02947846 0.        ]\n [0.         0.         0.09977324 0.00453515 0.00453515]\n [0.         0.         0.         0.         0.20181406]\n [0.         0.         0.         0.16553288 0.        ]]\ntransport cost: 24576.370543882178\n```\n:::\n:::\n\n\n::: {#8599807b .cell execution_count=13}\n``` {.python .cell-code}\n# squared l2 geometry\nprint(\"squared l2 geometry:\")\noptimal_plan_l2_sq_croissant, optimal_cost_l2_sq_croissant = compute_transport(\n    C=C_l2_sq,\n    a=bakery_prod,\n    b=cafe_prod,\n    verbose=True\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsquared l2 geometry:\noptimal transport plan: \n[[0.07029478 0.         0.         0.         0.        ]\n [0.         0.         0.10884354 0.         0.        ]\n [0.05442177 0.13151927 0.         0.         0.        ]\n [0.         0.06802721 0.         0.         0.        ]\n [0.         0.         0.         0.09070295 0.        ]\n [0.         0.         0.09977324 0.00453515 0.00453515]\n [0.         0.         0.         0.         0.20181406]\n [0.06122449 0.         0.         0.10430839 0.        ]]\ntransport cost: 177.28420815406028\n```\n:::\n:::\n\n\n***\n\nNow, we can visualize the assignement induced by each geometry.\n\n::: {#e13eacbc .cell executionInfo='{\"elapsed\":1831,\"status\":\"ok\",\"timestamp\":1677230871731,\"user\":{\"displayName\":\"quentin Feron\",\"userId\":3625065177957837000},\"user_tz\":-60}' execution_count=14}\n``` {.python .cell-code}\nfig, ax = plt.subplots(\n    1, 3, figsize=(9*3, 7)\n)\nplans = [optimal_plan_l1_croissant,\n         optimal_plan_l2_croissant,\n         optimal_plan_l2_sq_croissant]\ntitles = [r\"$\\ell_1$ geometry\", r\"$\\ell_2$ geometry\", r\"$\\ell_2^2$ geometry\"]\n\nfor axes, plan, title in zip(ax, plans, titles):\n  plot_assignement(\n      ax=axes,\n      x=bakery_pos, a=bakery_prod, x_label=\"Bakeries\",\n      y=cafe_pos, b=cafe_prod, y_label=\"Cafés\",\n      optimal_plan=plan,\n      title=title\n  )\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-14-output-1.png){width=2028 height=586}\n:::\n:::\n\n\n### In dimension $d = 1$\n\nLet assume in this subsection that the cost is of the form $c(x, y) = \\|x - y\\|_p^q$ with $p, q \\geq 1$, which covers the costs we considered in the previous examples, and that the points are in $\\mathbb{R}$, i.e. $x_1, ..., x_n, y_1, ... , y_n \\in \\mathbb{R}$. Then, computing OT boils down to sorting the points. Indeed, for all costs of the above form, the optimal permutation between $x$ and $y$ is $\\sigma^* = \\sigma_x^{-1} \\circ \\sigma_y$ where $\\sigma_x$ is the permutation sorting the $x_i$ and $\\sigma_y$ the one sorting the $y_i$. In particular, one has:\n\n$$\nW_c(\\mu, \\nu) = \\frac{1}{n} \\sum_{i=1}^n c(x_i, y_{\\sigma_x^{-1} \\circ \\sigma_y(i)}) = \\frac{1}{n} \\sum_{i=1}^n c(x_{\\sigma_x(i)}, y_{\\sigma_y(i)})\n$$\n\nThus, to compute the optimal transport cost, it is sufficient to sort $x$ and $y$.\n\nLet's check this fact on an example, by comparing the transport cost obtained by sorting the points to the one obtained with the function `ot.emd`. To simplify, we generate points $x,y \\subset \\mathbb{R}$ s.t. $x$ is sorted, i.e. $\\sigma_x = I_d$ and then $\\sigma^*=\\sigma_y$. Therefore, computing the optimal assignement amounts to sort $y$.\n\n::: {#25fcabee .cell executionInfo='{\"elapsed\":273,\"status\":\"ok\",\"timestamp\":1677186314277,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='e7ad5225-5ac8-42bd-b442-1b48fdbb8fd9' execution_count=15}\n``` {.python .cell-code}\n# generate points\nn = 5\nx = np.arange(0, 2*n, 2) + .25 * np.random.normal(size=(n,))\na = np.ones(n) / n\ny = np.arange(1, 2*n+1, 2) + .25 * np.random.normal(size=(n,))\nnp.random.shuffle(y)\nb = np.ones(n) / n\n\n# plot points\nfig, ax = plt.subplots(figsize=(12, 6))\nplot_points_1D(\n    ax,\n    x, y,\n    title=\"1D points\"\n)\n```\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-15-output-1.png){width=912 height=502}\n:::\n:::\n\n\n***\n\n**Question:**\n\n* For $\\ell_1$ and $\\ell_2^2$ geometries ($\\ell_2$ and $\\ell_1$ coincides on $\\mathbb{R}$), compute the optimal assignement and optimal transport cost by sorting $y$. Put the assignement into a vector $s \\in \\mathbb{R}^n$, s.t. $x_i$ is mapped to $y_{s_i}$, i.e. $s_i = \\sigma^*(i)$. Is it different according to the geometry?\n* Put now the assignment you obtained by sorting the points in the form of a transport plan $P^* \\in \\mathbb{R}^{n \\times n}$. Check that you obtain the results with `ot.emd`.\n\n**Answer:**\n\n::: {#8dc74390 .cell executionInfo='{\"elapsed\":4,\"status\":\"ok\",\"timestamp\":1677186314690,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='23e277c0-b38f-4c1e-a9c5-fbd73d39c2bf' execution_count=16}\n``` {.python .cell-code}\n# sort the points\ny_sorted = np.sort(y)\n\n# get optimal assignment as a vector\nassignment = np.argsort(y)\n\n# transform it to a transport plan\noptimal_plan = np.zeros((n,n))\nfor i, idx in enumerate(assignment):\n    optimal_plan[i, idx] = 1 / n\nprint(\n    f\"optimal transport plan obtained by sorting the points:\\n {optimal_plan}\"\n)\n\n# The result doesn't match the lecturer's\n```\n\n::: {.cell-output .cell-output-stdout}\n```\noptimal transport plan obtained by sorting the points:\n [[0.  0.  0.  0.2 0. ]\n [0.2 0.  0.  0.  0. ]\n [0.  0.  0.  0.  0.2]\n [0.  0.2 0.  0.  0. ]\n [0.  0.  0.2 0.  0. ]]\n```\n:::\n:::\n\n\n::: {#b5afb5d2 .cell executionInfo='{\"elapsed\":213,\"status\":\"ok\",\"timestamp\":1677186314899,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='320be5fd-7139-48fd-81b0-8491f131fb6a' execution_count=17}\n``` {.python .cell-code}\n# l1 geometry\nprint(\"l1 geometry:\")\nC_l1 = get_cost_matrix(\n    x=x, y=y,\n    cost_fn=lambda x,y: np.sum(np.abs(x - y))\n)\noptimal_plan_l1, optimal_cost_l1 = compute_transport(\n    C=C_l1,\n    a=a,\n    b=b,\n    verbose=True\n)\nprint(\n    f\"is it equal to the one obtained by sorting the points? \"\n    f\"{np.array_equal(optimal_plan_l1, optimal_plan)}\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nl1 geometry:\noptimal transport plan: \n[[0.  0.  0.  0.2 0. ]\n [0.2 0.  0.  0.  0. ]\n [0.  0.  0.  0.  0.2]\n [0.  0.2 0.  0.  0. ]\n [0.  0.  0.2 0.  0. ]]\ntransport cost: 1.149278108705205\nis it equal to the one obtained by sorting the points? True\n```\n:::\n:::\n\n\n::: {#48bfd142 .cell executionInfo='{\"elapsed\":3,\"status\":\"ok\",\"timestamp\":1677186314900,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='7541cb4f-8dbe-42e0-f51a-b59415be0933' execution_count=18}\n``` {.python .cell-code}\n# squared l2 geometry\n\ndef is_permutation(matrix):\n    \"\"\"\n    Check if a given matrix is a permutation matrix.\n    \"\"\"\n    n, m = matrix.shape\n    if n != m:\n        return False\n    \n    row_sum = np.sum(matrix, axis=1)\n    col_sum = np.sum(matrix, axis=0)\n    \n    return np.all(row_sum == 1) and np.all(col_sum == 1) and np.all((matrix == 0) | (matrix == 1))\n\nC_l2_sq = get_cost_matrix(\n    x=x, y=y,\n    cost_fn=lambda x,y: np.sum((x - y) ** 2)\n)\noptimal_plan_l2_sq, optimal_cost_l2_sq = compute_transport(\n    C=C_l2_sq,\n    a=a,\n    b=b,\n    verbose=True\n)\nprint(\n    f\"is permutation matrix? {is_permutation(optimal_plan_l2_sq)}\"\n)\nprint(\n    f\"is it equal to the one obtained by sorting the points? \"\n    f\"{np.array_equal(optimal_plan_l2_sq, optimal_plan)}\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\noptimal transport plan: \n[[0.  0.  0.  0.2 0. ]\n [0.2 0.  0.  0.  0. ]\n [0.  0.  0.  0.  0.2]\n [0.  0.2 0.  0.  0. ]\n [0.  0.  0.2 0.  0. ]]\ntransport cost: 1.3651629169059696\nis permutation matrix? False\nis it equal to the one obtained by sorting the points? True\n```\n:::\n:::\n\n\n***\n\nFinally, one can plot the assignement.\n\n::: {#c84a300e .cell executionInfo='{\"elapsed\":317,\"status\":\"error\",\"timestamp\":1677186795376,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='a141fcda-eba6-4c02-ecf5-51b232fe6478' execution_count=19}\n``` {.python .cell-code}\nfig, ax = plt.subplots(figsize=(12, 6))\nplot_assignement_1D(\n    ax,\n    x, y,\n    title=\"1D assignement\"\n)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-19-output-1.png){width=912 height=502}\n:::\n:::\n\n\n## Sinkhorn アルゴリズム\n\n### Adding negative entropy as a regularizer\n\nIn real ML applications, we often deal with large numbers of points. In this case, cubic complexity linear programming algorithms are too costly. This motivates (among other reasons) the regularized approach\n$$\n    \\min_{P \\in \\mathcal{U}(a,b)} \\langle C, P \\rangle + \\epsilon \\sum_{ij} P_{ij} [ \\log(P_{ij}) - 1].\n$$\nFor $\\epsilon$ is sufficiently small, one expects to recover an approximation of the original optimal transport plan.\n\n### The Sinkhorn iterates\n\nIn order to solve this problem, one can remark that the optimality conditions imply that a solution $P_\\epsilon^*$ necessarily is of the form $P_\\epsilon^* = \\text{diag}(u) \\, K \\, \\text{diag}(v)$, where $K = \\exp(-C/\\epsilon)$ and $u,v$ are two non-negative vectors.\n\n$P_\\epsilon^*$ should verify the constraints, i.e. $P_\\epsilon^* \\in U(a,b)$, so that\n$$\n    P_\\epsilon^* 1_m = a \\text{  and  } (P_\\epsilon^*)^T 1_n = b\n$$\nwhich can be rewritten as\n$$\n    u \\odot (Kv) = a \\text{  and  } v \\odot (K^T u) = b\n$$\n\nThen Sinkhorn's algorithm alternates between the resolution of these two equations, and reads at iteration $t$:\n$$\n    u^{t+1} \\leftarrow \\frac{a}{Kv^t} \\text{  and  } v^{t+1} \\leftarrow \\frac{b}{K^T u^{t+1}}\n$$\n\n### Initialization and convergence\n\nUsually, it starts from $v^{0} = \\mathrm{1}_m$ and alternate the above updates until $\\|u^{t+1} \\odot (Kv^{t+1}) - a\\|_1 + \\|v^{t+1} \\odot (K^T u^{t+1}) - b\\|_1 \\leq \\tau$, where $\\tau > 0$ is a fixed convergence threshold. Actually, since at the end of each iteration, one exactly has $v^{t+1} \\odot (K^T u^{t+1}) = b$, it just remains to test if $\\|u^{t+1} \\odot (Kv^{t+1}) - a\\|_1 \\leq \\tau$.\n\nFrom an entropic optimal transport plan $P^*_\\epsilon$, we can approximate the optimal transport cost by $\\sum_{i,j=1}^n P^*_{\\epsilon_{ij}} C_{ij} = ⟨C, P^*_\\epsilon⟩$. For the rest of the section, we call this quantity the entropic optimal transport cost.\n\n### Sinkhorn Implementation\n\nIn this section, you will implement your own version of the Sinkhorn Algorithm.\n\n***\n\n**Question:** Complete the following Sinkhorn algorithm, by:\n\n* Computing the kernel matrix $K = \\exp(-C / \\epsilon)$,\n* Starting from $v^{0} = \\mathrm{1}_m$,\n* Alternating the updates $u^{t+1} \\odot (Kv^t) = a$ and $v^{t+1} \\odot (K^T u^{t+1}) = b$,\n* Declaring convergence when $\\|u^t \\odot (Kv^t) - a\\|_1 + \\|v^t \\odot (K^T u^t) - b\\|_1 \\leq \\tau$.\n\n**Remark:** you should also use also a maximum number of iterations ``max_iter``, to stop the algorithm after a fixed number of iterations if the convergence is not reached.\n\n**Answer:**\n\n::: {#6f04749c .cell execution_count=20}\n``` {.python .cell-code}\ndef sinkhorn(\n    a: np.ndarray,\n    b: np.ndarray,\n    C: np.ndarray,\n    epsilon: float,\n    max_iters: int = 100,\n    tau: float = 1e-4\n) -> np.ndarray:\n    \"\"\"\n    Sinnkhorn's algorithm. It should output the optimal transport plan.\n    \"\"\"\n\n    K = np.exp( -C / epsilon )\n    n, m = a.shape[0], b.shape[0]\n    v = np.ones((m,))\n    for _ in range(max_iters):\n        u = a / K.dot(v)\n        v = b / K.transpose().dot(u)\n    return u[:,None] * v[None,:] * K  # u_i, v_j, K_ij\n```\n:::\n\n\n::: {#90f5cee2 .cell execution_count=21}\n``` {.python .cell-code}\nP = sinkhorn(a, b, C_l2_sq, epsilon=1)\nprint(P.sum(axis=0))\nprint(P.sum(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.2 0.2 0.2 0.2 0.2]\n[0.19757988 0.19787653 0.20030352 0.20090692 0.20333316]\n```\n:::\n:::\n\n\n::: {#0c0f4e06 .cell execution_count=22}\n``` {.python .cell-code}\nP = sinkhorn(a, b, C_l2_sq, epsilon=1, max_iters=1000)\nprint(P.sum(axis=0))\nprint(P.sum(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.2 0.2 0.2 0.2 0.2]\n[0.19997544 0.1999764  0.20000093 0.20000297 0.20004426]\n```\n:::\n:::\n\n\n::: {#c25ad2c4 .cell execution_count=23}\n``` {.python .cell-code}\ndef sinkhorn(\n    a: np.ndarray,\n    b: np.ndarray,\n    C: np.ndarray,\n    epsilon: float,\n    max_iters: int = 100,\n    tau: float = 1e-4\n) -> np.ndarray:\n    \"\"\"\n    Sinnkhorn's algorithm. It should output the optimal transport plan.\n    \"\"\"\n\n    K = np.exp( -C / epsilon )\n    n, m = a.shape[0], b.shape[0]\n    v = np.ones((m,))\n    for i in range(max_iters):\n        u = a / K.dot(v)\n        v = b / K.transpose().dot(u)\n        if i % 10 == 0:\n            # compute row sum D(u) K D(v) = u * Kv\n            if np.sum(np.abs(u * K.dot(v) - a)) < tau:\n                print('early termination: ' + str(i))\n                break\n    return u[:,None] * v[None,:] * K  # u_i, v_j, K_ij\n```\n:::\n\n\n::: {#c992f3b4 .cell execution_count=24}\n``` {.python .cell-code}\nP = sinkhorn(a, b, C_l2_sq, epsilon=1, max_iters=1000)\nprint(P.sum(axis=0))\nprint(P.sum(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nearly termination: 990\n[0.2 0.2 0.2 0.2 0.2]\n[0.19997453 0.19997552 0.20000097 0.20000309 0.20004589]\n```\n:::\n:::\n\n\n::: {#e9464c15 .cell execution_count=25}\n``` {.python .cell-code}\nP = sinkhorn(a, b, C_l2_sq, epsilon=0.1, max_iters=10000)\nprint(P.sum(axis=0))\nprint(P.sum(axis=1))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.2 0.2 0.2 0.2 0.2]\n[0.19995991 0.19997995 0.2        0.20002005 0.2000401 ]\n```\n:::\n:::\n\n\n***\n\nNow, we can test the Sinkhorn algorithm on the \"croissant\" transport example.\n\n***\n**Question:**\n* Complete the following fuction that takes as input the cost matrix $C$ and the weights vectors $a$ and $b$ and outputs the entropic optimal transport plan and the entropic optimal transport cost using the `sinkhorn` function. As for the exact transport, it has an option to display the results.\n* Use that function on the croissant transport to compute and display the optimal plan and the optimal cost for the $\\ell_1, \\ell_2$ and $\\ell_2^2$ geometries.\n* Each time you run the Sinkhorn algorithm, you should use $\\epsilon = 0.1 \\cdot \\bar{C}$, with $\\bar{C} = \\frac{1}{nm} \\sum_{i=1}^n \\sum_{j=1}^m C_{ij}$ is the mean of the cost matrix.  It remains to adapt the $\\epsilon$ value according to the cost matrix, to control the magnitude of the entries of $C / \\epsilon$. Why this strategy? What will happen if $\\epsilon$ is too small compared to the entries of $C$?\n\n**Answer:**\n\n::: {#3e59d629 .cell execution_count=26}\n``` {.python .cell-code}\ndef compute_transport_sinkhorn(\n    C: np.ndarray,\n    a: np.ndarray,\n    b: np.ndarray,\n    epsilon: float,\n    max_iters: int = 10_000,\n    tau: float = 1e-4,\n    verbose: bool = False,\n):\n  \"\"\"\n  Compute the entropic optimal transport plan and the entropic optimal transport cost\n  for cost matrix ``C`` and weight vectors $a$ and $b$.\n  If ``verbose`` is set to True, it displays the results.\n  \"\"\"\n  optimal_plan_sinkhorn = sinkhorn(a, b, C, epsilon, max_iters, tau)\n  optimal_cost_sinkhorn = np.sum(optimal_plan_sinkhorn * C)\n  if verbose:\n    print(\n        f\"entropic optimal transport plan: \\n{optimal_plan_sinkhorn}\"\n    )\n    print(\n        f\"entropic transport cost: {optimal_cost_sinkhorn}\"\n    )\n  return optimal_plan_sinkhorn, optimal_cost_sinkhorn\n```\n:::\n\n\n::: {#ade3fc59 .cell executionInfo='{\"elapsed\":5,\"status\":\"ok\",\"timestamp\":1677186319119,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='9f68f4d1-f6ce-41e9-990e-b0890b4084cb' execution_count=27}\n``` {.python .cell-code}\n# l1 geometry\nprint(\"l1 geometry:\")\nC_l1 = get_cost_matrix(\n    x=bakery_pos, y=cafe_pos,\n    cost_fn=lambda x,y: np.sum(np.abs(x - y))\n)\nepsilon = 1\noptimal_plan_sinkhorn_l1_croissant, optimal_cost_sinkhorn_l1_croissant = compute_transport_sinkhorn(\n    C=C_l1,\n    a=bakery_prod,\n    b=cafe_prod,\n    epsilon=epsilon,\n    verbose=True,\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nl1 geometry:\nearly termination: 5970\nentropic optimal transport plan: \n[[2.70428936e-002 4.32583290e-002 1.34214268e-047 1.83509051e-086\n  1.62880160e-235]\n [3.42773260e-084 1.30691077e-046 1.08827539e-001 1.90100995e-040\n  1.68731081e-189]\n [7.15328153e-002 1.14425257e-001 4.99347632e-122 4.85411038e-086\n  4.30844293e-235]\n [2.61705422e-002 4.18628990e-002 5.77469196e-189 1.77589404e-086\n  1.57625961e-235]\n [1.25908361e-049 4.80057848e-012 2.70172554e-084 9.07098043e-002\n  1.22406524e-115]\n [2.66904088e-052 1.01764013e-014 9.97892408e-002 1.92289196e-004\n  8.84651301e-003]\n [5.95876320e-051 4.18968529e-019 7.18872709e-119 4.29294956e-003\n  1.97502693e-001]\n [6.11947921e-002 7.27950530e-029 1.24902883e-128 1.04351442e-001\n  5.20381800e-060]]\nentropic transport cost: 177.27648952346257\n```\n:::\n:::\n\n\n::: {#7d31f270 .cell execution_count=28}\n``` {.python .cell-code}\nplt.imshow(optimal_plan_sinkhorn_l1_croissant)\n```\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-28-output-1.png){width=268 height=411}\n:::\n:::\n\n\n::: {#39fdc41d .cell executionInfo='{\"elapsed\":5,\"status\":\"ok\",\"timestamp\":1677186319120,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='6ef09f42-96b6-42af-c4e0-a280acda8139' execution_count=29}\n``` {.python .cell-code}\n# l2 geometry\nprint(\"l2 geometry:\")\nC_l2 = get_cost_matrix(\n    x=bakery_pos, y=cafe_pos,\n    cost_fn=lambda x,y: np.linalg.norm(x - y, ord=2)\n)\nepsilon = np.mean(C_l2_sq) * 0.05 # compute the optimal value to avoid underflow\noptimal_plan_sinkhorn_l2_croissant, optimal_cost_sinkhorn_l2_croissant = compute_transport_sinkhorn(\n    C=C_l2,\n    a=bakery_prod,\n    b=cafe_prod,\n    epsilon=epsilon,\n    verbose=True\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nl2 geometry:\nearly termination: 6480\nentropic optimal transport plan: \n[[1.47195199e-002 5.55812693e-002 2.07887308e-066 1.89085801e-083\n  4.08212986e-215]\n [4.71170808e-067 2.26166564e-043 1.08836263e-001 9.74649907e-077\n  7.01848099e-170]\n [4.19924977e-002 1.43964413e-001 2.66725594e-094 2.03490446e-086\n  7.16649420e-222]\n [6.80327467e-002 4.36749516e-013 5.13671791e-141 2.72754187e-101\n  3.05721358e-239]\n [1.24385751e-021 8.02928239e-007 1.04149196e-050 9.07085294e-002\n  6.66796031e-098]\n [8.63129441e-026 1.06829448e-010 9.97805175e-002 4.48903087e-003\n  4.56691630e-003]\n [2.65261029e-046 2.59222291e-040 8.94588488e-063 2.71496095e-025\n  2.01782290e-001]\n [6.11962788e-002 1.70632530e-011 1.98854584e-093 1.04348925e-001\n  1.28895438e-052]]\nentropic transport cost: 139.5030886918118\n```\n:::\n:::\n\n\n::: {#91cc4d96 .cell executionInfo='{\"elapsed\":4,\"status\":\"ok\",\"timestamp\":1677186319120,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='fa8c9abe-a06e-4c76-d059-e97687851c26' execution_count=30}\n``` {.python .cell-code}\n# squared l2 geometry\nprint(\"squared l2 geometry:\")\nC_l2_sq = get_cost_matrix(\n    x=bakery_pos, y=cafe_pos,\n    cost_fn=lambda x,y: np.sum((x - y) ** 2)\n)\nepsilon = np.mean(C_l2_sq) * 0.05 # compute the optimal value to avoid underflow\noptimal_plan_sinkhorn_l2_sq_croissant, optimal_cost_sinkhorn_l2_sq_croissant = compute_transport_sinkhorn(\n    C=C_l2_sq,\n    a=bakery_prod,\n    b=cafe_prod,\n    epsilon=epsilon,\n    verbose=True\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nsquared l2 geometry:\nearly termination: 390\nentropic optimal transport plan: \n[[9.15185856e-03 6.11459020e-02 2.53416007e-06 9.36830019e-11\n  5.88710931e-33]\n [1.98312263e-09 2.86298466e-05 1.08801507e-01 2.62245737e-07\n  1.22762517e-18]\n [1.02592189e-01 8.33635462e-02 3.95058637e-08 1.25018168e-08\n  7.16059834e-28]\n [6.36539082e-02 4.37874407e-03 9.20213996e-12 8.38044497e-09\n  1.80226054e-26]\n [1.15178824e-03 4.78786088e-02 4.40333811e-04 4.12385828e-02\n  1.04144097e-10]\n [1.27912352e-15 1.00116432e-09 9.93719135e-02 7.28353201e-04\n  8.73056135e-03]\n [5.51097456e-13 1.50024181e-09 4.51186568e-07 4.17827621e-03\n  1.97618514e-01]\n [9.39129734e-03 2.75105187e-03 4.51869851e-10 1.53400990e-01\n  1.31200779e-07]]\nentropic transport cost: 24883.330683517215\n```\n:::\n:::\n\n\n***\n\n### The effect of $\\epsilon$\n\nNow we can display the transportation plans obtained with Sinkhorn's algortihm, as we did for the exact OT.\n\n::: {#77c109f3 .cell executionInfo='{\"elapsed\":1917,\"status\":\"ok\",\"timestamp\":1677186324355,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='329a7955-acc7-490f-89e6-e7407763932c' execution_count=31}\n``` {.python .cell-code}\nfig, ax = plt.subplots(\n    1, 3, figsize=(9*3, 7)\n)\nplans = [optimal_plan_sinkhorn_l1_croissant,\n         optimal_plan_sinkhorn_l2_croissant,\n         optimal_plan_sinkhorn_l2_sq_croissant]\n\ntitles = [r\"$\\ell_1$ geometry\", r\"$\\ell_2$ geometry\", r\"$\\ell_2^2$ geometry\"]\n\nfor axes, plan, title in zip(ax, plans, titles):\n  plot_assignement(\n      ax=axes,\n      x=bakery_pos, a=bakery_prod, x_label=\"Bakeries\",\n      y=cafe_pos, b=cafe_prod, y_label=\"Cafés\",\n      optimal_plan=plan,\n      title=title\n  )\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-31-output-1.png){width=2028 height=586}\n:::\n:::\n\n\nNote: There always is some transport at every edge in Sinkhorn algorithm's output.\n\n::: {#4d3071c7 .cell execution_count=32}\n``` {.python .cell-code}\nfig, ax = plt.subplots(\n    1, 3, figsize=(9*3, 7)\n)\nplans = [optimal_plan_l1_croissant,\n         optimal_plan_l2_croissant,\n         optimal_plan_l2_sq_croissant]\n\ntitles = [r\"$\\ell_1$ geometry\", r\"$\\ell_2$ geometry\", r\"$\\ell_2^2$ geometry\"]\n\nfor axes, plan, title in zip(ax, plans, titles):\n  plot_assignement(\n      ax=axes,\n      x=bakery_pos, a=bakery_prod, x_label=\"Bakeries\",\n      y=cafe_pos, b=cafe_prod, y_label=\"Cafés\",\n      optimal_plan=plan,\n      title=title\n  )\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-32-output-1.png){width=2028 height=586}\n:::\n:::\n\n\nThe above transport plans are obtained for $\\epsilon = 0.1 \\cdot \\bar{C}$. Let's increase epsilon to $\\epsilon = 10 \\cdot \\bar{C}$ and replot the optimal  transport plans to visualize the effect of epsilon.\n\n::: {#5c62979e .cell executionInfo='{\"elapsed\":1524,\"status\":\"ok\",\"timestamp\":1677186325876,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='861f6970-aac7-4b0c-ec5d-0936d100ef45' execution_count=33}\n``` {.python .cell-code}\n# l1 geometry\nepsilon = 10 * np.mean(C_l1)\noptimal_plan_sinkhorn_l1_croissant, optimal_cost_sinkhorn_l1_croissant = compute_transport_sinkhorn(\n    C=C_l1,\n    a=bakery_prod,\n    b=cafe_prod,\n    epsilon=epsilon,\n    verbose=False,\n)\n\n# l2 geometry\nepsilon = 10 * np.mean(C_l2)\noptimal_plan_sinkhorn_l2_croissant, optimal_cost_sinkhorn_l2_croissant = compute_transport_sinkhorn(\n    C=C_l2,\n    a=bakery_prod,\n    b=cafe_prod,\n    epsilon=epsilon,\n    verbose=False\n)\n\n# squared l2 geometry\nepsilon = 10 * np.mean(C_l2_sq)\noptimal_plan_sinkhorn_l2_sq_croissant, optimal_cost_sinkhorn_l2_sq_croissant = compute_transport_sinkhorn(\n    C=C_l2_sq,\n    a=bakery_prod,\n    b=cafe_prod,\n    epsilon=epsilon,\n    verbose=False\n)\n\nfig, ax = plt.subplots(\n    1, 3, figsize=(9*3, 7)\n)\nplans = [optimal_plan_l1_croissant,\n         optimal_plan_l2_croissant,\n         optimal_plan_l2_sq_croissant]\ntitles = [r\"$\\ell_1$ geometry\", r\"$\\ell_2$ geometry\", r\"$\\ell_2^2$ geometry\"]\n\nfor axes, plan, title in zip(ax, plans, titles):\n  plot_assignement(\n      ax=axes,\n      x=bakery_pos, a=bakery_prod, x_label=\"Bakeries\",\n      y=cafe_pos, b=cafe_prod, y_label=\"Cafés\",\n      optimal_plan=plan,\n      title=title\n  )\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nearly termination: 10\nearly termination: 10\nearly termination: 10\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-33-output-2.png){width=2028 height=586}\n:::\n:::\n\n\nNote: If the epsilon is large, the distribution is close to uniform.\n\n***\n\n**Question:** What do you observe in relation to the transport plans obtained for the exact optimal transport?\n\n**Answer:**\n\n***\n\n### Sinkhorn consistency\n\nWe now show that this Sinkhorn algorithm is consistent with classical optimal transport, using the \"croissant\" transport example and focusing on the $\\ell_2$ cost.\n\n***\n\n**Question:** Complete the following code to compute, for various $\\epsilon'$, values on a regular grid:\n* Set $\\epsilon = \\epsilon' \\cdot \\bar{C}$,\n* The deviation of the entropic optimal plan $P^*_\\epsilon$ to the exact optimal plan $P^*$, namely $\\|P^*_\\epsilon - P^*\\|_2$.\n* The deviation of the entropic optimal cost $\\langle C, P^*_\\epsilon \\rangle$ to the exact optimal plan $\\langle C, P^*_\\epsilon \\rangle$, namely: $\\langle C, P^*_\\epsilon \\rangle - \\langle C, P^* \\rangle$.\n\nWe remind that the excat optimal transport plan for the $\\ell_2$ cost is stored as variable `optimal_plan_l2_croissant`.\n\n**Answer:**\n\n::: {#68fb303e .cell execution_count=34}\n``` {.python .cell-code}\nplan_diff = []\ndistance_diff = []\ngrid = np.linspace(0.01, 5, 100)\nfor epsilon_prime in grid:\n  epsilon = epsilon_prime * np.mean(C_l2)\n  optimal_plan_sinkhorn_l2_croissant, optimal_cost_sinkhorn_l2_croissant = compute_transport_sinkhorn(\n      C=C_l2,\n      a=bakery_prod,\n      b=cafe_prod,\n      epsilon=epsilon,\n      verbose=False\n  )\n  assert optimal_cost_sinkhorn_l2_croissant != np.nan, (\n      \"Optimal cost is nan due to numerical instabilities.\"\n  )\n  plan_diff.append(\n      np.sum(np.abs(optimal_plan_sinkhorn_l2_croissant - optimal_plan_l2_croissant))\n  )\n  distance_diff.append(\n      optimal_cost_sinkhorn_l2_croissant - optimal_cost_l2_croissant\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nearly termination: 2460\nearly termination: 220\nearly termination: 50\nearly termination: 30\nearly termination: 20\nearly termination: 20\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\nearly termination: 10\n```\n:::\n:::\n\n\n***\n\nNow, let's plot the results.\n\n::: {#4b0cca58 .cell execution_count=35}\n``` {.python .cell-code}\nfig, ax = plt.subplots(2, 1, figsize=(16, 5*2))\nreg_strengths = np.mean(C_l2) * grid\nplot_consistency(\n    ax,\n    reg_strengths,\n    plan_diff,\n    distance_diff\n)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/opt/homebrew/lib/python3.12/site-packages/IPython/core/pylabtools.py:170: UserWarning: Data has no positive values, and therefore cannot be log-scaled.\n  fig.canvas.print_figure(bytes_io, **kw)\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](OT1_files/figure-html/cell-35-output-2.png){width=1335 height=844}\n:::\n:::\n\n\nNote: The result is different from the lecturer's.\n\n## `OTT` パッケージ\n\n### Install `OTT`\n\nFirst, you need to install `OTT`.\n\n::: {#c4a20535 .cell executionInfo='{\"elapsed\":4333,\"status\":\"ok\",\"timestamp\":1677180333767,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='8e7c9ade-b5c5-40ca-e624-0353e1feab1f' execution_count=36}\n``` {.python .cell-code}\n%pip install ott-jax\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nerror: externally-managed-environment\r\n\r\n× This environment is externally managed\r\n╰─> To install Python packages system-wide, try brew install\r\n    xyz, where xyz is the package you are trying to\r\n    install.\r\n    \r\n    If you wish to install a Python library that isn't in Homebrew,\r\n    use a virtual environment:\r\n    \r\n    python3 -m venv path/to/venv\r\n    source path/to/venv/bin/activate\r\n    python3 -m pip install xyz\r\n    \r\n    If you wish to install a Python application that isn't in Homebrew,\r\n    it may be easiest to use 'pipx install xyz', which will manage a\r\n    virtual environment for you. You can install pipx with\r\n    \r\n    brew install pipx\r\n    \r\n    You may restore the old behavior of pip by passing\r\n    the '--break-system-packages' flag to pip, or by adding\r\n    'break-system-packages = true' to your pip.conf file. The latter\r\n    will permanently disable this error.\r\n    \r\n    If you disable this error, we STRONGLY recommend that you additionally\r\n    pass the '--user' flag to pip, or set 'user = true' in your pip.conf\r\n    file. Failure to do this can result in a broken Homebrew installation.\r\n    \r\n    Read more about this behavior here: <https://peps.python.org/pep-0668/>\r\n\r\nnote: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.\r\nhint: See PEP 668 for the detailed specification.\r\nNote: you may need to restart the kernel to use updated packages.\n```\n:::\n:::\n\n\nThen we load the required pakages.\n\n::: {#21ad542a .cell executionInfo='{\"elapsed\":1083,\"status\":\"ok\",\"timestamp\":1677180334848,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='5cf76243-4b95-46d7-ffe6-6fde9cedc07d' execution_count=37}\n``` {.python .cell-code}\nimport jax\nimport jax.numpy as jnp\nimport jax.random as random\nimport ott\nfrom ott.geometry import costs, pointcloud\nfrom ott.problems.linear import linear_problem\nfrom ott.solvers.linear import sinkhorn\n```\n:::\n\n\n### A world about `OTT` and `JAX`\n\n\n\n`OTT` is a python library that allows to compute and differentiate the entropic optimal transport. In this lab session, we will focus on entropic optimal transport computation, and not differentiation. differentiation will be takcled later.\n\n`OTT` is based on `JAX`, a package similar to `PyTorch` or `TensorFlow`, which allows to do automatic differentiation and GPU programming. It also provides useful primitives for efficient computation, such as the just-in-time (`jit`) compilation or the automatic vectorization map `vmap`. For more informations on `JAX`, see the tutorial https://jax.readthedocs.io/en/latest/notebooks/quickstart.html.\n\nUnlike `PyTorch` or `TensorFlow`, `JAX` is very close to `numpy` thanks to the `jax.numpy` package, which implements most of the `numpy` features, but for the `JAX` data structures. For this lab session, you only need to know how to manipulate `jax.numpy` Arrays and generate random numbers with `jax.random`.\n\nFirst, let's have a look to `jax.numpy` and see that it works (almost) exactly as numpy. Usually, one imports `jax.numpy as jnp` as done in the above cells, and developp as with `numpy`, by just replacing `np` by `jnp`. Note that `jax.numpy` Arrays are called `DeviceArray`. For more informations on `jax.numpy`, see https://jax.readthedocs.io/en/latest/jax-101/01-jax-basics.html.\n\n::: {#70549218 .cell executionInfo='{\"elapsed\":776,\"status\":\"ok\",\"timestamp\":1677177738063,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='102dd072-941c-4376-8da0-243d2d63ae52' execution_count=38}\n``` {.python .cell-code}\nd = 5\nu = 5 * jnp.ones(5)\nId = jnp.eye(5)\nprint(type(u))\nprint(f\"u = {u}\")\nprint(f\"Id = {Id}\")\nprint(f\"Id @ u = {jnp.dot(Id, u)}\")\nprint(f\"sum(u) = {jnp.sum(u)}\")\nprint(f\"var(u) = {jnp.var(u)}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<class 'jaxlib.xla_extension.ArrayImpl'>\nu = [5. 5. 5. 5. 5.]\nId = [[1. 0. 0. 0. 0.]\n [0. 1. 0. 0. 0.]\n [0. 0. 1. 0. 0.]\n [0. 0. 0. 1. 0.]\n [0. 0. 0. 0. 1.]]\nId @ u = [5. 5. 5. 5. 5.]\nsum(u) = 25.0\nvar(u) = 0.0\n```\n:::\n:::\n\n\nWith `numpy.random`, you can generate random numbers on the fly without giving the `seed`. For example, `np.random.rand()` generates a random number $x \\sim U([0, 1])$. Indeed, `numpy.random` uses an internal seed which is updated each time a random number generating function is called. On the other hand, with `jax.random`, we must give the `seed` each time we generate random numbers. To some extent, we want to always control the randomness. Moreover, we do not pass exactly a `seed` but a `jax.random.PRNGKey` key which is itself instantiated from a `seed`. Let's see it on an example.\n\n::: {#6a2715f3 .cell executionInfo='{\"elapsed\":344,\"status\":\"ok\",\"timestamp\":1677177741429,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='40386ca7-8e5b-4019-d976-ca6bad24c043' execution_count=39}\n``` {.python .cell-code}\nrng = jax.random.PRNGKey(0)\nn, d = 13, 2\nx = jax.random.normal(rng, (n, d))\nprint(f\"x = {x}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nx = [[ 2.516351   -1.3947194 ]\n [-0.8633262   0.6413567 ]\n [-0.37789643 -0.6044598 ]\n [ 1.9069     -0.17918469]\n [-0.7583423  -0.5160155 ]\n [ 1.2666148  -0.12342127]\n [ 0.28430256 -0.17251171]\n [ 1.0661486   1.5814103 ]\n [-2.0284636  -0.13168257]\n [-0.14515765  0.21532312]\n [-0.69525063 -0.9314128 ]\n [-0.89809936 -0.25272107]\n [-0.34937173  1.8394127 ]]\n```\n:::\n:::\n\n\nThen, to have new keys to generate new random numbers, we need to split the key via `jax.random.split`, which generate $n \\geq 2$ new keys from a key.\n\n::: {#056d78bc .cell executionInfo='{\"elapsed\":592,\"status\":\"ok\",\"timestamp\":1677177743638,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='c9c452b7-a183-4e2a-a161-672e75e6514c' execution_count=40}\n``` {.python .cell-code}\nrng1, rng2, rng3 = jax.random.split(rng, 3)\na = jax.random.normal(rng1, (n, d))\nb = jax.random.normal(rng2, (n, d))\nc = jax.random.normal(rng2, (n, d))\nprint(f\"a = {a}\")\nprint(f\"b = {b}\")\nprint(f\"c = {c}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na = [[-0.38696066 -0.96707183]\n [ 1.0078175  -0.6096286 ]\n [-1.153353    1.0749092 ]\n [-1.2452031  -0.63885343]\n [ 0.01121208  0.2842425 ]\n [ 0.5296049   0.26609063]\n [ 0.8728492   1.0844501 ]\n [ 1.4472795  -0.82503337]\n [-0.41826957  0.21321987]\n [ 1.9602116   0.17687395]\n [-0.9978761  -2.0551765 ]\n [-0.4094941  -1.4577458 ]\n [-1.0969195  -0.66684234]]\nb = [[ 0.10911155 -0.45371595]\n [ 0.12062439 -0.06927001]\n [ 0.00600028  2.3732579 ]\n [-0.17656058  1.7653493 ]\n [-0.06429235  0.487175  ]\n [-1.1079016  -1.0277865 ]\n [-0.0553451  -0.28271845]\n [-0.9633478  -0.05370665]\n [ 0.20281292 -0.16658288]\n [ 0.8015828  -0.61697495]\n [-0.30176872 -1.1862007 ]\n [-3.106658   -0.03262986]\n [ 0.53711027  0.21359496]]\nc = [[ 0.10911155 -0.45371595]\n [ 0.12062439 -0.06927001]\n [ 0.00600028  2.3732579 ]\n [-0.17656058  1.7653493 ]\n [-0.06429235  0.487175  ]\n [-1.1079016  -1.0277865 ]\n [-0.0553451  -0.28271845]\n [-0.9633478  -0.05370665]\n [ 0.20281292 -0.16658288]\n [ 0.8015828  -0.61697495]\n [-0.30176872 -1.1862007 ]\n [-3.106658   -0.03262986]\n [ 0.53711027  0.21359496]]\n```\n:::\n:::\n\n\nyou now know everything you need for the moment!\n\n### Entropic optimal transport with `OTT`\n\nNow let's use the implementation of the `OTT` Sinkhorn algorithm, on some random weighted point clouds. Then you will, by yourself, use it on the \"croissant\" transport example.\n\nLet's first generate the data.\n\n::: {#1d365501 .cell execution_count=41}\n``` {.python .cell-code}\n# generate data\nrng = jax.random.PRNGKey(0)\nrng1, rng2 = jax.random.split(rng, 2)\nn, m, d = 13, 17, 2\nx = jax.random.normal(rng1, (n, d))\ny = jax.random.normal(rng2, (m, d)) + 1\na = jnp.ones(n) / n\nb = jnp.ones(m) / m\n```\n:::\n\n\nThen, we have to define a `PointCloud` `geometry` which contains:\n* the point clouds `x` and `y`,\n* the cost function `cost_fn`,\n* the entropic regularization strength `epsilon`.\n\nNote that the `geometry` does not contain the weight vectors `a` and `b`, these are passed later.\n\nThe `cost_fn` should be an istance of `ott.geometry.CostFn`. Most of the usual costs are implemented. For example, the three costs $\\ell_1, \\ell_2$ and $\\ell_2^2$ are implemented. Here, we will focus on the $\\ell_2$ cost, implemented by `ott.geometry.costs.Euclidean`. See https://ott-jax.readthedocs.io/en/latest/_autosummary/ott.geometry.costs.CostFn.html#ott.geometry.costs.CostFn for more information on the provided `cost_fn`.\n\nWe still choose `epsilon` to be $0.1 \\cdot \\bar{C}$. To do this, we set `relative_epsilon=True` when instantiating the geometry. The term `relative` means that `epsilon` is chosen relatively to the mean of the cost matrix. Passing then `epsilon=0.1`, the value of `epsilon` used by Sinkhorn will be $0.1 \\cdot \\bar{C}$.\n\n::: {#d336e0a2 .cell execution_count=42}\n``` {.python .cell-code}\n# define geometry\ngeom = pointcloud.PointCloud(\n    x=x, y=y,\n    cost_fn=costs.Euclidean(),\n    epsilon=1e-1,\n    relative_epsilon=True\n)\n```\n:::\n\n\nWe then define an optimization problem from this geometry, which is the problem we will solve with the Sinkhorn algorithm.  We instantiate this optimization problem as an object of the class `linear_problem.LinearProblem`. We pass the weight vectors `a` and `b` because they define the constraints of the linear problem. Then, we instantiate a Sinkhorn solver, object of the class `sinkhorn.Sinkhorn`, which we will use to solve this optimization problem.\n\nThe `OTT` library is designed in this way because it allows to solve other optimal transport problems, which do not necessarily have a linear problem structure, and which use other solvers than Sinkhorn.\n\n::: {#979f902f .cell execution_count=43}\n``` {.python .cell-code}\n# create optimization problem\not_prob = linear_problem.LinearProblem(geom, a=a, b=b)\n\n# create sinkhorn solver\nsolver = sinkhorn.Sinkhorn(ot_prob)\n\n# solve the OT problem\not_sol = solver(ot_prob)\n```\n:::\n\n\nThe `ot` output object contains several callables and properties, notably a boolean assessing the Sinkhorn convergence, the marginal errors throughtout iterations and the optimal transport plan.\n\n::: {#669e6954 .cell executionInfo='{\"elapsed\":1048,\"status\":\"ok\",\"timestamp\":1677180360140,\"user\":{\"displayName\":\"Théo Uscidda\",\"userId\":4606330742318440000},\"user_tz\":-60}' outputId='e96f56dd-306e-46f9-b1aa-bce66204af1a' execution_count=44}\n``` {.python .cell-code}\nprint(\n    \" Sinkhorn has converged: \",\n    ot_sol.converged,\n    \"\\n\",\n    \"Error upon last iteration: \",\n    ot_sol.errors[(ot_sol.errors > -1)][-1],\n    \"\\n\",\n    \"Sinkhorn required \",\n    jnp.sum(ot_sol.errors > -1),\n    \" iterations to converge. \\n\",\n    \"entropic OT cost: \",\n    jnp.sum(ot_sol.matrix * ot_sol.geom.cost_matrix),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n Sinkhorn has converged:  True \n Error upon last iteration:  0.00019063428 \n Sinkhorn required  5  iterations to converge. \n entropic OT cost:  29.436863\n```\n:::\n:::\n\n\n***\n**Question:** Compute the entropic optimal transport plan and cost for the \"croissant\" transport problem, with $\\ell_2$ cost and $\\epsilon = 0.1 \\cdot \\bar{C}$. Then, plot the optimal transport plan.\n\n**Answer:**\n\n***\n\n\n## 参考文献 {.appendix}\n\nMarco Cuturi による [Colab](https://colab.research.google.com/drive/1IgR8bL_ihL_kHeZMbX4pIvtXoWieVTfG?usp=sharing) を参考にした．\n\n",
    "supporting": [
      "OT1_files"
    ],
    "filters": [],
    "includes": {}
  }
}