{
  "hash": "82fa4a42eb16740e69d6dda5c94f9b0b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R（４）メタプログラミング\"\nsubtitle: \"Expression について\"\nauthor: \"司馬 博文\"\ndate: 5/7/2021\ndate-modified: 6/5/2024\ncategories: [Computation, R]\nbibliography: \n    - ../../../assets/mathematics.bib\n    - ../../../assets/bib.bib\ncsl: ../../../assets/apalike.csl\nabstract-title: 概要\nabstract: R は統計計算のための言語です．\nformat:\n  html:\n    code-fold: false\nlisting: \n  -   id: lst-R\n      type: grid\n      sort: false\n      contents:\n          - R0.qmd\n          - R1.qmd\n          - R2.qmd\n          - R3.qmd\n          - R5.qmd\n          - YUIMA.qmd\n      date-format: iso\n      fields: [title,image,date,subtitle]\n---\n\n\n::: {#lst-R}\n:::\n\n## Expression とは\n\n### Language Object\n\nオブジェクト志向言語ではコード自体もオブジェクトであり，R では `call`, `expression`, `name` の３つのモードから構成される．^[[R Language Definition](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Language-objects-1)]\n\n１つのクラスからなるわけではなく，`call`, `symbol`, `constant`, `pairlist` の４つの型からなる．^[[@Wickham2019] [第17章](https://adv-r.hadley.nz/meta-big-picture.html)２節．]\n\n#### `pairlist`\n\nR の内部で用いられるデータ型であり，Lisp の `dotted-pair list`に似ている．\n\n`pairlist`オブジェクトは３つの slot をもち，`CAR`, `CDR`, `TAG`と呼ばれる．\n* `CAR`と`CDR`は IBM の 60 年代のコンピュータの`address`,`decrement`レジスタに由来し，リストの head と tail を指す．\n* `TAG`は文字列オブジェクトである．\n\n`pairlist`の R 内での機能は`list`と全く同じで，indexing syntax `[[]]`も同一である．\n\n### コンストラクタ\n\n次のような操作ができる^[[@Wickham2019] [第18章](https://adv-r.hadley.nz/expressions.html)]\n\n`rlang::expr` がコンストラクタである：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz <- rlang::expr(y <- x*10)\nz\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ny <- x * 10\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n language y <- x * 10\n```\n\n\n:::\n:::\n\n\n| typeof | class | mode |\n|:-----:|:-----:|:-----:|\n| `language` | `<-` | `call` |\n\n: {.hover .striped .responsive-sm tbl-colwidths=\"[10,10,10]\"}\n\n### 評価\n\n`expression` オブジェクトは `base::eval()` で評価できる：\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 4\neval(z)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 40\n```\n\n\n:::\n:::\n\n\n### 参照方法\n\n`expression` には list のようにアクセス可能である：^[[@Wickham2019] [第17章](https://adv-r.hadley.nz/meta-big-picture.html)２節．]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\nf <- expr(f(x = 1, y = 2))\n\nf$z <- 3\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nf(x = 1, y = 2, z = 3)\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nf[[2]] <- NULL\nf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nf(y = 2, z = 3)\n```\n\n\n:::\n:::\n\n\n## メタプログラミング\n\n### `enexpr` 関数\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncapture_it <- function(x) {\n  expr(x)\n}\ncapture_it(a + b + c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncapture_it <- function(x) {\n  enexpr(x)\n}\ncapture_it(a + b + c)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\na + b + c\n```\n\n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}