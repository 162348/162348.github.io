{
  "hash": "b6ac7a15c2387216fa372f7821aeb8f0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R（１）基本文法\"\nsubtitle: \"基本パッケージとその文法\"\nauthor: \"司馬 博文\"\ndate: 5/7/2021\ndate-modified: 6/7/2024\nimage: Files/R.png\ncategories: [Computation, R]\nbibliography: \n    - ../../../assets/mathematics.bib\n    - ../../../assets/bib.bib\ncsl: ../../../assets/apalike.csl\nabstract-title: 概要\nabstract: R は統計計算のための言語です．\nformat:\n  html:\n    code-fold: false\nlisting: \n  -   id: lst-R\n      type: grid\n      sort: false\n      contents:\n          - R1.qmd\n          - R2.qmd\n          - R3.qmd\n          - R4.qmd\n          - R5.qmd\n          - YUIMA.qmd\n      date-format: iso\n      fields: [title,image,date,subtitle]\n---\n\n\n::: {.callout-important appearance=\"simple\"}\n1. 全ては関数である．\n2. 全てはベクトルであり，複雑な構造は dispatch の賜物である．\n:::\n\n::: {#lst-R}\n:::\n\n## 基本\n\n### 対話モード\nバッチ処理は`R CMD BATCH file.z`で行う．\n\n> When a user types a command at the prompt (or when an expression is read from a file) the first thing that happens to it is that the command is transformed by the parser into an internal representation. The evaluator executes parsed R expressions and returns the value of the expression. All expressions have a value. This is the core of the language. -- [R Language Definition](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Evaluation-of-expressions-1)\n\n* R：どこからでも対話モードで実行可能なのが R．\n* `[1]`はすぐ隣の要素の index．ALGOL 系と違い，1から index する．\n    * ベクトルは基本横で`[1]`という行の名前の後に表示される，行列の行は`[1,]`と indexing される．indexing の表示の違いでクラスの違いがわかる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(10, 20, 30, 40)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:6, nrow = 2)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n\n:::\n\n* 関数名直打ちは定義が帰ってくる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n```\n\n\n:::\n:::\n\n\n:::\n\n* `()`も，直打ちも，generic function の神である print 関数を呼んでいる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 42\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42\n```\n\n\n:::\n:::\n\n\n:::\n\n* working directory の概念がある．\n    * `getwd()`, `setwd()`\n\n### 関数\n\n* keyword をつけて呼び出せるが，位置が正しければ省略可能\n    * `f(arg1=value1, arg2=value2)`\n\n- R は **関数型言語** で，全ての実装は関数になっている．が，認知容易性のために予約語として実装された特殊文字を用いて，中置記法が使える．\n    - `+`などの二項演算子は`”+”(1,2)`として使える．\n    - `in`などの Condition Flow の宣言っぽい演算子も実装は関数．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`+`(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 %in% c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n- 関数適用の大原則：**リサイクル**\n\n  logical の`==`も，`matrix(3,3,3)`も recycle される．\n    - `(1,2,3) == (2,3,4)`はベクトルの同一性を表さず，`(F,F,F)`を返し，`matrix(3,3,3)`は３でrecycleされた3×3行列．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) + c(4, 5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in c(1, 2, 3) + c(4, 5): longer object length is not a multiple of\nshorter object length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 7 7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) == c(2, 3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(3, nrow = 3, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    3    3    3\n[2,]    3    3    3\n[3,]    3    3    3\n```\n\n\n:::\n:::\n\n\n:::\n\n### オブジェクト操作\n`?Syntax`で演算の速さなどがわかる．\n\n* 代入\n    * `foo <- object`または`object -> foo`\n    * `<<-`は再帰的代入\n        * 関数の中でしか使われず，親 environment やグローバル環境の中からも右辺を探す．右辺が見つかったら再びそれを代入する．\n    * `=`は代入もできる\n    \n    > the operator `=` is only allowed at the top level (e.g., in the complete expression typed at the command prompt) or as one of the subexpressions in a braced list of expressions.\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- 1\n\nchange_foo <- function() {\n  foo <<- foo + 1\n}\n\nchange_foo()\nprint(foo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n:::\n\n* evaluetion\n    * `(object)`\n        * `print(object)` と等価．console だと裸で良い．\n* `;`\n    * 命令の併記\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1; y <- 2; z <- x + y\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n:::\n\n* 変数名に数字が使えるのいいな．\n  * 語頭は数字にはできない．\n\n::: {.callout-caution title=\"演算子まとめ\" collapse=\"true\"}\n\n\n| Operator | Description |\n|:-:|:----------------|\n| `-`      | Minus, can be unary or binary |\n| `+`      | Plus, can be unary or binary |\n| `!`      | Unary not |\n| `~`      | Tilde, used for model formulae, can be either unary or binary |\n| `?`      | Help |\n| `:`      | Sequence, binary (in model formulae: interaction) |\n| `*`      | Multiplication, binary |\n| `/`      | Division, binary |\n| `^`      | Exponentiation, binary |\n| `%x%`    | Special binary operators, x can be replaced by any valid name |\n| `%%`     | Modulus, binary |\n| `%/%`    | Integer divide, binary |\n| `%*%`    | Matrix product, binary |\n| `%o%`    | Outer product, binary |\n| `%x%`    | Kronecker product, binary |\n| `%in%`   | Matching operator, binary (in model formulae: nesting) |\n| `%||%`   | Null coalescing operator, binary |\n| `<`      | Less than, binary |\n| `>`      | Greater than, binary |\n| `==`     | Equal to, binary |\n| `>=`     | Greater than or equal to, binary |\n| `<=`     | Less than or equal to, binary |\n| `&`      | And, binary, vectorized |\n| `&&`     | And, binary, not vectorized |\n| `|`      | Or, binary, vectorized |\n| `||`     | Or, binary, not vectorized |\n| `<-`     | Left assignment, binary |\n| `->`     | Right assignment, binary |\n| `$`      | List subset, binary |\n\n: [R Language Definition](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Operators-1) {.active .hover .bordered .responsive-sm}\n\n:::\n\n\n## 制御\n\n* `{suite}`：ブロック\n\n    ブロックは閉じるまで評価されない．\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  { x <- 0\n  x + 5\n  }\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] 5\n  ```\n  \n  \n  :::\n  :::\n\n\n* `if`, `else`, `else if`：条件分岐\n\n    ```r\n    if ( statement1 )\n        statement2\n    else\n        statement3\n    ```\n\n* `for`, `while`, `repeat`：反復\n    \n    ```r\n    for ( name in vector ) {\n        statement\n    }\n    ```\n\n    ```r\n    while ( statement1 ) {\n        statement2\n    }\n    ```\n\n    ```r\n    repeat {\n        statement\n        if ( condition ) break\n    }\n    ```\n\n* `switch (statement, list)`：`statement`を評価した結果得る数値を用いて，`list`を indexing して（評価して）返す．\n\n  * `switch`は関数として実装されているが，「評価」のステップがあるために制御構文として使える．\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  x <- 3\n  switch(x, 2+2, mean(1:10), rnorm(5))\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] -1.21239418 -0.42072586  0.93179085  0.70058355  0.03332041\n  ```\n  \n  \n  :::\n  :::\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  switch(2, 2+2, mean(1:10), rnorm(5))\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] 5.5\n  ```\n  \n  \n  :::\n  :::\n\n\n\n関数型言語なので，forもifもfunctionも関数だと思った方がいい．()と{}を取り，{}はブロックの意味しか持たず，改行を挟まないなら省略して良い．（C, C++, Python, PerlなどのALGOL系と全く同じ）．文は改行文字かセミコロンで区切る．\nなるべく制御（再帰構造）を避けるのが関数型言語としての目標になる．\n\nControl\n多分if(cond)というのは引数だ．全ての関数は引数を離して書いても良い．$も同様．\n改行を経ないexprの併記は;を用いる．{}は改行を超えてコンパイラにまとまりを通知する．インデントは視認性以外の意味はなさそう．\n\n* if節\n    * 構文：if(Cond) {expr} else {expr}\n        * Condとは長さ1のlogical vectorに評価可能なobject\n        * いずれの{}もなくても動くが，行を分けたいなら必要．document読む限りつけるのが推奨されている．\n    * ifelse(test, yes, no)：testには条件式（logical型に変換可能なobject），yes/noには返すすべき文字列．\n        * ifelseにはない．\n* for文\n    * 構文：for(var in seq) expr\n        * seqは最初に評価される．\n        * length(seq)=0ならすぐにloopが終わる\n        * inは特別なControl Flowのための予約語．\n* while文\n    * 構文：while(Cond) expr\n* その他\n    * repeat expr\n    * break：loopの外の最初の文に制御を移す\n    * next\n\nvalueについて：全部静かに返り値を返している\n* ifはcondの評価の結果をlogicalを返す\n* for, while, repeatはNULLを返す\n* break, nextはloopの中で制御を移すので，返り値は持たない．\n\n## 関数定義\nfunction object を返す constructor\n\nfunction(arglist) expr\n[return(value)]\n- arglistはname=exprの形のexpressionも許容．\n    - exprの中に前の引数を入れてさえ良い．\n    - 参照時，名前つき引数指定 option = value では、引数名 option は一意的に決定される限り、先頭の文字列だけを与えるだけで良い！！！何それwww\n- returnが関数とは．関数型言語\n- valueもexpressionで良い．\n- returnを省略すると，最後になされた評価の値が返される．通常は実行時間が速くなるので省略されるが可読性は下がるかも．\n- valueを省略するとNULLが返される．\n\nリストを引数として受け入れたい\n* 特殊引数…\n    * この後に定義された引数は，keyword付きで参照しないとエラーになる．\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}