{
  "hash": "9d43186c63d8b1b77593bf039b9e7011",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R（１）基本文法\"\nsubtitle: \"基本パッケージとその文法\"\nauthor: \"司馬 博文\"\ndate: 6/5/2024\ncategories: [Computation, R]\nbibliography: \n    - ../../../mathematics.bib\n    - ../../../bib.bib\ncsl: ../../../apa.csl\nabstract-title: 概要\nabstract: R は統計計算のための言語です．\nformat:\n  html:\n    code-fold: false\n---\n\n\n::: {.callout-important appearance=\"simple\"}\n1. 全ては関数である．\n2. 全てはベクトルであり，複雑な構造は dispatch の賜物である．\n:::\n\n## 基本\n\n### 対話モード\nバッチ処理は`R CMD BATCH file.z`で行う．\n\n* R：どこからでも対話モードで実行可能なのが R．\n* `[1]`はすぐ隣の要素の index．ALGOL 系と違い，1から index する．\n    * ベクトルは基本横で`[1]`という行の名前の後に表示される，行列の行は`[1,]`と indexing される．indexing の表示の違いでクラスの違いがわかる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(10, 20, 30, 40)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:6, nrow = 2)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n\n:::\n\n* 関数名直打ちは定義が帰ってくる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n```\n\n\n:::\n:::\n\n\n:::\n\n* `()`も，直打ちも，generic function の神である print 関数を呼んでいる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 42\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42\n```\n\n\n:::\n:::\n\n\n:::\n\n* working directory の概念がある．\n    * `getwd()`, `setwd()`\n\n### 関数\n\n* keyword をつけて呼び出せるが，位置が正しければ省略可能\n    * `f(arg1=value1, arg2=value2)`\n\n- R は **関数型言語** で，全ての実装は関数になっている．が，認知容易性のために予約語として実装された特殊文字を用いて，中置記法が使える．\n    - `+`などの二項演算子は`”+”(1,2)`として使える．\n    - `in`などの Condition Flow の宣言っぽい演算子も実装は関数．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`+`(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 %in% c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n- 関数適用の大原則：**リサイクル**\n\n  logical の`==`も，`matrix(3,3,3)`も recycle される．\n    - `(1,2,3) == (2,3,4)`はベクトルの同一性を表さず，`(F,F,F)`を返し，`matrix(3,3,3)`は３でrecycleされた3×3行列．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) + c(4, 5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in c(1, 2, 3) + c(4, 5): longer object length is not a multiple of\nshorter object length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 7 7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) == c(2, 3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(3, nrow = 3, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    3    3    3\n[2,]    3    3    3\n[3,]    3    3    3\n```\n\n\n:::\n:::\n\n\n:::\n\n### オブジェクト操作\n`?Syntax`で演算の速さなどがわかる．\n\n* 代入\n    * `foo <- object`または`object -> foo`\n    * `<<-`は再帰的代入\n        * 関数の中でしか使われず，親 environment やグローバル環境の中からも右辺を探す．右辺が見つかったら再びそれを代入する．\n    * `=`は代入もできる\n    \n    > the operator `=` is only allowed at the top level (e.g., in the complete expression typed at the command prompt) or as one of the subexpressions in a braced list of expressions.\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- 1\n\nchange_foo <- function() {\n  foo <<- foo + 1\n}\n\nchange_foo()\nprint(foo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n:::\n\n* evaluetion\n    * `(object)`\n        * `print(object)` と等価．console だと裸で良い．\n* `;`\n    * 命令の併記\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1; y <- 2; z <- x + y\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n:::\n\n* 変数名に数字が使えるのいいな．\n  * 語頭は数字にはできない．\n\n## オブジェクト\n\n### データ構造：built-in は５つ\n\n* vector\n    * scaler オブジェクトは長さ１の vector として実装されている？\n        * scaler は数値，文字列，論理値など．\n    * `c()`が constructor\n    * `x[]`で indexing できる\n        * `[]`の中身はベクトルで指定できる！これが slice の代わり．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(10, 20, 30, 40, 50)\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 30 40\n```\n\n\n:::\n:::\n\n\n:::\n\n* matrix\n    * `matrix()` がコンストラクタ\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:9, nrow = 3, ncol = 3)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\n:::\n\n* list：ベクトルとの違いはデータ型が不均一であるのを認めること．\n    * `list()` がコンストラクタ\n    * 多分データ分析じゃない計算機命令的な棲み分け．一番 csv みたい，\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlst <- list(name = \"Alice\", age = 25, scores = c(90, 85, 88))\nlst\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$name\n[1] \"Alice\"\n\n$age\n[1] 25\n\n$scores\n[1] 90 85 88\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlst[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlst$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"\n```\n\n\n:::\n:::\n\n\n:::\n\n* data frame：要は実データに即した構造で，行列の拡張．csv みたいな．長さの等しい vector の list．\n    * `data.frame` がコンストラクタ．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(name = c(\"Alice\", \"Bob\"), age = c(25, 30))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   name age\n1 Alice  25\n2   Bob  30\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\" \"Bob\"  \n```\n\n\n:::\n:::\n\n\n:::\n\n* array：ベクトル，行列のその先へ\n    * `array`がコンストラクタ\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\narr <- array(1:8, dim = c(2, 2, 2))\narr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narr[1, 2, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n:::\n\n### データ型：built-in は 25^[[@Wickham2019] [第12章](https://adv-r.hadley.nz/base-types.html)．]\n`typeof()`で調べる\n\n* `int`：整数\n* `double`：クラスとしては`numeric`として実装されている．浮動小数点\n  * `3.4e-2`は $3.4×10^-2$ で表す．\n* `complex`：`1i`を虚数単位とし，`a+bi`と表す．\n* `character`\n    * `paste(x,y,[sep=“ “])`\n* `logical`：Boole 値\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"complex\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n* `print(pi, digit=12)`\n    * 任意精度表示．多分 print.numeric_version への dispatch\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(pi, digit=12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.14159265359\n```\n\n\n:::\n:::\n\n\n### 予約語とそのデータ型\n\n* `pi`, `e`：`double`型\n* `Inf`, `NaN`：`doule`型\n* `T`,`F`：TRUE と FALSE の予約．`logical` 型\n    * `as.numeric()`で`1`,`0`に埋め込まれる．\n* `NA`：Not Available，統計データの欠損を表す．\n    * 各モードに１つずつ存在する generic な存在である．\n    * `NA_integer_`, `NA_real_`, `NA_complex_`, `NA_character_`, `NA_logical_`, ......\n* `LETTERS`, `letters`：アルファベットのベクトル，`character` 型\n* `NULL`：`NULL` 型でモードを持たない特殊なオブジェクト．$\\emptyset$ のこと．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLETTERS\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n```\n\n\n:::\n:::\n\n\n:::\n\n### データ構造\n`class()`で調べることが出来る．\n\n多くはデータ型（`typeof()`）と一致する．\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n### Logical：２値関数\nベクトルを各成分ごとに評価して，logical vector を返す関数．\n\n* `!=`, `>=`, `<=`\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(3, 2, 1)\nx != y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx >= y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <= y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n* `is.null()`, `is.na()`, `is.nan()`, `is.finite()`, `is.infinite()`\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(c(1, NA, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.finite(c(1, Inf, NA, NaN))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n:::\n\n* `identical(1,1.0)`：`T`である，いずれも倍精度浮動小数点で表現されるので．\n* `all.equal()`\n* `&`,`|`：論理積・和\n* `&&`, `||`：条件式の論理積・和\n  * ただし，最初の要素にのみ適用される．\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(TRUE, FALSE, TRUE)\ny <- c(TRUE, TRUE, FALSE)\nx & y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx && y\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x && y: 'length = 3' in coercion to 'logical(1)'\n```\n\n\n:::\n:::\n\n:::\n\n* `xor()`：排他的論理和\n* `%in%`：match の二項関係版 interface．\n    * `\"%in%\" <- function(x, table) match(x, table, nomatch = 0) > 0`が現状の定義\n\n* `with(data, expr, …)`\n    * `expr`はlogical expression to evaluate をベタがき\n* `match(x, table)`\n    * `x %in% table`と使える．\n    * `x`：vector\n    * `table`：vector\n    * 返り値：logical vector\n\n### Base\n\n* library(package) and require(package) both load the namespace of the package with name package and attach it on the search list.\n    * require is designed for use inside other functions; it returns FALSE and gives a warning (rather than an error as library() does by default) if the package does not exist.\n\n### Utils\n\n* str(obj)：R objectの構造を教えてくれる．structure\n* mode(obj)：オブジェクトのモード＝データ型を返す．\n* class(obj)：Rは全てのものはオブジェクトだから，classを返す．\n\n* help()：?keywordと等価．\n    * Trig {base}：パッケージbaseのTrigについての説明．\n    * graphics::hist：はパッケージgraphicsの関数histについて．\n    * 特殊関数を調べるには””でescapeする必要があることがある．\n* example()：Rのこの機能やばすぎる\n    * help内の例を実行\n    * demo()にさらにある．\n* help.search()：??”keyword””と等価．\n    * キーワード検索\n    * Google検索と同じ要領で使ってください．\n\n## 統計処理\n\n### Stats\n\n* runif(n [,min=0, max=1])：区間上の一様分布\n    * dunif：density\n    * punif：distribution function\n    * qunif：quantile function\n* rnorm(n [, mean=0, sd=1])：正規分布\n    * dnorm\n    * pnorm\n    * qnorm\n* sample(x, size [,replace=FALSE, prob=NULL])：ベクトルxの中からsize個をランダム抽出\n    * 元々が非復元抽出なので，size=length(x)とすると置換．replace=TRUEとすると復元抽出．\n    * probにvectorを引かせると，xの要素にでやすさの重みがつく．\n\n### 時系列分析\n* ts.plot()\n\n### Graphics\n\n* hist(x, …)\n    * breaks=“Starges”：binの数をStargesの公式で定めているところを，scaler nで指定できる．\n    * col=“NULL”：barsをfillする色”lightgreen”などにできる．\n    * main, xlab, ylab：title()でgetするattribution\n    * right=“TRUE”：デフォルトではbinはright-closedである．\n* plot(x[, y, …])\n    * xが適切な構造を持つならyはいらない．\n    * arrayを渡すと，タイル図になる．\n    * dfを渡すと，算譜図になる．\n* image(x)\n    * \n\n### grDevices\n\n* hcl.colors(n)：n色のpalleteを作成する．\n\n### Datasets\n`data()`で一覧を見れる\n\n* co2\n    * Mauna LoaのCO2 concentration\n* volcano\n    * Aukland’s Maunga Whauのtopographic data\n    * 10m×10m範囲での\n* Titanic\n    * 4-dimentional array\n* airquality\n    * New York Airquality Measurement\n    * 6変数についてのdata frame\n* jpdata\n    * 統計局からの県別データでutf8なのでread.csv(file=“”, fileEncoding=“utf8”)が安全．\n    * jpdata1.csv：対象データ\n    * jpdata2.csv：対象データの内容\n    * jpdata3.csv：圏別と地域の対応関係\n* tokyo_weather\n    * 気象庁からのデータ．\n* tokyo_covid19\n    * 東京のstopcovid19.metro.tokyo.lg.jpのデータ項目．",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}