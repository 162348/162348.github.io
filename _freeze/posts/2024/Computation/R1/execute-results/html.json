{
  "hash": "bbc31bd22efcf1b66515affa9ebfb8ba",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R（１）基本文法\"\nsubtitle: \"基本パッケージとその文法\"\nauthor: \"司馬 博文\"\ndate: 5/7/2021\ndate-modified: 6/7/2024\ncategories: [Computation, R]\nbibliography: \n    - ../../../mathematics.bib\n    - ../../../bib.bib\ncsl: ../../../apa.csl\nabstract-title: 概要\nabstract: R は統計計算のための言語です．\nformat:\n  html:\n    code-fold: false\n---\n\n\n::: {.callout-important appearance=\"simple\"}\n1. 全ては関数である．\n2. 全てはベクトルであり，複雑な構造は dispatch の賜物である．\n:::\n\n## 基本\n\n### 対話モード\nバッチ処理は`R CMD BATCH file.z`で行う．\n\n> When a user types a command at the prompt (or when an expression is read from a file) the first thing that happens to it is that the command is transformed by the parser into an internal representation. The evaluator executes parsed R expressions and returns the value of the expression. All expressions have a value. This is the core of the language. -- [R Language Definition](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Evaluation-of-expressions-1)\n\n* R：どこからでも対話モードで実行可能なのが R．\n* `[1]`はすぐ隣の要素の index．ALGOL 系と違い，1から index する．\n    * ベクトルは基本横で`[1]`という行の名前の後に表示される，行列の行は`[1,]`と indexing される．indexing の表示の違いでクラスの違いがわかる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(10, 20, 30, 40)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10 20 30 40\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:6, nrow = 2)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n:::\n\n\n:::\n\n* 関数名直打ちは定義が帰ってくる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (..., na.rm = FALSE)  .Primitive(\"sum\")\n```\n\n\n:::\n:::\n\n\n:::\n\n* `()`も，直打ちも，generic function の神である print 関数を呼んでいる．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 42\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 42\n```\n\n\n:::\n:::\n\n\n:::\n\n* working directory の概念がある．\n    * `getwd()`, `setwd()`\n\n### 関数\n\n* keyword をつけて呼び出せるが，位置が正しければ省略可能\n    * `f(arg1=value1, arg2=value2)`\n\n- R は **関数型言語** で，全ての実装は関数になっている．が，認知容易性のために予約語として実装された特殊文字を用いて，中置記法が使える．\n    - `+`などの二項演算子は`”+”(1,2)`として使える．\n    - `in`などの Condition Flow の宣言っぽい演算子も実装は関数．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n`+`(1, 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n1 %in% c(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n:::\n\n- 関数適用の大原則：**リサイクル**\n\n  logical の`==`も，`matrix(3,3,3)`も recycle される．\n    - `(1,2,3) == (2,3,4)`はベクトルの同一性を表さず，`(F,F,F)`を返し，`matrix(3,3,3)`は３でrecycleされた3×3行列．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) + c(4, 5)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in c(1, 2, 3) + c(4, 5): longer object length is not a multiple of\nshorter object length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 7 7\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3) == c(2, 3, 4)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix(3, nrow = 3, ncol = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    3    3    3\n[2,]    3    3    3\n[3,]    3    3    3\n```\n\n\n:::\n:::\n\n\n:::\n\n### オブジェクト操作\n`?Syntax`で演算の速さなどがわかる．\n\n* 代入\n    * `foo <- object`または`object -> foo`\n    * `<<-`は再帰的代入\n        * 関数の中でしか使われず，親 environment やグローバル環境の中からも右辺を探す．右辺が見つかったら再びそれを代入する．\n    * `=`は代入もできる\n    \n    > the operator `=` is only allowed at the top level (e.g., in the complete expression typed at the command prompt) or as one of the subexpressions in a braced list of expressions.\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfoo <- 1\n\nchange_foo <- function() {\n  foo <<- foo + 1\n}\n\nchange_foo()\nprint(foo)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n:::\n\n* evaluetion\n    * `(object)`\n        * `print(object)` と等価．console だと裸で良い．\n* `;`\n    * 命令の併記\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1; y <- 2; z <- x + y\nprint(z)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n:::\n\n\n:::\n\n* 変数名に数字が使えるのいいな．\n  * 語頭は数字にはできない．\n\n::: {.callout-caution title=\"演算子まとめ\" collapse=\"true\"}\n\n\n| Operator | Description |\n|:-:|:----------------|\n| `-`      | Minus, can be unary or binary |\n| `+`      | Plus, can be unary or binary |\n| `!`      | Unary not |\n| `~`      | Tilde, used for model formulae, can be either unary or binary |\n| `?`      | Help |\n| `:`      | Sequence, binary (in model formulae: interaction) |\n| `*`      | Multiplication, binary |\n| `/`      | Division, binary |\n| `^`      | Exponentiation, binary |\n| `%x%`    | Special binary operators, x can be replaced by any valid name |\n| `%%`     | Modulus, binary |\n| `%/%`    | Integer divide, binary |\n| `%*%`    | Matrix product, binary |\n| `%o%`    | Outer product, binary |\n| `%x%`    | Kronecker product, binary |\n| `%in%`   | Matching operator, binary (in model formulae: nesting) |\n| `%||%`   | Null coalescing operator, binary |\n| `<`      | Less than, binary |\n| `>`      | Greater than, binary |\n| `==`     | Equal to, binary |\n| `>=`     | Greater than or equal to, binary |\n| `<=`     | Less than or equal to, binary |\n| `&`      | And, binary, vectorized |\n| `&&`     | And, binary, not vectorized |\n| `|`      | Or, binary, vectorized |\n| `||`     | Or, binary, not vectorized |\n| `<-`     | Left assignment, binary |\n| `->`     | Right assignment, binary |\n| `$`      | List subset, binary |\n\n: [R Language Definition](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html#Operators-1) {.active .hover .bordered .responsive-sm}\n\n:::\n\n\n### 制御\n\n* `{suite}`：ブロック\n\n    ブロックは閉じるまで評価されない．\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  { x <- 0\n  x + 5\n  }\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] 5\n  ```\n  \n  \n  :::\n  :::\n\n\n* `if`, `else`, `else if`：条件分岐\n\n    ```r\n    if ( statement1 )\n        statement2\n    else\n        statement3\n    ```\n\n* `for`, `while`, `repeat`：反復\n    \n    ```r\n    for ( name in vector ) {\n        statement\n    }\n    ```\n\n    ```r\n    while ( statement1 ) {\n        statement2\n    }\n    ```\n\n    ```r\n    repeat {\n        statement\n        if ( condition ) break\n    }\n    ```\n\n* `switch (statement, list)`：`statement`を評価した結果得る数値を用いて，`list`を indexing して返す．\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  x <- 3\n  switch(x, 2+2, mean(1:10), rnorm(5))\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1]  0.1257957  0.4054643  0.3092814 -0.2748118 -1.3159889\n  ```\n  \n  \n  :::\n  :::\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  switch(2, 2+2, mean(1:10), rnorm(5))\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ```\n  [1] 5.5\n  ```\n  \n  \n  :::\n  :::\n\n\n## 基本型\n\n### データ構造：built-in は５つ\n\n* vector\n    * scaler オブジェクトは長さ１の vector として実装されている？\n        * scaler は数値，文字列，論理値など．\n    * `c()`が constructor\n    * `x[]`で indexing できる\n        * `[]`の中身はベクトルで指定できる！これが slice の代わり．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(10, 20, 30, 40, 50)\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 10\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20 30 40\n```\n\n\n:::\n:::\n\n\n:::\n\n* matrix\n    * `matrix()` がコンストラクタ\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:9, nrow = 3, ncol = 3)\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmat[2, 3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8\n```\n\n\n:::\n:::\n\n\n:::\n\n* list：ベクトルとの違いはデータ型が不均一であるのを認めること．\n    * `list()` がコンストラクタ\n    * 多分データ分析じゃない計算機命令的な棲み分け．一番 csv みたい，\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlst <- list(name = \"Alice\", age = 25, scores = c(90, 85, 88))\nlst\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$name\n[1] \"Alice\"\n\n$age\n[1] 25\n\n$scores\n[1] 90 85 88\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlst[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlst$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\"\n```\n\n\n:::\n:::\n\n\n:::\n\n* data frame：要は実データに即した構造で，行列の拡張．csv みたいな．長さの等しい vector の list．\n    * `data.frame` がコンストラクタ．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(name = c(\"Alice\", \"Bob\"), age = c(25, 30))\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   name age\n1 Alice  25\n2   Bob  30\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf[1, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 25\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndf$name\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Alice\" \"Bob\"  \n```\n\n\n:::\n:::\n\n\n:::\n\n* array：ベクトル，行列のその先へ\n    * `array`がコンストラクタ\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\narr <- array(1:8, dim = c(2, 2, 2))\narr\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n, , 1\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n, , 2\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\narr[1, 2, 2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 7\n```\n\n\n:::\n:::\n\n\n:::\n\n### データ型：built-in は 25^[[@Wickham2019] [第12章](https://adv-r.hadley.nz/base-types.html)．]\n`typeof()`で調べる\n\n> Note that in the C code underlying R, all objects are pointers to a structure with typedef `SEXPREC`; the different R data types are represented in C by `SEXPTYPE`, which determines how the information in the various parts of the structure is used. \n\n* `int`：整数\n* `double`：クラスとしては`numeric`として実装されている．浮動小数点\n  * `3.4e-2`は $3.4×10^-2$ で表す．\n* `complex`：`1i`を虚数単位とし，`a+bi`と表す．\n* `character`\n    * `paste(x,y,[sep=“ “])`\n* `logical`：Boole 値\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1i)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"complex\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n\n:::\n\n* `print(pi, digit=12)`\n    * 任意精度表示．多分 print.numeric_version への dispatch\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(pi, digit=12)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.14159265359\n```\n\n\n:::\n:::\n\n\n### 予約語とそのデータ型\n\n* `pi`, `e`：`double`型\n* `Inf`, `NaN`：`doule`型\n* `T`,`F`：TRUE と FALSE の予約．`logical` 型\n    * `as.numeric()`で`1`,`0`に埋め込まれる．\n* `NA`：Not Available，統計データの欠損を表す．\n    * 各モードに１つずつ存在する generic な存在である．\n    * `NA_integer_`, `NA_real_`, `NA_complex_`, `NA_character_`, `NA_logical_`, ......\n* `LETTERS`, `letters`：アルファベットのベクトル，`character` 型\n* `NULL`：`NULL` 型でモードを持たない特殊なオブジェクト．$\\emptyset$ のこと．\n\n::: {.callout-caution collapse=\"true\" title=\"例\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLETTERS\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n[20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\n```\n\n\n:::\n:::\n\n\n:::\n\n### データのクラス\n`class()`で調べることが出来る．\n\n多くはデータ型（`typeof()`）と一致する．\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(pi)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"numeric\"\n```\n\n\n:::\n:::\n\n\n### Logical：２値関数\nベクトルを各成分ごとに評価して，logical vector を返す関数．\n\n* `!=`, `>=`, `<=`\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ny <- c(3, 2, 1)\nx != y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx >= y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx <= y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n:::\n\n* `is.null()`, `is.na()`, `is.nan()`, `is.finite()`, `is.infinite()`\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(c(1, NA, 3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nis.finite(c(1, Inf, NA, NaN))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n:::\n\n* `identical(1,1.0)`：`T`である，いずれも倍精度浮動小数点で表現されるので．\n* `all.equal()`：「ほぼ同じ」かどうか．数値の近似比較に使える．\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nidentical(1, 1.0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nall.equal(1, 1.0000001)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Mean relative difference: 1e-07\"\n```\n\n\n:::\n:::\n\n:::\n\n* `&`,`|`：論理積・和\n* `&&`, `||`：条件式の論理積・和\n  * `&`,`|`と違い，ベクトルには使えない．\n* `xor()`：排他的論理和\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(TRUE, FALSE, TRUE)\ny <- c(TRUE, TRUE, FALSE)\nx & y\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE FALSE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nx && y\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in x && y: 'length = 3' in coercion to 'logical(1)'\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nxor(x, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n:::\n\n* `%in%`：match の二項関係版 interface．\n    * `\"%in%\" <- function(x, table) match(x, table, nomatch = 0) > 0`が現状の定義\n* `with(data, expr, …)`\n    * `data`：data frame\n    * `expr`は`data`の列名に関する expression をベタがき\n    * 列ごとに`expr`を実行した結果を返す．\n* `match(x, table)`\n    * `x %in% table`と使える．\n    * `x`：vector\n    * `table`：vector\n    * 返り値：logical vector\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 2, 3)\ntable <- c(2, 3, 4)\nx %in% table\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE  TRUE  TRUE\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmatch(x, table)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA  1  2\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- data.frame(a = 1:3, b = 4:6)\nwith(data, a + b)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 7 9\n```\n\n\n:::\n:::\n\n:::\n\n### `mode` について\n\n* `str(obj)`：R object の構造を教えてくれる．structure\n* `mode(obj)`：オブジェクトのモード＝データ型を返す．\n* `class(obj)`：R は全てのものはオブジェクトだから，class を返す．この値に従って dispatch されている．\n\n> Function `mode` gives information about the mode of an object in the sense of Becker, Chambers & Wilks (1988), and is more compatible with other implementations of the S language. -- [R Language Definition](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html)\n\n* `storage.mode(obj)`：オブジェクトの storage mode を返す．\n\n> Finally, the function `storage.mode` returns the storage mode of its argument in the sense of Becker et al. (1988).  -- [R Language Definition](https://stat.ethz.ch/R-manual/R-devel/doc/manual/R-lang.html)\n\n* `help()`：`?keyword`と等価．\n    * `Trig {base}`：パッケージ base の Trig についての説明．\n    * `graphics::hist`：はパッケージ graphics の関数 hist について．\n    * 特殊関数を調べるには`””`で escape する必要があることがある．\n* `example()`：R のこの機能やばすぎる\n    * help 内の例を実行\n    * `demo()`がさらにある．\n* `help.search()`：`??”keyword”`と等価．\n    * キーワード検索\n    * Google 検索と同じ要領で使ってください．\n\n## 属性\n\n`NULL`以外の全てのオブジェクトは`attribute`を持ち得る．`attribute`とは，全ての成分に名前がついた`pairlist`である．\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(y ~ x1 + x2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$class\n[1] \"formula\"\n\n$.Environment\n<environment: R_GlobalEnv>\n```\n\n\n:::\n:::\n\n\n属性は，第一義的には R にクラス構造を実装するのに使われる．`class`属性を評価し，そのオブジェクトにどの function dispatch を適用するかを決定する．\n\n\n```{=html}\n<div class=\"article-card-container\">\n  <div class=\"article-card\">\n    <a href=\"https://162348.github.io/posts/2024/Computation/R0.html\" target=\"_blank\">\n      <img src=\"https://162348.github.io/profile.jpg\" alt=\"Article Image\" class=\"article-image\">\n      <div class=\"article-content\">\n        <h3 class=\"article-title\">R の概観</h3>\n        <p class=\"article-description\">R は統計計算のための言語です．  </p>\n      </div>\n    </a>\n  </div>\n</div>\n```\n\n\n### `names`\n\n`names`は，ベクトルの各要素に名前をつけるための属性であり，indexing にも使われる．\n\n### `class`\n\n`class`は，オブジェクトのクラスを指定する文字列である．",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}