{
  "hash": "275e15199fb1783a41ccca070607c32b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R（５）統計処理\"\nauthor: \"司馬 博文\"\ndate: 5/7/2021\ndate-modified: 6/7/2024\ncategories: [Computation, R]\nbibliography: \n    - ../../../mathematics.bib\n    - ../../../bib.bib\ncsl: ../../../apa.csl\nabstract-title: 概要\nabstract: R は統計計算のための言語です．\nformat:\n  html:\n    code-fold: false\n---\n\n\n## 統計処理\n\n### Stats\n\n* `runif(n [,min=0, max=1])`：区間上の一様分布\n    * `dunif`：density\n    * `punif`：distribution function\n    * `qunif`：quantile function\n* ``rnorm(n [, mean=0, sd=1])`：正規分布\n    * `dnorm`\n    * `pnorm`\n    * `qnorm`\n* `sample(x, size [,replace=FALSE, prob=NULL])`：ベクトル`x`の中から`size`個をランダム抽出\n    * 元々が非復元抽出なので，`size=length(x)`とすると置換．`replace=TRUE`とすると復元抽出．\n    * `prob`に vector を引かせると，`x`の要素にでやすさの重みがつく．\n\n### 時系列分析\n* {ts.plot()}\n\n### Graphics\n\n* `hist(x, …)`\n    * `breaks=“Starges”`：bin の数を Starges の公式で定めているところを，scaler `n`で指定できる．\n    * `col=“NULL”`：bars を fill する色．`lightgreen`などにできる．\n    * `main`, `xlab`, `ylab`：`title()`で get する attribution\n    * `right=“TRUE”`：デフォルトでは bin は right-closed である．\n* `plot(x[, y, …])`\n    * `x`が適切な構造を持つなら{y}はいらない．\n    * array を渡すと，タイル図になる．\n    * df を渡すと，散布図になる．\n* `image(x)`\n\n### grDevices\n\n* `hcl.colors(n)`：`n`色の pallete を作成する．\n\n### Datasets\n`data()`で一覧を見れる\n\n* `co2`\n    * Mauna Loa の CO2 concentration\n* `volcano`\n    * Aukland’s Maunga Whau の topographic data\n    * 10m×10m 範囲\n* `Titanic`\n    * 4-dimentional array\n* `airquality`\n    * New York Airquality Measurement\n    * ６変数についての data frame\n* `jpdata`\n    * 統計局からの県別データで utf8 なので`read.csv(file=“”, fileEncoding=“utf8”)`が安全．\n    * `jpdata1.csv`：対象データ\n    * `jpdata2.csv`：対象データの内容\n    * `jpdata3.csv`：圏別と地域の対応関係\n* `tokyo_weather`\n    * 気象庁からのデータ．\n* `tokyo_covid19`\n    * 東京の stopcovid19.metro.tokyo.lg.jp のデータ項目．\n\n### `formula`クラス\na symbolic description of the model to be fitted\n\n#### 構成\n\n```r\ny ~ x1 + x2 + ...\n```\n\n| | |\n|:---:|:---:|\n| `class` | `formula` |\n| `typeof` | `language` |\n| `mode` | `call` |\n\n: {.active .hover .bordered .responsive-sm}\n\n::: {.callout-caution title=\"例\" collapse=\"true\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nformula <- y ~ x1 + x2 + x3\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(formula)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"language\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(formula)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"formula\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(formula)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"formula\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(formula)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nClass 'formula'  language y ~ x1 + x2 + x3\n  ..- attr(*, \".Environment\")=<environment: R_GlobalEnv> \n```\n\n\n:::\n:::\n\n:::\n\n\n#### メソッド\n* `summary(object, ...)`\n\n#### 線型モデルのフィッチxイング\n```r\nlm(formula, data, subset, weights, na.action, method = \"qr\", model = TRUE, x = FALSE, y = FALSE, qr = TRUE, singular.ok = TRUE, contrasts = NULL, offset, ...)\n```\n* `formula`：`vector ~ vector`の形の\n* 最小二乗法を使って，formula `y~x`を関係式 $y = a + bx$ の $a,b$ の値を定める．\n    * 推定値は `$coefficients` に格納される．\n\n## データの扱い\n\nR：５．データI/Oと整形\nindexing / filteringによる整形と書き出し\nNAが入っているデータフレームを扱うときは，状況依存の振る舞いをするので文法に注意する．\n\nLogical Expressionの復習\nベクトルをrecycleにより各成分ごとに評価して，logical vectorを返す2値関数である．\n\n* ==, !=, >=, <=：T==1はTが返る．\n* is.null(), is.na(), is.nan(), is.finite(), is.infinite(), \n* identical(1,1.0)：Tである，1もdouble型（倍精度浮動小数点）で表現されるので．\n    * ベクトルとしての同一性はall(x==y)などで表現できる．\n* all.equal()\n* &,|：論理積・和\n* &&, ||：条件式の論理積・和\n* xor()：排他的論理和\n* %in%：matchの二項関係版interface．\n    * \"%in%\" <- function(x, table) match(x, table, nomatch = 0) > 0が現状の定義\n\n関数型インターフェース\n* match(x, table)\n    * x %in% tableと使える．\n    * x：vector\n    * table：vector\n    * 返り値：logical vector\n\nfiltering：Logical Vectorを介してデータを選び出す技法\n\n基本：v[ vを含むexpr ]\n\nインデックス番号の取得\n* which(expr with x)：logical vector xからTUREのindex numberの列を抽出する\n    * 帰ってきたベクトルで元のdfをindexingできる\n* which.min(x)などもある\n\n* x[index]：logical vectorでindexingするとTRUEのみを選び出す．\n    * x[cond]：x>3は評価するとlogical vectorである．\n    * x[which(cond)]：numeric vectorでindexしている点だけ違う．\n    - x[which(cond),]：行全体を見たい場合．これからwhichを抜かすとNAなので参照不可能．\n* df$Ozone>10：でも参照できる．\n    * データフレームの各列はベクトルなリストなので，$はベクトルが返る\n* -：省く\n    * -WindでWindの列を除く．Windの列についてだけ全てFalseのベクトルを返しているのか？\n\n条件式評価の関数型インターフェース\n* with(data, expr, …)\n    * exprはlogical expression to evaluateをベタがき\n* ifelse(b,u,v)\n    * b：logical expression．\n    * u：bの第i要素がTの場合，uiが代入される．\n    * v：bの第i要素がFの場合，viが代入される．\n    * 出来上がったuとvの折衷ベクトルが返る．\n\nデータの取り出し\n\n次のレベルのインターフェース\n* subset(x, subset, select, drop=FALSE)：切り出して使う．\n    * x：vectors, matrices, data frames\n    * subset：行に関する条件式で，Ozone>=50など．\n    * select：列に関する条件式で，data frameのcolumnを選び出す手法を指示するvector．c(Wind,Day)など．\n    * drop：結果が１次元情報になった時，データ型をvectorにするかどうか．データフレームの構造を落とさないためにはFALSEを指定しなければならない．\n    * 特にlogical vectorとの違いは，NAを残さないこと．\n* split(x, f, drop=FALSE, …)\n* merge(x, y, …)\n\n* cbind()でdata frameをくっつける．\n\n部分代入\n\n* x[expr with x] <- 0：条件式を満たす部分のみ0にする．\n\nデータ整形\n\nデータを適切にいくつかに区分し，それぞれに統計量をあてがう．\n* aggregate(formula, data, FUN, ...)\n    * formula：y ~ xなど，xに従ってyを分類する．xは月など．yは.とするとdataを走る．\n    * FUN：meanなどの統計関数．\n    * data：dfまたはlist．\n\n種々の適切な変換関数からなるgeneric function\n* transform(`_data`, ...)\n    * _data：The object to be transformed\n\n\n入出力\nutils package\n\n* write.csv(x, file=“”)\n\nread関数は基本的にread.tableが全ての機能を持っており，そのほかは特殊化．\n必ずdata.frameを返す．\n* read.table(file=“”,header=FALSE, …)\n    * 変数名をつけるheaderがfileの一行目に存在しないデータを読み込むための関数\n* read.csv(file=“”, fileEncoding=“utf8”)\n    * Comma Separated Valueを読み込むためにdefaults値をあらかじめ設定してあるread.table()\n    * row.names=1：numeric nを引くと，n行目を列の名前とみなす．\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}