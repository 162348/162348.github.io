---
title: "Mysteries in Forward Event Chain Monte Carlo"
subtitle: "Inquiry into High-dimensional Scaling Limits"
author: "Draft Draft"
date: 10/4/2025
categories: [PDMP, MCMC, Process]
# image: Images/Cochran.svg
bibliography: 
    - ../../../assets/2023.bib
    - ../../../assets/2024.bib
    - ../../../assets/2025.bib
csl: ../../../assets/apalike.csl
# listing: 
#     -   id: lst-survey
#         type: grid
#         sort: false
#         contents:
#             - "../Survey/BDA1.qmd"
#             - "../Survey/BayesRegression.qmd"
#             - "../Survey/Survey2.qmd"
#         date-format: iso
#         fields: [title,image,date,subtitle]
---

{{< include ../../../assets/_preamble.qmd >}}

FECMC is a generalization of BPS in that it reduces to BPS (in the limit) when the orthogonal components are fully refreshed.^[FECMC with full orthogonal refresh is $d\to\infty$ asymptotically equivalent to BPS, allegedly.]

However, an interesting phenomenon is that the scaling limit seems to be entirely different from the BPS case, especially when orthogonal switches are employed as recommended in [@Michel+2020].

::: {layout="[50,50]" layout-valign="top"}

::: {#first-column}
![](FECMC/FECMC_1000d_FirstComponent_full.svg)

![](FECMC/FECMC_1000d_full.jpg)

![](FECMC/FECMC_marginal_full.svg)
:::

::: {#second-column}
![](FECMC/FECMC_1000d_FirstComponent_switch.svg)

![](FECMC/FECMC_1000d_switch.jpg)

![](FECMC/FECMC_marginal_switch.svg)
:::

:::

The frequency of orthogonal switches seems to be crucial. As an edge case, without refreshing the orthogonal components, the scaling limit seems to lose ergodicity:

![](FECMC/FECMC_1000d_no.jpg)

However, the effect of $p$ decreases as $d$ increases:

::: {layout-ncol=3 layout-valign="top"}

![$d=5000$](FECMC/FECMC_5000d_switch.jpg)

![$d=10000$](FECMC/FECMC_10000d_switch.jpg)

![$d=50000$](FECMC/FECMC_50000d_switch.jpg)

![$d=5000$](FECMC/FECMC_5000d_switch.gif)

![$d=10000$](FECMC/FECMC_10000d_switch.gif)

![$d=50000$](FECMC/FECMC_50000d_switch.gif)

:::


## Omitted Animations

Below we'll list the animations of the trajectories of FECMC (1) with its orthogonal components fully refreshed, (2) switched, and (3) no orthogonal refresh.

![(1) FECMC with its orthogonal components fully refresed](FECMC/FECMC_1000d_full.gif)

![(2) FECMC with its orthogonal components switched](FECMC/FECMC_1000d_switch.gif)

![(3) FECMC with no orthogonal refresh](FECMC/FECMC_1000d_no.gif)

## The Dynamics of FECMC with no refresh

The deterministic dynamics seems to be determined by the initial value.

Here we add two more examples with different initial values:

::: {layout="[50,50]" layout-valign="top"}

::: {#first-column}
![](FECMC/FECMC_1000d_no2.gif)
:::

::: {#second-column}
![](FECMC/FECMC_1000d_no3.gif)
:::

:::

## Diffusion Coefficient Estimation

The diffusion coefficient (denoted by `phi`) should be $(32/\pi)^{1/4}\approx1.786$, and the drift coefficient (denoted by `theta`) should be $\sqrt{2/\pi}\approx0.798$.

When $d=1000$, 

```{r}
#| output: false
library(arrow)
df <- read_feather("FECMC/FECMC_Estimation_check1.arrow")
library(zoo); z <- zoo(df$U, order.by = df$t)
library(yuima)
```

```{r}
dat <- setData(z)   # yuima.data を作成
dat
```

```{r}
ymodel <- setModel(drift="-theta*x", diffusion="phi")
param.init <- list(theta=1.0, phi=1.0)
low.par <- list(theta=0.0, phi=0.0)
upp.par <- list(theta=2.0, phi=2.0)
yuima <- setYuima(model=ymodel, data=dat)
mle1 <- qmle(yuima, start=param.init, lower=low.par, upper=upp.par)
summary(mle1)
```

When $d=10000$ with $10^5$ skeletons,

```{r}
df <- read_feather("FECMC/FECMC_Estimation_check.arrow")
z <- zoo(df$U, order.by = df$t)
dat <- setData(z)   # yuima.data を作成
dat
```

```{r}
ymodel <- setModel(drift="-theta*x", diffusion="phi")
param.init <- list(theta=1.0, phi=1.0)
low.par <- list(theta=0.0, phi=0.0)
upp.par <- list(theta=2.0, phi=2.0)
yuima <- setYuima(model=ymodel, data=dat)
mle1 <- qmle(yuima, start=param.init, lower=low.par, upper=upp.par)
summary(mle1)
```

When $d=10^5$ with $10^6$ skeletons,

```{r}
library(arrow)

df <- read_feather("FECMC/a.arrow")
library(zoo)
z <- zoo(df$U, order.by = df$t)
library(yuima)
dat <- setData(z)   # yuima.data を作成
dat
```

```{r}
df_ <- read_feather("FECMC/b.arrow")
df_$t <- df_$t - 0.000025 + df$t[length(df$t)]
df_combined <- rbind(df, df_)
library(zoo)
z <- zoo(df_combined$U, order.by = df_combined$t)
library(yuima)
dat <- setData(z)
```

```{r}
ymodel <- setModel(drift="-theta*x", diffusion="phi")
param.init <- list(theta=1.0, phi=1.0)
low.par <- list(theta=0.0, phi=0.0)
upp.par <- list(theta=2.0, phi=2.0)
yuima <- setYuima(model=ymodel, data=dat)
mle1 <- qmle(yuima, start=param.init, lower=low.par, upper=upp.par)
summary(mle1)
```