---
title: "`brms` を用いたベイズロジスティック回帰分析"
subtitle: "BMI データを題材として"
author: "司馬 博文"
date: 12/12/2024
date-modified: 12/12/2024
categories: [Bayesian, Statistics, R, Stan]
bibliography: 
    - ../../../assets/mathematics.bib
    - ../../../assets/bib.bib
    - ../../../assets/bib1.bib
csl: ../../../assets/apalike.csl
# abstract-title: 概要
# abstract: |
#     心理学などの人間を対象にする研究では変数の数が多く，正しいモデルを見つけるために分散分析 (ANOVA) が広く用いられる．
#     しかし，古典的な ANOVA 解析手法である F-検定や t-検定は，データの一側面しか伝えない．
#     一方で，モデルの仮定を前面に出したベイズ的な解析手法は，データを探索的に吟味することができ，極めて微妙な消息も捉えることが可能になる．
#     本稿では特にベイズ ANOVA 手法 [@Gelman2005], [@Rouder+2012] を採用して，そのモデルケースを実証する．
# image: Files/House.png
code-fold: false
execute:
    cache: true
listing: 
    -   id: lst-survey
        type: grid
        sort: false
        contents:
            - "BDA2.qmd"
            - "BayesRegression.qmd"
            - "../TransDimensionalModels/IdealPoint1.qmd"
        date-format: iso
        fields: [title,image,date,subtitle]
    # -   id: lst-embedding
    #     type: grid
    #     grid-columns: 1
    #     grid-item-align: center
    #     sort: false
    #     contents:
    #         - "BDA2.qmd"
    #     date-format: iso
    #     fields: [title,image,date,subtitle]
---

{{< include ../../../assets/_preamble.qmd >}}

## はじめに

多くの社会的なデータは非数値的である．しかしその背後には潜在的な連続変数を想定することが多い．

加えて，線型回帰分析の結果複雑な非線型関係が予期された際，本格的なノンパラメトリック推論に移る前に，離散変数の設定に換言して非線型性を扱いやすくするなど，離散変数を扱う積極的理由もある．

本稿ではロジスティック回帰を主に扱う．

::: {#lst-survey}
:::

## ロジスティック回帰

```{r}
#| echo: false
#| output: false
path <- "~/Desktop/Mentalism/3-BayesianDataAnalysis/Files/data.xlsx"
library(readxl)
raw_df <- read_excel(path)
library(dplyr)
raw_df <- raw_df %>%
  rename(LAB = LAB_color_100)
raw_df <- raw_df %>%
  mutate(obesity = case_when(
  BMI < 18.5 ~ "underweight",
  BMI < 25 ~ "normal",
  BMI >= 25 ~ "obese",
  TRUE ~ "E"
  ))
library(brms)
library(knitr)
```

## 項目応答モデル

### データの概観

[@Boeck-Wilson2004] による「怒るかどうか？」のデータを用いる．混合モデルの点推定のためのパッケージ `lme4` [@Bates+2015] で利用可能になっている．

```{r}
#| output: false
library(lme4)
data("VerbAgg", package = "lme4")
df <- VerbAgg
```

応答は３段階の順序応答 `resp` とこれを２段階にしたもの `r2` である．

```{r}
kable(head(df))
```

### 固定効果１母数モデル

通常の１母数モデルに，過分散を説明するための固定効果の項 $\al_0$ を加えたモデルを考える：

$$
g(\P[Y_{ik}=1])=\al_{j[i]}-\beta_{k[i]}+\al_0,\qquad\al_0\sim\rt(3;0,2.5),
$$
$$
\al_j\sim\rN(\mu_\al,\sigma_\al^2),\quad\mu_\al\sim\rN(0,3),\quad\sigma_\al\sim\rN(0,3),
$$
$$
\beta_k\sim\rN(\mu_\beta,\sigma_\beta^2),\quad\mu_\beta\sim\rN(0,3),\quad\sigma_\beta\sim\rN(0,3).
$$

`sd` というクラスはグループレベル変数の標準偏差を意味する．

$\al_j,\beta_k$ の定数の違いに関する識別不可能性は，いずれも $0$ を中心とした

```{r}
#| output: false
formula_1PL <- bf(r2 ~ 1 + (1|item) + (1|id))
prior_1PL <-  prior("normal(0,3)", class="sd", group = "id") +
  prior("normal(0,3)", class="sd", group = "item")
fit_1PL <- brm(
  formula_1PL,
  data = df,
  family = brmsfamily("bernoulli", link = "logit"),
  prior = prior_1PL,
  chains = 4, cores = 4
)
```

```{r}
prior_summary(fit_1PL)
```

`vectorized` というのは，下記 Stan コード内で尤度は for 文で構成されるが，このループに入れなくて良いものがある場合をいう．

::: {.callout-tip collapse="true" title="Stan コードの表示"}

```r
stancode(fit_1PL)
```

によって推定に用いられた Stan コードが表示できる．

次を見る限り，確かに意図したモデルになっている：

```stan
// generated with brms 2.21.0
functions {
}
data {
  int<lower=1> N;  // total number of observations
  array[N] int Y;  // response variable
  // data for group-level effects of ID 1
  int<lower=1> N_1;  // number of grouping levels
  int<lower=1> M_1;  // number of coefficients per level
  array[N] int<lower=1> J_1;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_1_1;
  // data for group-level effects of ID 2
  int<lower=1> N_2;  // number of grouping levels
  int<lower=1> M_2;  // number of coefficients per level
  array[N] int<lower=1> J_2;  // grouping indicator per observation
  // group-level predictor values
  vector[N] Z_2_1;
  int prior_only;  // should the likelihood be ignored?
}
transformed data {
}
parameters {
  real Intercept;  // temporary intercept for centered predictors
  vector<lower=0>[M_1] sd_1;  // group-level standard deviations
  array[M_1] vector[N_1] z_1;  // standardized group-level effects
  vector<lower=0>[M_2] sd_2;  // group-level standard deviations
  array[M_2] vector[N_2] z_2;  // standardized group-level effects
}
transformed parameters {
  vector[N_1] r_1_1;  // actual group-level effects
  vector[N_2] r_2_1;  // actual group-level effects
  real lprior = 0;  // prior contributions to the log posterior
  r_1_1 = (sd_1[1] * (z_1[1]));
  r_2_1 = (sd_2[1] * (z_2[1]));
  lprior += student_t_lpdf(Intercept | 3, 0, 2.5);
  lprior += normal_lpdf(sd_1 | 0,3)
    - 1 * normal_lccdf(0 | 0,3);
  lprior += normal_lpdf(sd_2 | 0,3)
    - 1 * normal_lccdf(0 | 0,3);
}
model {
  // likelihood including constants
  if (!prior_only) {
    // initialize linear predictor term
    vector[N] mu = rep_vector(0.0, N);
    mu += Intercept;
    for (n in 1:N) {
      // add more terms to the linear predictor
      mu[n] += r_1_1[J_1[n]] * Z_1_1[n] + r_2_1[J_2[n]] * Z_2_1[n];
    }
    target += bernoulli_logit_lpmf(Y | mu);
  }
  // priors including constants
  target += lprior;
  target += std_normal_lpdf(z_1[1]);
  target += std_normal_lpdf(z_2[1]);
}
generated quantities {
  // actual population-level intercept
  real b_Intercept = Intercept;
}
```

`-1*normal_lccdf(0|0,3)` というのは定数であり，推定には全く影響を与えないが，後続の `bridgesampling` パッケージ [@Gronau-Singmann-Wagenmakers2020] によるモデル比較の API 構築のために付けられたものである [@Burkner2021 p.21]．

:::

<!-- 
```{r}
sum <- summary(fit_1PL)
row1 <- data.frame(sum$fix)
row2 <- data.frame(sum$random[1]) %>%
  setNames(colnames(row1))
row3 <- data.frame(sum$random[2]) %>%
  setNames(colnames(row1))
kable(rbind(row1, row2, row3))
```
-->

```{r}
summary(fit_1PL)
```

低い ESS から変動効果の項 $\ep_i$ の推定に苦労していることがわかる．

```{r}
plot(fit_1PL)
```

ここにはグローバルなパラメータしか表示されておらず，ランダム効果の結果は次のように見る必要がある：

```{r}
#| output: false
library(ggplot2)
ranef_item <- ranef(fit_1PL)$item
posterior_means <- ranef_item[,1,1]
lower_bounds <- ranef_item[,3,1]
upper_bounds <- ranef_item[,4,1]
plot_df_item <- data.frame(
  item = rownames(ranef_item),
  mean = posterior_means,
  lower = lower_bounds,
  upper = upper_bounds
)
```

```{r}
ggplot(plot_df_item, aes(x = mean, y = item)) +
  geom_point() +
  geom_errorbar(aes(xmin = lower, xmax = upper), width = 0.2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title = "Posterior Means and 95% Credible Intervals for Items",
       x = "Posterior Estimate",
       y = "Item")
```

多くの参加者にとって腹立たしい例とそうでない例が区別できているようである．

```{r}
#| output: false
#| echo: false
ranef_id <- ranef(fit_1PL)$id
posterior_means <- ranef_id[,1,1]
lower_bounds <- ranef_id[,3,1]
upper_bounds <- ranef_id[,4,1]
plot_df_id <- data.frame(
  id = rownames(ranef_id),
  mean = posterior_means,
  lower = lower_bounds,
  upper = upper_bounds
)
```

```{r}
plot_df_id <- plot_df_id %>% arrange(mean) %>% mutate(rank = row_number())
ggplot(plot_df_id, aes(x = mean, y = rank)) +
  geom_point() +
  geom_errorbar(aes(xmin = lower, xmax = upper), width = 0.2) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
  labs(title = "Posterior Means and 95% Credible Intervals for Individuals",
       x = "Posterior Estimate",
       y = "Individual")
```

こうして怒りやすかった人を並べることができる．

しかしガタガタしている区分定数的な模様が見れる．実はこれは item の分だけある．というのも，「何個の項目に Yes と答えたか」だけが $\al_j$ を決める要因になってしまっているためである．

これが項目識別のできない１母数モデルの限界である．

### 固定効果２母数モデル

項目識別力母数 $\gamma_k$ を導入する：
$$
g(\mu_i)=\gamma_{k[i]}\Paren{\al_{j[i]}-\beta_{k[i]}},
$$


```{r}
#| eval: false
formula_2PL <- bf(r2 ~ 1 + (1|item) + (1|id))
prior_2PL <-  prior("normal(0,3)", class="sd", group = "id") +
  prior("normal(0,3)", class="sd", group = "item")
fit_2PL <- brm(
  formula_2PL,
  data = df,
  family = brmsfamily("bernoulli", link = "logit"),
  prior = prior_2PL,
  chains = 4, cores = 4
)
```

### 共変量の追加

理想点モデルなど多くの項目応答モデルは，$\al_j,\beta_k$ の推定に終始してきたが，本当のリサーチクエスチョンはその先にある．

個人レベルの共変量を追加した階層モデルを構築して，$\al_j$ の位置や応答の傾向への影響を調べることが真の目標であった．

## 文献案内 {.appendix}

[@Burkner2021] に項目応答モデルのベイズ的な扱いが取り上げられている．特にパッケージ `brms` を用いた例が３つある．
