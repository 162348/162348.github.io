{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"大規模な不均衡データに対するロジスティック回帰（後編）\"\n",
        "subtitle: \"離散時間 MCMC から連続時間 MCMC へ\"\n",
        "author: \"司馬博文\"\n",
        "date: 7/18/2024\n",
        "date-modified: 10/7/2024\n",
        "image: Logistic2.svg\n",
        "categories: [Bayesian, Computation, Julia, MCMC]\n",
        "bibliography: \n",
        "    - ../../../assets/2023.bib\n",
        "    - ../../../assets/2024.bib\n",
        "    - ../../../assets/2025.bib\n",
        "csl: ../../../assets/apalike.csl\n",
        "abstract-title: 概要\n",
        "abstract: ロジットモデルやプロビットモデルの事後分布からのサンプリングには，その混合構造を利用したデータ拡張による Gibbs サンプラーが考案されている．しかし，このような Gibbs サンプラーは不明な理由で極めて収束が遅くなることがよく見られ，そのうちの１つのパターンが **大規模な不均衡データ** である．前編ではこの現象がなぜ起こるかに関して考察した．ここでは代替手法として Zig-Zag サンプラーがうまくいくことをみる．\n",
        "code-fold: false\n",
        "execute:\n",
        "    cache: true\n",
        "listing: \n",
        "    -   id: lst-listing\n",
        "        type: grid\n",
        "        grid-columns: 1\n",
        "        grid-item-align: center\n",
        "        sort: false\n",
        "        contents:\n",
        "            - \"Logistic.qmd\"\n",
        "        date-format: iso\n",
        "        fields: [title,image,subtitle]\n",
        "    -   id: lst-zigzag\n",
        "        type: grid\n",
        "        sort: false\n",
        "        contents:\n",
        "            - \"../Process/ZigZag.qmd\"\n",
        "            - \"../Process/PureJump.qmd\"\n",
        "            - \"../Stat/ZigZagSubsampling.qmd\"\n",
        "        date-format: iso\n",
        "        fields: [title,image,date,subtitle]\n",
        "---\n",
        "\n",
        "::: {.hidden}\n",
        "\n",
        "::: {.content-visible when-format=\"html\"}\n",
        "\n",
        "A Blog Entry on Bayesian Computation by an Applied Mathematician\n",
        "\n",
        "$$\n",
        "\n",
        "\\renewcommand{\\P}{\\operatorname{P}}\\newcommand{\\E}{\\operatorname{E}}\n",
        "\\newcommand{\\R}{\\mathbb{R}}\\newcommand{\\bR}{\\mathbb{R}}\\newcommand{\\F}{\\mathcal{F}}\n",
        "\\newcommand{\\abs}[1]{\\lvert#1\\rvert}\\newcommand{\\Abs}[1]{\\left|#1\\right|}\\newcommand{\\ABs}[1]{\\biggl|#1\\biggr|}\\newcommand{\\norm}[1]{\\|#1\\|}\\newcommand{\\Norm}[1]{\\left\\|#1\\right\\|}\\newcommand{\\NOrm}[1]{\\biggl\\|#1\\biggr\\|}\\newcommand{\\Brace}[1]{\\left\\{#1\\right\\}}\\newcommand{\\BRace}[1]{\\biggl\\{#1\\biggr\\}}\\newcommand{\\paren}[1]{\\left(#1\\right)}\\newcommand{\\Paren}[1]{\\biggr(#1\\biggl)}\\newcommand{\\brac}[1]{\\langle#1\\rangle}\\newcommand{\\Brac}[1]{\\left\\langle#1\\right\\rangle}\\newcommand{\\BRac}[1]{\\biggl\\langle#1\\biggr\\rangle}\\newcommand{\\bra}[1]{\\left\\langle#1\\right|}\\newcommand{\\ket}[1]{\\left|#1\\right\\rangle}\\newcommand{\\Square}[1]{\\left[#1\\right]}\\newcommand{\\SQuare}[1]{\\biggl[#1\\biggr]}\\newcommand{\\rN}{\\operatorname{N}}\\newcommand{\\ov}[1]{\\overline{#1}}\\newcommand{\\un}[1]{\\underline{#1}}\\newcommand{\\wt}[1]{\\widetilde{#1}}\\newcommand{\\wh}[1]{\\widehat{#1}}\\newcommand{\\pp}[2]{\\frac{\\partial #1}{\\partial #2}}\\newcommand{\\ppp}[3]{\\frac{\\partial #1}{\\partial #2\\partial #3}}\\newcommand{\\dd}[2]{\\frac{d #1}{d #2}}\\newcommand{\\floor}[1]{\\lfloor#1\\rfloor}\\newcommand{\\Floor}[1]{\\left\\lfloor#1\\right\\rfloor}\\newcommand{\\ceil}[1]{\\lceil#1\\rceil}\\newcommand{\\ocinterval}[1]{(#1]}\\newcommand{\\cointerval}[1]{[#1)}\\newcommand{\\COinterval}[1]{\\left[#1\\right)}\\newcommand{\\iso}{\\overset{\\sim}{\\to}}\n",
        "\n",
        "\n",
        "\n",
        "\\newcommand{\\y}{\\b{y}}\\newcommand{\\mi}{\\,|\\,}\\newcommand{\\Mark}{\\mathrm{Mark}}\n",
        "\\newcommand{\\argmax}{\\operatorname*{argmax}}\\newcommand{\\argmin}{\\operatorname*{argmin}}\n",
        "\n",
        "\\newcommand{\\pr}{\\mathrm{pr}}\\newcommand{\\Conv}{\\operatorname{Conv}}\\newcommand{\\cU}{\\mathcal{U}}\n",
        "\\newcommand{\\Map}{\\mathrm{Map}}\\newcommand{\\dom}{\\mathrm{Dom}\\;}\\newcommand{\\cod}{\\mathrm{Cod}\\;}\\newcommand{\\supp}{\\mathrm{supp}\\;}\n",
        "\\newcommand{\\grad}{\\operatorname{grad}}\\newcommand{\\rot}{\\operatorname{rot}}\\renewcommand{\\div}{\\operatorname{div}}\\newcommand{\\tr}{\\operatorname{tr}}\\newcommand{\\Tr}{\\operatorname{Tr}}\\newcommand{\\KL}{\\operatorname{KL}}\\newcommand{\\JS}{\\operatorname{JS}}\\newcommand{\\ESS}{\\operatorname{ESS}}\\newcommand{\\MSE}{\\operatorname{MSE}}\\newcommand{\\erf}{\\operatorname{erf}}\\newcommand{\\arctanh}{\\operatorname{arctanh}}\\newcommand{\\pl}{\\operatorname{pl}}\\newcommand{\\minimize}{\\operatorname{minimize}}\\newcommand{\\subjectto}{\\operatorname{subject to}}\\newcommand{\\sinc}{\\operatorname{sinc}}\\newcommand{\\Ent}{\\operatorname{Ent}}\\newcommand{\\Polya}{\\operatorname{Polya}}\\newcommand{\\Exp}{\\operatorname{Exp}}\\newcommand{\\codim}{\\operatorname{codim}}\\newcommand{\\sgn}{\\operatorname{sgn}}\\newcommand{\\rank}{\\operatorname{rank}}\n",
        "\n",
        "\\newcommand{\\vctr}[2]{\\begin{pmatrix}#1\\\\#2\\end{pmatrix}}\\newcommand{\\vctrr}[3]{\\begin{pmatrix}#1\\\\#2\\\\#3\\end{pmatrix}}\\newcommand{\\mtrx}[4]{\\begin{pmatrix}#1&#2\\\\#3&#4\\end{pmatrix}}\\newcommand{\\smtrx}[4]{\\paren{\\begin{smallmatrix}#1&#2\\\\#3&#4\\end{smallmatrix}}}\\newcommand{\\Ker}{\\mathrm{Ker}\\;}\\newcommand{\\Coker}{\\mathrm{Coker}\\;}\\newcommand{\\Coim}{\\mathrm{Coim}\\;}\\newcommand{\\lcm}{\\mathrm{lcm}}\\newcommand{\\GL}{\\mathrm{GL}}\\newcommand{\\SL}{\\mathrm{SL}}\\newcommand{\\alt}{\\mathrm{alt}}\n",
        "\n",
        "\\renewcommand{\\Re}{\\mathrm{Re}\\;}\\renewcommand{\\Im}{\\mathrm{Im}\\,}\\newcommand{\\Gal}{\\mathrm{Gal}}\\newcommand{\\PGL}{\\mathrm{PGL}}\\newcommand{\\PSL}{\\mathrm{PSL}}\\newcommand{\\Log}{\\mathrm{Log}\\,}\\newcommand{\\Res}{\\mathrm{Res}\\,}\\newcommand{\\on}{\\mathrm{on}\\;}\\newcommand{\\hatC}{\\widehat{\\C}}\\newcommand{\\hatR}{\\hat{\\R}}\\newcommand{\\PV}{\\mathrm{P.V.}}\\newcommand{\\diam}{\\mathrm{diam}}\\newcommand{\\Area}{\\mathrm{Area}}\\newcommand{\\Lap}{\\Laplace}\\newcommand{\\f}{\\mathbf{f}}\\newcommand{\\cR}{\\mathcal{R}}\\newcommand{\\const}{\\mathrm{const.}}\\newcommand{\\Om}{\\Omega}\\newcommand{\\Cinf}{C^\\infty}\\newcommand{\\ep}{\\epsilon}\\newcommand{\\dist}{\\mathrm{dist}}\\newcommand{\\opart}{\\o{\\partial}}\\newcommand{\\Length}{\\mathrm{Length}}\n",
        "\n",
        "\\newcommand{\\cA}{\\mathcal{A}}\\newcommand{\\cO}{\\mathcal{O}}\\newcommand{\\cW}{\\mathcal{W}}\\renewcommand{\\O}{\\mathcal{O}}\\renewcommand{\\S}{\\mathcal{S}}\\newcommand{\\U}{\\mathcal{U}}\\newcommand{\\V}{\\mathrm{V}}\\newcommand{\\N}{\\mathbb{N}}\\newcommand{\\bN}{\\mathbb{N}}\\newcommand{\\C}{\\mathrm{C}}\\newcommand{\\bC}{\\mathbb{C}}\\newcommand{\\Z}{\\mathcal{Z}}\\newcommand{\\Q}{\\mathbb{Q}}\\newcommand{\\bQ}{\\mathbb{Q}}\\newcommand{\\TV}{\\mathrm{TV}}\\newcommand{\\ORD}{\\mathrm{ORD}}\\newcommand{\\Card}{\\mathrm{Card}\\,}\\newcommand{\\Top}{\\mathrm{Top}}\\newcommand{\\Disc}{\\mathrm{Disc}}\\newcommand{\\Codisc}{\\mathrm{Codisc}}\\newcommand{\\CoDisc}{\\mathrm{CoDisc}}\\newcommand{\\Ult}{\\mathrm{Ult}}\\newcommand{\\ord}{\\mathrm{ord}}\\newcommand{\\bS}{\\mathbb{S}}\\newcommand{\\PConn}{\\mathrm{PConn}}\\newcommand{\\mult}{\\mathrm{mult}}\\newcommand{\\inv}{\\mathrm{inv}}\n",
        "\n",
        "\\newcommand{\\Der}{\\mathrm{Der}}\\newcommand{\\osub}{\\overset{\\mathrm{open}}{\\subset}}\\newcommand{\\osup}{\\overset{\\mathrm{open}}{\\supset}}\\newcommand{\\al}{\\alpha}\\newcommand{\\K}{\\mathbb{K}}\\newcommand{\\Sp}{\\mathrm{Sp}}\\newcommand{\\g}{\\mathfrak{g}}\\newcommand{\\h}{\\mathfrak{h}}\\newcommand{\\Imm}{\\mathrm{Imm}}\\newcommand{\\Imb}{\\mathrm{Imb}}\\newcommand{\\Gr}{\\mathrm{Gr}}\n",
        "\n",
        "\\newcommand{\\Ad}{\\mathrm{Ad}}\\newcommand{\\finsupp}{\\mathrm{fin\\;supp}}\\newcommand{\\SO}{\\mathrm{SO}}\\newcommand{\\SU}{\\mathrm{SU}}\\newcommand{\\acts}{\\curvearrowright}\\newcommand{\\mono}{\\hookrightarrow}\\newcommand{\\epi}{\\twoheadrightarrow}\\newcommand{\\Stab}{\\mathrm{Stab}}\\newcommand{\\nor}{\\mathrm{nor}}\\newcommand{\\T}{\\mathbb{T}}\\newcommand{\\Aff}{\\mathrm{Aff}}\\newcommand{\\rsup}{\\triangleright}\\newcommand{\\subgrp}{\\overset{\\mathrm{subgrp}}{\\subset}}\\newcommand{\\Ext}{\\mathrm{Ext}}\\newcommand{\\sbs}{\\subset}\\newcommand{\\sps}{\\supset}\\newcommand{\\In}{\\mathrm{in}\\;}\\newcommand{\\Tor}{\\mathrm{Tor}}\\newcommand{\\p}{\\b{p}}\\newcommand{\\q}{\\mathfrak{q}}\\newcommand{\\m}{\\mathfrak{m}}\\newcommand{\\cS}{\\mathcal{S}}\\newcommand{\\Frac}{\\mathrm{Frac}\\,}\\newcommand{\\Spec}{\\mathrm{Spec}\\,}\\newcommand{\\bA}{\\mathbb{A}}\\newcommand{\\Sym}{\\mathrm{Sym}}\\newcommand{\\Ann}{\\mathrm{Ann}}\\newcommand{\\Her}{\\mathrm{Her}}\\newcommand{\\Bil}{\\mathrm{Bil}}\\newcommand{\\Ses}{\\mathrm{Ses}}\\newcommand{\\FVS}{\\mathrm{FVS}}\n",
        "\n",
        "\\newcommand{\\Ho}{\\mathrm{Ho}}\\newcommand{\\CW}{\\mathrm{CW}}\\newcommand{\\lc}{\\mathrm{lc}}\\newcommand{\\cg}{\\mathrm{cg}}\\newcommand{\\Fib}{\\mathrm{Fib}}\\newcommand{\\Cyl}{\\mathrm{Cyl}}\\newcommand{\\Ch}{\\mathrm{Ch}}\n",
        "\\newcommand{\\rP}{\\mathrm{P}}\\newcommand{\\rE}{\\mathrm{E}}\\newcommand{\\e}{\\b{e}}\\renewcommand{\\k}{\\b{k}}\\newcommand{\\Christ}[2]{\\begin{Bmatrix}#1\\\\#2\\end{Bmatrix}}\\renewcommand{\\Vec}[1]{\\overrightarrow{\\mathrm{#1}}}\\newcommand{\\hen}[1]{\\mathrm{#1}}\\renewcommand{\\b}[1]{\\boldsymbol{#1}}\n",
        "\n",
        "\\newcommand{\\Inc}{\\mathrm{Inc}}\\newcommand{\\aInc}{\\mathrm{aInc}}\\newcommand{\\HS}{\\mathrm{HS}}\\newcommand{\\loc}{\\mathrm{loc}}\\newcommand{\\Lh}{\\mathrm{L.h.}}\\newcommand{\\Epi}{\\mathrm{Epi}}\\newcommand{\\slim}{\\mathrm{slim}}\\newcommand{\\Ban}{\\mathrm{Ban}}\\newcommand{\\Hilb}{\\mathrm{Hilb}}\\newcommand{\\Ex}{\\mathrm{Ex}}\\newcommand{\\Co}{\\mathrm{Co}}\\newcommand{\\sa}{\\mathrm{sa}}\\newcommand{\\nnorm}[1]{{\\left\\vert\\kern-0.25ex\\left\\vert\\kern-0.25ex\\left\\vert #1 \\right\\vert\\kern-0.25ex\\right\\vert\\kern-0.25ex\\right\\vert}}\\newcommand{\\dvol}{\\mathrm{dvol}}\\newcommand{\\Sconv}{\\mathrm{Sconv}}\\newcommand{\\I}{\\mathcal{I}}\\newcommand{\\nonunital}{\\mathrm{nu}}\\newcommand{\\cpt}{\\mathrm{cpt}}\\newcommand{\\lcpt}{\\mathrm{lcpt}}\\newcommand{\\com}{\\mathrm{com}}\\newcommand{\\Haus}{\\mathrm{Haus}}\\newcommand{\\proper}{\\mathrm{proper}}\\newcommand{\\infinity}{\\mathrm{inf}}\\newcommand{\\TVS}{\\mathrm{TVS}}\\newcommand{\\ess}{\\mathrm{ess}}\\newcommand{\\ext}{\\mathrm{ext}}\\newcommand{\\Index}{\\mathrm{Index}\\;}\\newcommand{\\SSR}{\\mathrm{SSR}}\\newcommand{\\vs}{\\mathrm{vs.}}\\newcommand{\\fM}{\\mathfrak{M}}\\newcommand{\\EDM}{\\mathrm{EDM}}\\newcommand{\\Tw}{\\mathrm{Tw}}\\newcommand{\\fC}{\\mathfrak{C}}\\newcommand{\\bn}{\\boldsymbol{n}}\\newcommand{\\br}{\\boldsymbol{r}}\\newcommand{\\Lam}{\\Lambda}\\newcommand{\\lam}{\\lambda}\\newcommand{\\one}{\\mathbf{1}}\\newcommand{\\dae}{\\text{-a.e.}}\\newcommand{\\das}{\\text{-a.s.}}\\newcommand{\\td}{\\text{-}}\\newcommand{\\RM}{\\mathrm{RM}}\\newcommand{\\BV}{\\mathrm{BV}}\\newcommand{\\normal}{\\mathrm{normal}}\\newcommand{\\lub}{\\mathrm{lub}\\;}\\newcommand{\\Graph}{\\mathrm{Graph}}\\newcommand{\\Ascent}{\\mathrm{Ascent}}\\newcommand{\\Descent}{\\mathrm{Descent}}\\newcommand{\\BIL}{\\mathrm{BIL}}\\newcommand{\\fL}{\\mathfrak{L}}\\newcommand{\\De}{\\Delta}\n",
        "\n",
        "\\newcommand{\\calA}{\\mathcal{A}}\\newcommand{\\calB}{\\mathcal{B}}\\newcommand{\\D}{\\mathcal{D}}\\newcommand{\\Y}{\\mathcal{Y}}\\newcommand{\\calC}{\\mathcal{C}}\\renewcommand{\\ae}{\\mathrm{a.e.}\\;}\\newcommand{\\cZ}{\\mathcal{Z}}\\newcommand{\\fF}{\\mathfrak{F}}\\newcommand{\\fI}{\\mathfrak{I}}\\newcommand{\\rV}{\\mathrm{V}}\\newcommand{\\cE}{\\mathcal{E}}\\newcommand{\\sMap}{\\sigma\\textrm{-}\\mathrm{Map}}\\newcommand{\\cC}{\\mathcal{C}}\\newcommand{\\comp}{\\complement}\\newcommand{\\J}{\\mathcal{J}}\\newcommand{\\sumN}[1]{\\sum_{#1\\in\\N}}\\newcommand{\\cupN}[1]{\\cup_{#1\\in\\N}}\\newcommand{\\capN}[1]{\\cap_{#1\\in\\N}}\\newcommand{\\Sum}[1]{\\sum_{#1=1}^\\infty}\\newcommand{\\sumn}{\\sum_{n=1}^\\infty}\\newcommand{\\summ}{\\sum_{m=1}^\\infty}\\newcommand{\\sumk}{\\sum_{k=1}^\\infty}\\newcommand{\\sumi}{\\sum_{i=1}^\\infty}\\newcommand{\\sumj}{\\sum_{j=1}^\\infty}\\newcommand{\\cupn}{\\cup_{n=1}^\\infty}\\newcommand{\\capn}{\\cap_{n=1}^\\infty}\\newcommand{\\cupk}{\\cup_{k=1}^\\infty}\\newcommand{\\cupi}{\\cup_{i=1}^\\infty}\\newcommand{\\cupj}{\\cup_{j=1}^\\infty}\\newcommand{\\limn}{\\lim_{n\\to\\infty}}\\renewcommand{\\L}{\\mathcal{L}}\\newcommand{\\cL}{\\mathcal{L}}\\newcommand{\\Cl}{\\mathrm{Cl}}\\newcommand{\\cN}{\\mathcal{N}}\\newcommand{\\Ae}{\\textrm{-a.e.}\\;}\\renewcommand{\\csub}{\\overset{\\textrm{closed}}{\\subset}}\\renewcommand{\\csup}{\\overset{\\textrm{closed}}{\\supset}}\\newcommand{\\wB}{\\wt{B}}\\newcommand{\\cG}{\\mathcal{G}}\\newcommand{\\Lip}{\\mathrm{Lip}}\\newcommand{\\AC}{\\mathrm{AC}}\\newcommand{\\Mol}{\\mathrm{Mol}}\n",
        "\n",
        "\\newcommand{\\Pe}{\\mathrm{Pe}}\\newcommand{\\wR}{\\wh{\\mathbb{\\R}}}\\newcommand*{\\Laplace}{\\mathop{}\\!\\mathbin\\bigtriangleup}\\newcommand*{\\DAlambert}{\\mathop{}\\!\\mathbin\\Box}\\newcommand{\\bT}{\\mathbb{T}}\\newcommand{\\dx}{\\dslash x}\\newcommand{\\dt}{\\dslash t}\\newcommand{\\ds}{\\dslash s}\n",
        "\n",
        "\\newcommand{\\round}{\\mathrm{round}}\\newcommand{\\cond}{\\mathrm{cond}}\\newcommand{\\diag}{\\mathrm{diag}}\n",
        "\\newcommand{\\Adj}{\\mathrm{Adj}}\\newcommand{\\Pf}{\\mathrm{Pf}}\\newcommand{\\Sg}{\\mathrm{Sg}}\n",
        "\n",
        "\n",
        "\\newcommand{\\aseq}{\\overset{\\text{a.s.}}{=}}\\newcommand{\\deq}{\\overset{\\text{d}}{=}}\\newcommand{\\cV}{\\mathcal{V}}\\newcommand{\\FM}{\\mathrm{FM}}\\newcommand{\\KR}{\\mathrm{KR}}\\newcommand{\\rba}{\\mathrm{rba}}\\newcommand{\\rca}{\\mathrm{rca}}\\newcommand{\\Prob}{\\mathrm{Prob}}\\newcommand{\\X}{\\mathcal{X}}\\newcommand{\\Meas}{\\mathrm{Meas}}\\newcommand{\\as}{\\;\\text{a.s.}}\\newcommand{\\io}{\\;\\mathrm{i.o.}}\\newcommand{\\fe}{\\;\\text{f.e.}}\\newcommand{\\bF}{\\mathbb{F}}\\newcommand{\\W}{\\mathcal{W}}\\newcommand{\\Pois}{\\mathrm{Pois}}\\newcommand{\\iid}{\\text{i.i.d.}}\\newcommand{\\wconv}{\\rightsquigarrow}\\newcommand{\\Var}{\\mathrm{Var}}\\newcommand{\\xrightarrown}{\\xrightarrow{n\\to\\infty}}\\newcommand{\\au}{\\mathrm{au}}\\newcommand{\\cT}{\\mathcal{T}}\\newcommand{\\wto}{\\overset{\\text{w}}{\\to}}\\newcommand{\\dto}{\\overset{\\text{d}}{\\to}}\\newcommand{\\sto}{\\overset{\\text{s}}{\\to}}\\newcommand{\\pto}{\\overset{\\text{p}}{\\to}}\\newcommand{\\mto}{\\overset{\\text{m}}{\\to}}\\newcommand{\\vto}{\\overset{v}{\\to}}\\newcommand{\\Cont}{\\mathrm{Cont}}\\newcommand{\\stably}{\\mathrm{stably}}\\newcommand{\\Np}{\\mathbb{N}^+}\\newcommand{\\oM}{\\overline{\\mathcal{M}}}\\newcommand{\\fP}{\\mathfrak{P}}\\newcommand{\\sign}{\\mathrm{sign}}\n",
        "\\newcommand{\\Borel}{\\mathrm{Borel}}\\newcommand{\\Mid}{\\,|\\,}\\newcommand{\\middleMid}{\\;\\middle|\\;}\\newcommand{\\CP}{\\mathrm{CP}}\\newcommand{\\bD}{\\mathbb{D}}\\newcommand{\\bL}{\\mathbb{L}}\\newcommand{\\fW}{\\mathfrak{W}}\\newcommand{\\DL}{\\mathcal{D}\\mathcal{L}}\\renewcommand{\\r}[1]{\\mathrm{#1}}\\newcommand{\\rC}{\\mathrm{C}}\\newcommand{\\qqquad}{\\qquad\\quad}\n",
        "\n",
        "\\newcommand{\\bit}{\\mathrm{bit}}\n",
        "\n",
        "\\newcommand{\\err}{\\mathrm{err}}\n",
        "\n",
        "\\newcommand{\\varparallel}{\\mathbin{\\!/\\mkern-5mu/\\!}}\\newcommand{\\Ri}{\\mathrm{Ri}}\\newcommand{\\Cone}{\\mathrm{Cone}}\\newcommand{\\Int}{\\mathrm{Int}}\n",
        "\n",
        "\\newcommand{\\pre}{\\mathrm{pre}}\\newcommand{\\om}{\\omega}\n",
        "\n",
        "\n",
        "\\newcommand{\\del}{\\partial}\n",
        "\\newcommand{\\LHS}{\\mathrm{LHS}}\\newcommand{\\RHS}{\\mathrm{RHS}}\\newcommand{\\bnu}{\\boldsymbol{\\nu}}\\newcommand{\\interior}{\\mathrm{in}\\;}\\newcommand{\\SH}{\\mathrm{SH}}\\renewcommand{\\v}{\\boldsymbol{\\nu}}\\newcommand{\\n}{\\mathbf{n}}\\newcommand{\\ssub}{\\Subset}\\newcommand{\\curl}{\\mathrm{curl}}\n",
        "\n",
        "\\newcommand{\\Ei}{\\mathrm{Ei}}\\newcommand{\\sn}{\\mathrm{sn}}\\newcommand{\\wgamma}{\\widetilde{\\gamma}}\n",
        "\n",
        "\\newcommand{\\Ens}{\\mathrm{Ens}}\n",
        "\n",
        "\\newcommand{\\cl}{\\mathrm{cl}}\\newcommand{\\x}{\\boldsymbol{x}}\n",
        "\n",
        "\\newcommand{\\Do}{\\mathrm{Do}}\\newcommand{\\IV}{\\mathrm{IV}}\n",
        "\n",
        "\\newcommand{\\AIC}{\\mathrm{AIC}}\\newcommand{\\mrl}{\\mathrm{mrl}}\\newcommand{\\dotx}{\\dot{x}}\\newcommand{\\UMV}{\\mathrm{UMV}}\\newcommand{\\BLU}{\\mathrm{BLU}}\n",
        "\n",
        "\\newcommand{\\comb}[2]{\\begin{pmatrix}#1\\\\#2\\end{pmatrix}}\\newcommand{\\bP}{\\mathbb{P}}\\newcommand{\\compsub}{\\overset{\\textrm{cpt}}{\\subset}}\\newcommand{\\lip}{\\textrm{lip}}\\newcommand{\\BL}{\\mathrm{BL}}\\newcommand{\\G}{\\mathbb{G}}\\newcommand{\\NB}{\\mathrm{NB}}\\newcommand{\\oR}{\\ov{\\R}}\\newcommand{\\liminfn}{\\liminf_{n\\to\\infty}}\\newcommand{\\limsupn}{\\limsup_{n\\to\\infty}}\\newcommand{\\esssup}{\\mathrm{ess.sup}}\\newcommand{\\asto}{\\xrightarrow{\\as}}\\newcommand{\\Cov}{\\mathrm{Cov}}\\newcommand{\\cQ}{\\mathcal{Q}}\\newcommand{\\VC}{\\mathrm{VC}}\\newcommand{\\mb}{\\mathrm{mb}}\\newcommand{\\Avar}{\\mathrm{Avar}}\\newcommand{\\bB}{\\mathbb{B}}\\newcommand{\\bW}{\\mathbb{W}}\\newcommand{\\sd}{\\mathrm{sd}}\\newcommand{\\w}[1]{\\widehat{#1}}\\newcommand{\\bZ}{\\mathbb{Z}}\\newcommand{\\Bernoulli}{\\mathrm{Ber}}\\newcommand{\\Ber}{\\mathrm{Ber}}\\newcommand{\\Mult}{\\mathrm{Mult}}\\newcommand{\\BPois}{\\mathrm{BPois}}\\newcommand{\\fraks}{\\mathfrak{s}}\\newcommand{\\frakk}{\\mathfrak{k}}\\newcommand{\\IF}{\\mathrm{IF}}\\newcommand{\\bX}{\\boldsymbol{X}}\\newcommand{\\bx}{\\boldsymbol{x}}\\newcommand{\\indep}{\\perp\\!\\!\\!\\perp}\\newcommand{\\IG}{\\mathrm{IG}}\\newcommand{\\Levy}{\\mathrm{Levy}}\\newcommand{\\MP}{\\mathrm{MP}}\\newcommand{\\Hermite}{\\mathrm{Hermite}}\\newcommand{\\Skellam}{\\mathrm{Skellam}}\\newcommand{\\Dirichlet}{\\mathrm{Dirichlet}}\\renewcommand{\\Beta}{\\operatorname{Beta}}\\newcommand{\\bE}{\\mathbb{E}}\\newcommand{\\bG}{\\mathbb{G}}\\newcommand{\\MISE}{\\mathrm{MISE}}\\newcommand{\\logit}{\\operatorname{logit}}\\newcommand{\\expit}{\\mathtt{expit}}\\newcommand{\\cK}{\\mathcal{K}}\\newcommand{\\dl}{\\dot{l}}\\newcommand{\\dotp}{\\dot{p}}\\newcommand{\\wl}{\\wt{l}}\\newcommand{\\Gauss}{\\mathrm{Gauss}}\\newcommand{\\fA}{\\mathfrak{A}}\\newcommand{\\under}{\\mathrm{under}\\;}\\newcommand{\\whtheta}{\\wh{\\theta}}\\newcommand{\\Em}{\\mathrm{Em}}\\newcommand{\\ztheta}{{\\theta_0}}\n",
        "\\newcommand{\\rO}{\\mathrm{O}}\\newcommand{\\Bin}{\\mathrm{Bin}}\\newcommand{\\rW}{\\mathrm{W}}\\newcommand{\\rG}{\\mathrm{G}}\\newcommand{\\rB}{\\mathrm{B}}\\newcommand{\\rU}{\\mathrm{U}}\\newcommand{\\HG}{\\mathrm{HG}}\\newcommand{\\GAMMA}{\\mathrm{Gamma}}\\newcommand{\\Cauchy}{\\mathrm{Cauchy}}\\newcommand{\\rt}{\\mathrm{t}}\\newcommand{\\rF}{\\mathrm{F}}\n",
        "\\newcommand{\\FE}{\\mathrm{FE}}\\newcommand{\\bV}{\\boldsymbol{V}}\\newcommand{\\GLS}{\\mathrm{GLS}}\\newcommand{\\be}{\\boldsymbol{e}}\\newcommand{\\POOL}{\\mathrm{POOL}}\\newcommand{\\GMM}{\\mathrm{GMM}}\\newcommand{\\MM}{\\mathrm{MM}}\\newcommand{\\SSIV}{\\mathrm{SSIV}}\\newcommand{\\JIV}{\\mathrm{JIV}}\\newcommand{\\AR}{\\mathrm{AR}}\\newcommand{\\ILS}{\\mathrm{ILS}}\\newcommand{\\SLS}{\\mathrm{SLS}}\\newcommand{\\LIML}{\\mathrm{LIML}}\n",
        "\n",
        "\\newcommand{\\Rad}{\\mathrm{Rad}}\\newcommand{\\bY}{\\boldsymbol{Y}}\\newcommand{\\pone}{{(1)}}\\newcommand{\\ptwo}{{(2)}}\\newcommand{\\ps}[1]{{(#1)}}\\newcommand{\\fsub}{\\overset{\\text{finite}}{\\subset}}\n",
        "\n",
        "\n",
        "\\newcommand{\\varlim}{\\varprojlim}\\newcommand{\\Hom}{\\mathrm{Hom}}\\newcommand{\\Iso}{\\mathrm{Iso}}\\newcommand{\\Mor}{\\mathrm{Mor}}\\newcommand{\\Isom}{\\mathrm{Isom}}\\newcommand{\\Aut}{\\mathrm{Aut}}\\newcommand{\\End}{\\mathrm{End}}\\newcommand{\\op}{\\mathrm{op}}\\newcommand{\\ev}{\\mathrm{ev}}\\newcommand{\\Ob}{\\mathrm{Ob}}\\newcommand{\\Ar}{\\mathrm{Ar}}\\newcommand{\\Arr}{\\mathrm{Arr}}\\newcommand{\\Set}{\\mathrm{Set}}\\newcommand{\\Grp}{\\mathrm{Grp}}\\newcommand{\\Cat}{\\mathrm{Cat}}\\newcommand{\\Mon}{\\mathrm{Mon}}\\newcommand{\\Ring}{\\mathrm{Ring}}\\newcommand{\\CRing}{\\mathrm{CRing}}\\newcommand{\\Ab}{\\mathrm{Ab}}\\newcommand{\\Pos}{\\mathrm{Pos}}\\newcommand{\\Vect}{\\mathrm{Vect}}\\newcommand{\\FinVect}{\\mathrm{FinVect}}\\newcommand{\\FinSet}{\\mathrm{FinSet}}\\newcommand{\\FinMeas}{\\mathrm{FinMeas}}\\newcommand{\\OmegaAlg}{\\Omega\\text{-}\\mathrm{Alg}}\\newcommand{\\OmegaEAlg}{(\\Omega,E)\\text{-}\\mathrm{Alg}}\\newcommand{\\Fun}{\\mathrm{Fun}}\\newcommand{\\Func}{\\mathrm{Func}}\n",
        "\n",
        "\\newcommand{\\Stoch}{\\mathrm{Stoch}}\\newcommand{\\FinStoch}{\\mathrm{FinStoch}}\\newcommand{\\Copy}{\\mathrm{copy}}\\newcommand{\\Delete}{\\mathrm{delete}}\n",
        "\\newcommand{\\Bool}{\\mathrm{Bool}}\\newcommand{\\CABool}{\\mathrm{CABool}}\\newcommand{\\CompBoolAlg}{\\mathrm{CompBoolAlg}}\\newcommand{\\BoolAlg}{\\mathrm{BoolAlg}}\\newcommand{\\BoolRng}{\\mathrm{BoolRng}}\\newcommand{\\HeytAlg}{\\mathrm{HeytAlg}}\\newcommand{\\CompHeytAlg}{\\mathrm{CompHeytAlg}}\\newcommand{\\Lat}{\\mathrm{Lat}}\\newcommand{\\CompLat}{\\mathrm{CompLat}}\\newcommand{\\SemiLat}{\\mathrm{SemiLat}}\\newcommand{\\Stone}{\\mathrm{Stone}}\\newcommand{\\Mfd}{\\mathrm{Mfd}}\\newcommand{\\LieAlg}{\\mathrm{LieAlg}}\n",
        "\\newcommand{\\Op}{\\mathrm{Op}}\n",
        "\\newcommand{\\Sh}{\\mathrm{Sh}}\n",
        "\\newcommand{\\Diff}{\\mathrm{Diff}}\n",
        "\\newcommand{\\B}{\\mathcal{B}}\\newcommand{\\cB}{\\mathcal{B}}\\newcommand{\\Span}{\\mathrm{Span}}\\newcommand{\\Corr}{\\mathrm{Corr}}\\newcommand{\\Decat}{\\mathrm{Decat}}\\newcommand{\\Rep}{\\mathrm{Rep}}\\newcommand{\\Grpd}{\\mathrm{Grpd}}\\newcommand{\\sSet}{\\mathrm{sSet}}\\newcommand{\\Mod}{\\mathrm{Mod}}\\newcommand{\\SmoothMnf}{\\mathrm{SmoothMnf}}\\newcommand{\\coker}{\\mathrm{coker}}\\newcommand{\\Ord}{\\mathrm{Ord}}\\newcommand{\\eq}{\\mathrm{eq}}\\newcommand{\\coeq}{\\mathrm{coeq}}\\newcommand{\\act}{\\mathrm{act}}\n",
        "\n",
        "\\newcommand{\\apf}{\\mathrm{apf}}\\newcommand{\\opt}{\\mathrm{opt}}\\newcommand{\\IS}{\\mathrm{IS}}\\newcommand{\\IR}{\\mathrm{IR}}\\newcommand{\\iidsim}{\\overset{\\text{i.i.d.}}{\\sim}}\\newcommand{\\propt}{\\,\\propto\\,}\\newcommand{\\bM}{\\mathbb{M}}\\newcommand{\\cX}{\\mathcal{X}}\\newcommand{\\cY}{\\mathcal{Y}}\\newcommand{\\cP}{\\mathcal{P}}\\newcommand{\\ola}[1]{\\overleftarrow{#1}}\n",
        "\n",
        "\\renewcommand{\\iff}{\\;\\mathrm{iff}\\;}\n",
        "\\newcommand{\\False}{\\mathrm{False}}\\newcommand{\\True}{\\mathrm{True}}\n",
        "\\newcommand{\\otherwise}{\\mathrm{otherwise}}\n",
        "\\newcommand{\\suchthat}{\\;\\mathrm{s.t.}\\;}\n",
        "\n",
        "\\newcommand{\\cM}{\\mathcal{M}}\\newcommand{\\M}{\\mathbb{M}}\\newcommand{\\cF}{\\mathcal{F}}\\newcommand{\\cD}{\\mathcal{D}}\\newcommand{\\fX}{\\mathfrak{X}}\\newcommand{\\fY}{\\mathfrak{Y}}\\newcommand{\\fZ}{\\mathfrak{Z}}\\renewcommand{\\H}{\\mathcal{H}}\\newcommand{\\cH}{\\mathcal{H}}\\newcommand{\\fH}{\\mathfrak{H}}\\newcommand{\\bH}{\\mathbb{H}}\\newcommand{\\id}{\\mathrm{id}}\\newcommand{\\A}{\\mathcal{A}}\n",
        "\\newcommand{\\lmd}{\\lambda}\n",
        "\\newcommand{\\Lmd}{\\Lambda}\n",
        "\\newcommand{\\cI}{\\mathcal{I}}\n",
        "\n",
        "\\newcommand{\\Lrarrow}{\\;\\;\\Leftrightarrow\\;\\;}\n",
        "\\DeclareMathOperator{\\des}{des}\n",
        "\\DeclareMathOperator{\\nd}{nd}\n",
        "\\DeclareMathOperator{\\dsep}{d-sep}\n",
        "\\DeclareMathOperator{\\sep}{sep}\n",
        "\\newcommand{\\rLL}{\\mathrm{LL}}\\newcommand{\\HT}{\\mathrm{HT}}\\newcommand{\\PS}{\\mathrm{PS}}\\newcommand{\\rI}{\\mathrm{I}}\n",
        "$$\n",
        "\n",
        ":::\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        "前稿はこちら：\n",
        "\n",
        "::: {#lst-listing}\n",
        ":::\n",
        "\n",
        "## 重点サブサンプリングを取り入れた Zig-Zag サンプラー\n",
        "\n",
        "### はじめに\n",
        "\n",
        "説明変数 $X\\in\\L(\\Om;\\R^p)$ と回帰係数 $\\xi\\in\\L(\\Om;\\R^p)$ に関するロジスティックモデル\n",
        "\n",
        "$$\n",
        "\\P[Y=1\\mi X,\\xi]=F(X^\\top\\xi)=\\frac{\\exp(X^\\top\\xi)}{1+\\exp(X^\\top\\xi)}\\tag{1}\n",
        "$$\n",
        "\n",
        "において，$\\{y^i\\}$ または $\\{x^i_j\\}$ が不均衡であった場合は，前節で見たように Gibbs サンプラーによる方法ではスケールしない．\n",
        "\n",
        "よく調整されたランダムウォーク Metropolis-Hastings 法を用いることが解決の１つとしてあり得るが，やはり本当に大きな $n$ や $p$ に関してスケールしないことが問題である [@Chopin-Ridgway2017]．\n",
        "\n",
        "そこで Zig-Zag サンプラーを用いることを考える．Zig-Zag サンプラーについては次の記事も参照：\n",
        "\n",
        "::: {#lst-zigzag}\n",
        ":::\n",
        "\n",
        "### 事後分布の特徴\n",
        "\n",
        "実はロジスティック回帰ではポテンシャル $U$ の勾配が有界になり，簡単なサブサンプリングが可能である．\n",
        "\n",
        "事後分布の負の対数密度は，定数の違いを除いて次のように表せる：\n",
        "\\begin{align*}\n",
        "    U(\\xi)&:=-\\log p_0(\\xi)-\\sum_{i=1}^n\\log\\paren{\\frac{\\exp(y^i(x^i)^\\top\\xi)}{1+\\exp((x^i)^\\top\\xi)}}\\\\\n",
        "    &=:U_0(\\xi)+U_1(\\xi).\n",
        "\\end{align*}\n",
        "\n",
        "$U_1$ は次のように１つのサンプルのみに依存する関数 $U^j_1$ の平均として表せる：\n",
        "$$\n",
        "U_1(\\xi)=\\frac{1}{n}\\sum_{j=1}^nU^j_1(\\xi)\n",
        "$$\n",
        "$$\n",
        "U_1^j(\\xi)=-n\\log\\paren{\\frac{\\exp\\paren{y^j(x^j)^\\top\\xi}}{1+\\exp\\paren{(x^j)^\\top\\xi}}}\n",
        "$$\n",
        "\n",
        "各 $U^j_1$ の勾配は次のように計算でき，有界である：\n",
        "$$\n",
        "\\partial_iU^j_1(\\xi)=n\\frac{x^j_i\\exp\\paren{(x^j)^\\top\\xi}}{1+\\exp\\paren{(x^j)^\\top\\xi}}-ny^jx^j_i<nx^j_i(1-y^j).\n",
        "$$\n",
        "\n",
        "### 定数強度 Poisson 点過程からの剪定 {#sec-ZZ-Global}\n",
        "\n",
        "特に全 $\\partial_iU_1(\\xi)$ に共通する上界として\n",
        "$$\n",
        "\\abs{\\partial_iU^j_1(\\xi)}\\le n\\max_{j\\in[n]}\\abs{x^j_i}\\qquad i\\in[d]\n",
        "$$ {#eq-bound-U1}\n",
        "を得るから，強度\n",
        "$$\n",
        "\\lambda_i(\\xi,\\theta)=\\Paren{\\theta_i\\partial_iU(\\xi)}_+\\le\\Paren{n\\theta_i\\max_{j\\in[n]}\\abs{x^j_i}}_+\n",
        "$$\n",
        "をもった Poisson 点過程を元に剪定 (thinning) [@Lewis-Shedler1979] を実行できる．\n"
      ],
      "id": "70558d0f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| output: false\n",
        "#| code-summary: サブサンプリングなしの Zig-Zag 過程のシミュレーションをする関数 ZZ1d() を定義\n",
        "using ZigZagBoomerang\n",
        "using Distributions\n",
        "using Random\n",
        "using LinearAlgebra\n",
        "using Statistics  # just for sure\n",
        "using StatsFuns\n",
        "\n",
        "\"\"\"\n",
        "    ∇U(i,j,ξ,x,y)\n",
        "        i ∈ [d]: 次元を表すインデックス\n",
        "        j ∈ [n]: サンプル番号を表すインデックス\n",
        "        ξ: パラメータ空間 R^d 上の位置\n",
        "        他，観測 (x,y) を引数にとる．\n",
        "    この関数を実装する際，log の中身をそのまま計算しようとすると大変大きくなり，数値的に不安定になる（除算の後は 1 近くになるはずだが，Inf になってしまう）\n",
        "\"\"\"\n",
        "∇U(i::Int64, j::Int64, ξ, x::Matrix{Float64}, y::Vector{Float64}) = length(y) * x[i,j] * (logistic(dot(x[:,j],ξ)) - y[j])\n",
        "\n",
        "\"\"\"\n",
        "    ∇U(i,ξ,x,y)：∇U(i,j,ξ,x,y) を全データ j ∈ [n] について足し合わせたもの\n",
        "        i ∈ [d]: 次元を表すインデックス\n",
        "        ξ: パラメータ空間 R^d 上の位置\n",
        "        他，観測 (x,y) を引数にとる．\n",
        "\"\"\"\n",
        "function ∇U(i::Int64, ξ, x::Matrix{Float64}, y::Vector{Float64})\n",
        "    n = length(y)\n",
        "    U_list = []\n",
        "    for j in 1:n\n",
        "        push!(U_list, ∇U(i, j, ξ, x, y))\n",
        "    end\n",
        "    return mean(U_list)\n",
        "end\n",
        "\n",
        "function  ∇U(ξ, x::Matrix{Float64}, y::Vector{Float64})  # 1次元の場合のショートカット\n",
        "    return ∇U(1, ξ, x, y)\n",
        "end\n",
        "\n",
        "pos(x) = max(zero(x), x)\n",
        "\n",
        "\"\"\"\n",
        "    λ(i, ξ, θ, ∇U, x, y)：第 i ∈ [d] 次元のレート関数\n",
        "        i ∈ [d]: 次元を表すインデックス\n",
        "        (ξ,θ): E 上の座標\n",
        "        ∇U\n",
        "        (x,y): 観測\n",
        "\"\"\"\n",
        "λ(i::Int64, ξ, θ, ∇U, x, y) = pos(θ[i] * ∇U(i, ξ, x, y))\n",
        "λ(ξ, θ, ∇U, x, y) = pos(θ * ∇U(ξ, x, y))  # 1次元の場合のショートカット\n",
        "\n",
        "\"\"\"\n",
        "    λ(τ, a, b)：代理レート関数の時刻 τ における値\n",
        "        τ: 時間\n",
        "        a,b: 1次関数の係数\n",
        "\"\"\"\n",
        "λ_bar(τ, a, b) = pos(a + b*τ)\n",
        "\n",
        "\"\"\"\n",
        "`x`: current location, `θ`: current velocity, `t`: current time,\n",
        "\"\"\"\n",
        "function move_forward(τ, t, ξ, θ, ::ZigZag1d)\n",
        "    τ + t, ξ + θ*τ , θ\n",
        "end\n",
        "\n",
        "\"\"\"\n",
        "    ZZ1d(∇U, ξ, θ, T, x, y, Flow; rng=Random.GLOBAL_RNG, ab=ab_Global)：ZigZag sampler without subsampling\n",
        "        `∇U`: gradient of the negative log-density\n",
        "        `(ξ,θ)`: initial state\n",
        "        `T`: Time Horizon\n",
        "        `(x,y)`: observation\n",
        "        `Flow`: continuous dynamics\n",
        "\n",
        "        `a+bt`: computational bound for intensity m(t)\n",
        "\n",
        "        `num`: ポアソン時刻に到着した回数\n",
        "        `acc`: 受容回数．`acc/num` は acceptance rate\n",
        "\"\"\"\n",
        "function ZZ1d(∇U, ξ, θ, T::Float64, x::Matrix{Float64}, y::Vector{Float64}, Flow::ZigZagBoomerang.ContinuousDynamics; rng=Random.GLOBAL_RNG, ab=ab_Global)\n",
        "    t = zero(T)\n",
        "    Ξ = [(t, ξ, θ)]\n",
        "    num = acc = 0\n",
        "    epoch_list = [num]\n",
        "    a, b = ab(ξ, θ, x, y, Flow)\n",
        "    t′ =  t + poisson_time(a, b, rand())  # イベントは a,b が定める affine proxy に従って生成する\n",
        "\n",
        "    while t < T\n",
        "        τ = t′ - t\n",
        "        t, ξ, θ = move_forward(τ, t, ξ, θ, Flow)\n",
        "        l, lb = λ(ξ, θ, ∇U, x, y), λ_bar(τ, a, b)  # λ が真のレート, λ_bar が affine proxy\n",
        "        num += 1\n",
        "        if rand()*lb < l\n",
        "            acc += 1\n",
        "            if l > lb + 0.01\n",
        "                println(l-lb)\n",
        "                println(l)\n",
        "            end\n",
        "            θ = -θ\n",
        "            push!(Ξ, (t, ξ, θ))\n",
        "            push!(epoch_list, num)\n",
        "        end\n",
        "        a, b = ab(ξ, θ, x, y, Flow)\n",
        "        t′ = t + poisson_time(a, b, rand())\n",
        "    end\n",
        "\n",
        "    return Ξ, epoch_list, acc/num\n",
        "end"
      ],
      "id": "1bcdd19a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-summary: global な computational bounds を定義\n",
        "#| output: false\n",
        "\n",
        "a_Global(ξ, θ, x, y) = length(y) * maximum(abs.(vec(x)))\n",
        "b_Global(ξ, θ, x, y) = 0\n",
        "\n",
        "ab_Global(ξ, θ, x, y, ::ZigZag1d) = (a_Global(ξ, θ, x, y), b_Global(ξ, θ, x, y))"
      ],
      "id": "c8969bef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "# T = 500.0\n",
        "# (ξ0, θ0) = (0.0, 1.0)\n",
        "# trace_ZZ1, epochs_ZZ1, acc_ZZ1 = ZZ1d(∇U, ξ0, θ0, T, x, y, ZigZag1d(); ab=ab_Global)\n",
        "# dt = 0.01\n",
        "# traj_ZZ1 = discretize(trace_ZZ1, ZigZag1d(), dt)"
      ],
      "id": "309f2ef3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Affine 強度 Poisson 点過程からの剪定 {#sec-ZZ-Affine}\n",
        "\n",
        "さらにタイトに，次の affine 関数による評価を考える：\n",
        "$$\n",
        "\\ov{m}_i(t):=a_i+b_it,\\qquad i\\in[d],\n",
        "$$\n",
        "$$\n",
        "a_i:=(\\theta_i\\partial_iU(\\xi_*))_++C_i\\abs{\\xi-\\xi_*}\n",
        "$$\n",
        "$$\n",
        "b_i:=C_i\\sqrt{d},\\qquad C_i:=\\frac{n}{4}\\max_{j\\in[n]}\\abs{x^j_i}\\abs{x^j}.\n",
        "$$\n"
      ],
      "id": "fdcb08b5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: 観測を生成\n",
        "#| output: false\n",
        "using StatsFuns\n",
        "using Distributions\n",
        "\n",
        "ξ0 = [1.0] # True value\n",
        "n_list = [10, 100, 1000]  # 実験で用いるサンプルサイズの列\n",
        "\n",
        "Σ = [2]\n",
        "x = rand(MvNormal(ξ0, Σ), n_list[end])\n",
        "y = rand.(Bernoulli.(logistic.(ξ0*x)))  # BitVector になってしまう\n",
        "y = Float64.(vec(y))  # Vector{Float64} に変換"
      ],
      "id": "84171782",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "using JLD2\n",
        "\n",
        "@load \"Logistic2_data.jld2\" x y"
      ],
      "id": "273ac9bf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-summary: preprocessing for ZZ-CV of complexity O(n)\n",
        "#| output: false\n",
        "using Statistics\n",
        "using LinearAlgebra\n",
        "\n",
        "\"\"\"\n",
        "    U(ξ, x, y)：ポテンシャル関数\n",
        "        ξ: パラメータ空間上の点\n",
        "        (x,y): 観測\n",
        "\"\"\"\n",
        "function U(ξ, x, y)\n",
        "    n = length(y)\n",
        "    U_list = []\n",
        "    for j in 1:n\n",
        "        push!(U_list, U(j, ξ, x, y))\n",
        "    end\n",
        "    return mean(U_list)\n",
        "end\n",
        "function U(j, ξ, x, y)\n",
        "    n = length(y)\n",
        "    product = dot(x[:,j],ξ)\n",
        "    return -n * log(exp(y[j] * product) / (1 + exp(product)))\n",
        "end\n",
        "\n",
        "using Optim\n",
        "\n",
        "result = optimize(ξ -> U(ξ, x, y), [0.0], LBFGS())\n",
        "ξ_star = Optim.minimizer(result)\n",
        "\n",
        "function C(ξ, θ, x, y)\n",
        "    n = length(y)\n",
        "    max_value = maximum(x.^2)\n",
        "    return n * max_value / 4\n",
        "end\n",
        "\n",
        "a_Affine(ξ, θ, x, y) = pos(θ * ∇U(ξ_star,x,y)) + C(ξ, θ, x, y) * abs(ξ - ξ_star[1])\n",
        "b_Affine(ξ, θ, x, y) = C(ξ, θ, x, y)\n",
        "\n",
        "# computational bounds for intensity m(t)\n",
        "ab_Affine(ξ, θ, x, y, ::ZigZag1d) = (a_Affine(ξ, θ, x, y), b_Affine(ξ, θ, x, y))"
      ],
      "id": "aa1a0340",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "# T = 500.0\n",
        "# (ξ0, θ0) = (0.0, 1.0)\n",
        "# trace_ZZ1, epochs_ZZ1, acc_ZZ1 = ZZ1d(∇U, ξ0, θ0, T, x, y, ZigZag1d(); ab=ab_Affine)\n",
        "# dt = 0.01\n",
        "# traj_ZZ1 = discretize(trace_ZZ1, ZigZag1d(), dt)"
      ],
      "id": "8b30bc65",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### サブサンプリング：確率的な点過程からの剪定 {#sec-ZZ-SS-CV}\n",
        "\n",
        "Poisson 過程の強度関数を確率化し，$K\\sim\\rU([n])$ に対して\n",
        "$$\n",
        "m_i^K(t):=\\Paren{\\theta_i E^K_i(x+\\theta t)}_+\n",
        "$$\n",
        "$$\n",
        "E^K_i(x):=\\partial_iU(\\xi_*)+\\partial_iU^K(\\xi)-\\partial_iU^K(\\xi_*)\n",
        "$$\n",
        "としても，引き続き同様の上界を持つ．\n",
        "\n",
        "ここで，$m_i^K$ の評価は $m_i$ より $n$ 倍軽量になっていることに注意．\n"
      ],
      "id": "24011948"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| output: false\n",
        "#| code-summary: サブサンプリングありの Zig-Zag 過程のシミュレーションをする関数 ZZ1d_SS() と ZZ1d_CV() を定義\n",
        "using ZigZagBoomerang\n",
        "using Distributions\n",
        "using Random\n",
        "using LinearAlgebra\n",
        "using Statistics  # just for sure\n",
        "using StatsFuns\n",
        "\n",
        "function λj_Global(j::Int64, ξ, θ, ∇U, x, y)\n",
        "    Eʲ = ∇U(1, j, ξ, x, y)\n",
        "    return pos(θ * Eʲ)\n",
        "end\n",
        "\n",
        "function ZZ1d_SS(∇U, ξ, θ, T::Float64, x::Matrix{Float64}, y::Vector{Float64}, Flow::ZigZagBoomerang.ContinuousDynamics; rng=Random.GLOBAL_RNG, ab=ab_Global)\n",
        "    t = zero(T)\n",
        "    Ξ = [(t, ξ, θ)]\n",
        "    num = acc = 0\n",
        "    epoch_list = [num]\n",
        "    a, b = ab(ξ, θ, x, y, Flow)\n",
        "    t′ =  t + poisson_time(a, b, rand())  # イベントは a,b が定める affine proxy に従って生成する\n",
        "\n",
        "    while t < T\n",
        "        τ = t′ - t\n",
        "        t, ξ, θ = move_forward(τ, t, ξ, θ, Flow)\n",
        "        j = rand(1:length(y))\n",
        "        l, lb = λj_Global(j, ξ, θ, ∇U, x, y), λ_bar(τ, a, b)  # λ が真のレート, λ_bar が affine proxy\n",
        "        num += 1\n",
        "        if rand()*lb < l\n",
        "            acc += 1\n",
        "            if l > lb + 0.01\n",
        "                println(l-lb)\n",
        "            end\n",
        "            θ = -θ\n",
        "            push!(Ξ, (t, ξ, θ))\n",
        "            push!(epoch_list, num)\n",
        "        end\n",
        "        a, b = ab(ξ, θ, x, y, Flow)\n",
        "        t′ = t + poisson_time(a, b, rand())\n",
        "    end\n",
        "\n",
        "    return Ξ, epoch_list, acc/num\n",
        "end\n",
        "\n",
        "function λj(j::Int64, ξ, θ, ∇U, x, y)\n",
        "    Eʲ = ∇U(ξ_star, x, y) + ∇U(1, j, ξ, x, y) - ∇U(1, j, ξ_star, x, y)\n",
        "    return pos(θ * Eʲ)\n",
        "end\n",
        "\n",
        "function ZZ1d_CV(∇U, ξ, θ, T::Float64, x::Matrix{Float64}, y::Vector{Float64}, Flow::ZigZagBoomerang.ContinuousDynamics; rng=Random.GLOBAL_RNG, ab=ab_Affine)\n",
        "    t = zero(T)\n",
        "    Ξ = [(t, ξ, θ)]\n",
        "    num = acc = 0\n",
        "    epoch_list = [num]\n",
        "    a, b = ab(ξ, θ, x, y, Flow)\n",
        "    t′ =  t + poisson_time(a, b, rand())  # イベントは a,b が定める affine proxy に従って生成する\n",
        "\n",
        "    while t < T\n",
        "        τ = t′ - t\n",
        "        t, ξ, θ = move_forward(τ, t, ξ, θ, Flow)\n",
        "        j = rand(1:length(y))\n",
        "        l, lb = λj(j, ξ, θ, ∇U, x, y), λ_bar(τ, a, b)  # λ が真のレート, λ_bar が affine proxy\n",
        "        num += 1\n",
        "        if rand()*lb < l\n",
        "            acc += 1\n",
        "            if l > lb + 0.01\n",
        "                println(l-lb)\n",
        "            end\n",
        "            θ = -θ\n",
        "            push!(Ξ, (t, ξ, θ))\n",
        "            push!(epoch_list, num)\n",
        "        end\n",
        "        a, b = ab(ξ, θ, x, y, Flow)\n",
        "        t′ = t + poisson_time(a, b, rand())\n",
        "    end\n",
        "\n",
        "    return Ξ, epoch_list, acc/num\n",
        "end"
      ],
      "id": "73a38f03",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 数値実験による性能比較\n",
        "\n",
        "| 剪定元の Poisson 過程の強度 \\\\ サブサンプリング | なし | あり |\n",
        "|:----:|:----:|:---:|\n",
        "| 定数 | ZZ (Global) [-@sec-ZZ-Global] | ZZ-SS [-@sec-ZZ-SS-CV] |\n",
        "| Affine | ZZ (Affine) [-@sec-ZZ-Affine] | ZZ-CV [-@sec-ZZ-SS-CV] |\n",
        "\n",
        ": ４つの Zig-Zag サンプラーの実装 {.hover .responsive-sm tbl-colwidths=\"[40,30,30]\"}\n"
      ],
      "id": "3811bb62"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-summary: サブサンプリングなしの実験を実行する関数 experiment_ZZ() を定義\n",
        "#| code-fold: true\n",
        "#| eval: false\n",
        "using Statistics\n",
        "\n",
        "function ESS(samples::Vector{Float64}, T, dt)\n",
        "    B = T / dt\n",
        "    V = (dt / T) * sum(samples.^2) - ((dt / T) * sum(samples))^2\n",
        "    Y = samples .* sqrt(T / B)\n",
        "    ESS = T * V / var(Y)\n",
        "    return ESS\n",
        "end\n",
        "\n",
        "function getESSperEpoch(ab, T ,dt, x, y; ξ0=0.0, θ0=1.0)\n",
        "    trace, epochs, acc = ZZ1d(∇U, ξ0, θ0, T, x, y, ZigZag1d(); ab=ab)\n",
        "    traj = discretize(trace, ZigZag1d(), dt)\n",
        "    return ESS(traj.x, T, dt) / epochs[end]\n",
        "end\n",
        "\n",
        "N = 10\n",
        "T = 500.0\n",
        "dt = 0.1\n",
        "\n",
        "function experiment_ZZ(N, T, dt; ξ0=0.0, θ0=1.0, n_list=[10, 100, 1000])  # サブサンプリングなしの ZZ() に関して N 回実験\n",
        "    ESSs_sum_Affine = zero(n_list)\n",
        "    ESSs_sum_Global = zero(n_list)\n",
        "\n",
        "    for _ in 1:N\n",
        "        ESSs_Affine = []\n",
        "        ESSs_Global = []\n",
        "        for n in n_list\n",
        "            push!(ESSs_Affine, getESSperEpoch(ab_Affine, T, dt, x[:,1:n], y[1:n]; ξ0=ξ0, θ0=θ0))\n",
        "            push!(ESSs_Global, getESSperEpoch(ab_Global, T, dt, x[:,1:n], y[1:n]; ξ0=ξ0, θ0=θ0))\n",
        "        end\n",
        "        ESSs_sum_Affine = [ESSs_sum_Affine ESSs_Affine]\n",
        "        ESSs_sum_Global = [ESSs_sum_Global ESSs_Global]\n",
        "    end\n",
        "    return mean(ESSs_sum_Affine, dims=2), var(ESSs_sum_Affine, dims=2), mean(ESSs_sum_Global, dims=2), var(ESSs_sum_Global, dims=2)\n",
        "end\n",
        "\n",
        "# ESS_Affine, var_ESS_Affine, ESS_Global, var_ESS_Global = experiment_ZZ(2, T, dt; ξ0=0.0, θ0=1.0, n_list=n_list)"
      ],
      "id": "54be6af6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-summary: 実験には 10分 かかるので，保持した実行結果を用いる\n",
        "#| output: false\n",
        "#| code-fold: true\n",
        "using JLD2\n",
        "\n",
        "@load \"Logistic2_Experiment1.jld2\" ESS_Affine var_ESS_Affine ESS_Global var_ESS_Global"
      ],
      "id": "ddc8a2e8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-summary: 結果をプロット\n",
        "#| code-fold: true\n",
        "#| echo: false\n",
        "#| output: false\n",
        "using Plots\n",
        "using GLM, DataFrames\n",
        "\n",
        "function startPlot(n_list, ESS, var_ESS; label=\"ZZ (Global bound)\", background_color=false, color=\"#78C2AD\", xlabel=\"Observations\")\n",
        "    if background_color\n",
        "        p = plot(#n_list, ESS,\n",
        "        xscale=:log10,\n",
        "        yscale=:log10,\n",
        "        xlabel=xlabel,\n",
        "        ylabel=\"ESS per Epoch\",\n",
        "        background_color = \"#F0F1EB\"\n",
        "        )\n",
        "    else\n",
        "        p = plot(#n_list, ESS,\n",
        "        xscale=:log10,\n",
        "        yscale=:log10,\n",
        "        xlabel=xlabel,\n",
        "        ylabel=\"ESS per Epoch\"\n",
        "        )\n",
        "    end\n",
        "\n",
        "    scatter!(p, n_list, ESS,\n",
        "            yerror=var_ESS,\n",
        "            markerstrokecolor=color,\n",
        "            marker=:circle,\n",
        "            markersize=5,\n",
        "            markeralpha=0.6,\n",
        "            color=color,\n",
        "            label=nothing\n",
        "            )\n",
        "\n",
        "    df = DataFrame(X = log10.(n_list), Y = log10.(vec(ESS)))\n",
        "    model = lm(@formula(Y ~ X), df)\n",
        "    X_pred = range(minimum(df.X), maximum(df.X), length=100)\n",
        "    Y_pred = predict(model, DataFrame(X = X_pred))\n",
        "    plot!(p, 10 .^ X_pred, 10 .^ Y_pred,\n",
        "        line=:solid,\n",
        "        linewidth=2,\n",
        "        color=color,\n",
        "        label=label\n",
        "        )\n",
        "\n",
        "    return p\n",
        "end\n",
        "\n",
        "function addPlot(p, n_list, ESS, var_ESS; label=\"ZZ (Affine bound)\", color=\"#E95420\")\n",
        "    q = scatter(p, n_list, ESS,\n",
        "            yerror=var_ESS,\n",
        "            markerstrokecolor=color,\n",
        "            marker=:circle,\n",
        "            markersize=5,\n",
        "            markeralpha=0.6,\n",
        "            color=color,\n",
        "            label=nothing\n",
        "            )\n",
        "\n",
        "    df = DataFrame(X = log10.(n_list), Y = log10.(vec(ESS)))\n",
        "    model = lm(@formula(Y ~ X), df)\n",
        "    X_pred = range(minimum(df.X), maximum(df.X), length=100)\n",
        "    Y_pred = predict(model, DataFrame(X = X_pred))\n",
        "    plot!(q, 10 .^ X_pred, 10 .^ Y_pred,\n",
        "        line=:solid,\n",
        "        linewidth=2,\n",
        "        color=color,\n",
        "        label=label\n",
        "        )\n",
        "    \n",
        "    return q\n",
        "end\n",
        "\n",
        "p = startPlot(n_list, ESS_Global, sqrt.(var_ESS_Global)#; background_color=true\n",
        ")\n",
        "q = addPlot(p, n_list, ESS_Affine, sqrt.(var_ESS_Affine))\n",
        "display(q)"
      ],
      "id": "9486152d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-summary: サブサンプリング付きの実験を実行する関数 experiment_ZZ() を定義\n",
        "#| code-fold: true\n",
        "#| eval: false\n",
        "using Statistics\n",
        "\n",
        "# function ESS(samples::Vector{Float64}, T, dt)\n",
        "#     B = T / dt\n",
        "#     V = (dt / T) * sum(samples.^2) - ((dt / T) * sum(samples))^2\n",
        "#     Y = samples .* sqrt(T / B)\n",
        "#     ESS = T * V / var(Y)\n",
        "#     return ESS\n",
        "# end\n",
        "\n",
        "function getESSperEpoch_SS(ab, ZZ, T ,dt, x, y; ξ0=0.0, θ0=1.0)\n",
        "    trace, epochs, acc = ZZ(∇U, ξ0, θ0, T, x, y, ZigZag1d(); ab=ab)\n",
        "    traj = discretize(trace, ZigZag1d(), dt)\n",
        "    return ESS(traj.x, T, dt) * length(y) / epochs[end]  # サブサンプリングをしているので length(y) で補正する必要あり\n",
        "end\n",
        "\n",
        "N = 10\n",
        "T = 500.0\n",
        "dt = 0.1\n",
        "\n",
        "function experiment_ZZ_SS(N, T, dt; ξ0=0.0, θ0=1.0, n_list=[10, 100, 1000])  # サブサンプリングなしの ZZ() に関して N 回実験\n",
        "    ESSs_sum_CV = zero(n_list)\n",
        "    ESSs_sum_SS = zero(n_list)\n",
        "\n",
        "    for _ in 1:N\n",
        "        ESSs_CV = []\n",
        "        ESSs_SS = []\n",
        "        for n in n_list\n",
        "            push!(ESSs_CV, getESSperEpoch_SS(ab_Affine, ZZ1d_CV, T, dt, x[:,1:n], y[1:n]; ξ0=ξ0, θ0=θ0))\n",
        "            push!(ESSs_SS, getESSperEpoch_SS(ab_Global, ZZ1d_SS, T, dt, x[:,1:n], y[1:n]; ξ0=ξ0, θ0=θ0))\n",
        "        end\n",
        "        ESSs_sum_CV = [ESSs_sum_CV ESSs_CV]\n",
        "        ESSs_sum_SS = [ESSs_sum_SS ESSs_SS]\n",
        "    end\n",
        "    return mean(ESSs_sum_CV, dims=2), var(ESSs_sum_CV, dims=2), mean(ESSs_sum_SS, dims=2), var(ESSs_sum_SS, dims=2)\n",
        "end\n",
        "\n",
        "# ESS_CV, var_ESS_CV, ESS_SS, var_ESS_SS = experiment_ZZ_SS(2, T, dt; ξ0=0.0, θ0=1.0, n_list=n_list)"
      ],
      "id": "fcab22cd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "@load \"Logistic2_Experiment2.jld2\" ESS_CV var_ESS_CV ESS_SS var_ESS_SS"
      ],
      "id": "af6b1927",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-summary: 結果をプロット\n",
        "#| code-fold: true\n",
        "\n",
        "q = addPlot(q, n_list, ESS_CV, sqrt.(var_ESS_CV); label=\"ZZ-CV\", color=\"darkorange\")\n",
        "q = addPlot(q, n_list, ESS_SS, sqrt.(var_ESS_SS); label=\"ZZ-SS\", color=\"blue\")\n",
        "q = plot!(q, legend=:bottomleft)\n",
        "display(q)"
      ],
      "id": "70a90a1b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "#| eval: false\n",
        "savefig(q, \"Logistic2_ESS_per_Epoch.svg\")"
      ],
      "id": "4f60109e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "実際に実験に用いたコードは[こちら](_Logistic2.jl)．\n",
        "\n",
        "### 比較対象：MALA\n"
      ],
      "id": "75b21b85"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "#| code-fold: true\n",
        "#| code-summary: MALA によるサンプリングを実行\n",
        "using AdvancedHMC, AdvancedMH, ForwardDiff\n",
        "using LogDensityProblems\n",
        "using LogDensityProblemsAD\n",
        "using StructArrays\n",
        "using LinearAlgebra\n",
        "\n",
        "struct LogTargetDensity\n",
        "    x::Matrix{Float64}\n",
        "    y::Vector{Float64}\n",
        "end\n",
        "\n",
        "LogDensityProblems.logdensity(p::LogTargetDensity, ξ) = -U(ξ, p.x, p.y)\n",
        "LogDensityProblems.dimension(p::LogTargetDensity) = 1\n",
        "LogDensityProblems.capabilities(::Type{LogTargetDensity}) = LogDensityProblems.LogDensityOrder{0}()\n",
        "\n",
        "model_with_ad = LogDensityProblemsAD.ADgradient(Val(:ForwardDiff), LogTargetDensity(x, y))\n",
        "\n",
        "σ² = 0.0001\n",
        "spl = MALA(x -> MvNormal((σ² / 2) .* x, σ² * I))\n",
        "\n",
        "chain = sample(model_with_ad, spl, 2000; initial_params=ξ0, chain_type=StructArray, param_names=[\"ξ\"], stats=true)\n",
        "\n",
        "traj_MALA = chain.ξ"
      ],
      "id": "c4eed6c9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### 有効サンプル数について\n",
        "\n",
        "時区間 $[0,T]$ における ZigZag 過程の，関数 $h\\in\\L^2(\\R^d)$ に関する **有効サンプル数** (ESS) とは\n",
        "$$\n",
        "\\wh{\\ESS}:=T\\frac{\\wh{\\V_\\pi[h]}}{\\wh{\\sigma^2_h}}\n",
        "$$\n",
        "$$\n",
        "\\wh{\\V_\\pi[h]}:=\\frac{1}{T}\\int^T_0h(X_s)^2\\,ds-\\paren{\\frac{1}{T}\\int^T_0h(X_s)\\,ds}^2,\n",
        "$$\n",
        "$$\n",
        "\\wh{\\sigma^2_h}:=\\frac{1}{B-1}\\sum_{i=1}^B(Y_i-\\ov{Y})^2,\\quad Y_i:=\\sqrt{\\frac{B}{T}}\\int^{\\frac{iT}{B}}_{\\frac{(i-1)T}{B}}h(X_s)\\,ds\n",
        "$$\n",
        "で定まる値である．\n",
        "\n",
        "例えば次のようにして計算できる：\n",
        "\n",
        "```julia\n",
        "function ESS(samples::Vector{Float64}, T, dt)\n",
        "    V = (dt / T) * sum(samples.^2) - ((dt / T) * sum(samples))^2\n",
        "    Y = samples .* sqrt(T / B)\n",
        "    ESS = T * V / var(Y)\n",
        "    return ESS\n",
        "end\n",
        "```\n",
        "\n",
        "### 重点サブサンプリング [@Sen+2020]\n",
        "\n",
        "一様でないサブサンプリングを導入することで，Zig-Zag サンプラーを不均衡データにも強くすると同時に，サブサンプリングの効率を上げることもできる．\n",
        "\n",
        "サブサンプリングのために定義したランダムな強度関数（第 [-@sec-ZZ-SS-CV] 節）\n",
        "$$\n",
        "m_i^K(t)=\\Paren{\\theta_iE^K_i(x+\\theta t)}_+\n",
        "$$\n",
        "は，\n",
        "$$\n",
        "\\E\\SQuare{E^K_i(\\xi)}=\\partial_iU(\\xi)\n",
        "$$\n",
        "を満たす限り，$K\\sim\\rU([n])$ に限る必要はなかったのである．\n",
        "\n",
        "すなわち，$(p_x)$ をある $[n]$ 上の分布 $\\nu\\in\\cP([n])$ の質量関数として\n",
        "$$\n",
        "\\partial_iV_1^J(\\xi):=\\frac{1}{p_J}\\partial_iU^J(\\xi)\\qquad J\\sim\\nu\n",
        "$$\n",
        "と定めると，\n",
        "$$\n",
        "\\abs{\\partial_iV_i^j(\\xi)}\\le\\max_{j\\in[n]}\\frac{\\abs{x_i^j}}{p_j}\n",
        "$$\n",
        "が成り立つ．式 ([-@eq-bound-U1]) は $p_j\\equiv1/n$ の場合であったのである．\n",
        "\n",
        "換言すれば，\n",
        "$$\n",
        "p_j\\propt\\abs{x^j_i}\n",
        "$$\n",
        "と定めることで，Poisson 強度関数 $m^j_i$ の上界をタイトにすることができ，その結果剪定の効率が上がる．\n"
      ],
      "id": "edb759c4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "a_IS(ξ, θ, x, y) = sum(abs.(x))\n",
        "b_IS(ξ, θ, x, y) = 0\n",
        "\n",
        "ab_IS(ξ, θ, x, y, ::ZigZag1d) = (a_IS(ξ, θ, x, y), b_IS(ξ, θ, x, y))"
      ],
      "id": "6ac9731c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| output: false\n",
        "#| code-summary: 重点サブサンプリングによる ZigZag サンプラー ZZ1d_IS() を定義\n",
        "using StatsBase\n",
        "\n",
        "function λj_IS(j::Int64, ξ, θ, ∇U, x, y)\n",
        "    pj = abs(x[1,j]) / sum(abs.(x))  # x がスパースだと 0 になりやすいことに注意\n",
        "    Eʲ = ∇U(1, j, ξ, x, y) / (length(y) * pj)\n",
        "    return pos(θ * Eʲ)\n",
        "end\n",
        "\n",
        "function ZZ1d_IS(∇U, ξ, θ, T::Float64, x::Matrix{Float64}, y::Vector{Float64}, Flow::ZigZagBoomerang.ContinuousDynamics; rng=Random.GLOBAL_RNG, ab=ab_IS)\n",
        "    t = zero(T)\n",
        "    Ξ = [(t, ξ, θ)]\n",
        "    num = acc = 0\n",
        "    epoch_list = [num]\n",
        "    a, b = ab(ξ, θ, x, y, Flow)\n",
        "    t′ =  t + poisson_time(a, b, rand())  # イベントは a,b が定める affine proxy に従って生成する\n",
        "    n = length(y)\n",
        "\n",
        "    while t < T\n",
        "        τ = t′ - t\n",
        "        t, ξ, θ = move_forward(τ, t, ξ, θ, Flow)\n",
        "        j = sample(1:n, Weights(abs.(vec(x))))\n",
        "        l, lb = λj_IS(j, ξ, θ, ∇U, x, y), λ_bar(τ, a, b)  # λ が真のレート, λ_bar が affine proxy\n",
        "        num += 1\n",
        "        if rand()*lb < l\n",
        "            acc += 1\n",
        "            if l > lb + 0.01\n",
        "                println(l-lb)\n",
        "            end\n",
        "            θ = -θ\n",
        "            push!(Ξ, (t, ξ, θ))\n",
        "            push!(epoch_list, num)\n",
        "        end\n",
        "        a, b = ab(ξ, θ, x, y, Flow)\n",
        "        t′ = t + poisson_time(a, b, rand())\n",
        "    end\n",
        "\n",
        "    return Ξ, epoch_list, acc/num\n",
        "end"
      ],
      "id": "ebaf0efc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "#| code-fold: true\n",
        "#| code-summary: 実験を実行する関数 experiment_ZZ_IS() を定義\n",
        "function experiment_ZZ_IS(N, T, dt; ξ0=0.0, θ0=1.0, n_list=[10, 100, 1000])  # 重点サブサンプリング ZZ1d_IS() に関して N 回実験\n",
        "    ESSs_sum_IS = zero(n_list)\n",
        "\n",
        "    for _ in 1:N\n",
        "        ESSs_IS = []\n",
        "        for n in n_list\n",
        "            push!(ESSs_IS, getESSperEpoch_SS(ab_IS, ZZ1d_IS, T, dt, x[:,1:n], y[1:n]; ξ0=ξ0, θ0=θ0))\n",
        "        end\n",
        "        ESSs_sum_IS = [ESSs_sum_IS ESSs_IS]\n",
        "    end\n",
        "    return mean(ESSs_sum_IS, dims=2), var(ESSs_sum_IS, dims=2)\n",
        "end\n",
        "\n",
        "ESS_IS, var_ESS_IS = experiment_ZZ_IS(2, 500.0, 1.0; ξ0=0.0, θ0=1.0, n_list=n_list)"
      ],
      "id": "a2f9e01e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| output: false\n",
        "#| echo: false\n",
        "@load \"Logistic2_Experiment3_.jld2\" ESS_IS var_ESS_IS"
      ],
      "id": "85acbce8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {
        "fig-caption": "新たに追加された ZZ-IS は濃い緑色でプロットされている．"
      },
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: 結果をプロット\n",
        "r = addPlot(q, n_list, ESS_IS, sqrt.(var_ESS_IS); label=\"ZZ-IS\", color=\"green\")\n",
        "display(r)"
      ],
      "id": "bddbad4b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "#| eval: false\n",
        "savefig(r, \"Logistic2.svg\")"
      ],
      "id": "310c57a1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "制御変数による方法 ZZ-CV （オレンジ色）は $n\\to\\infty$ の漸近論に基づいているので，観測数が増えるほど効率は上がっていく．\n",
        "\n",
        "## Zig-Zag サンプラーの大規模不均衡データへの適用\n",
        "\n",
        "### 大規模不均衡データ\n",
        "\n",
        "大規模不均衡データでは，事後分布が十分な集中性を持たないために制御変数による方法 ZZ-CV が十分な効率改善を示さないが，重点サブサンプリングによれば Poisson 強度関数のタイトな上界を引き続き構成できる．\n",
        "\n",
        "ここでは，$\\xi_0=1$ を真値とし，次のような１次元データを考える：\n",
        "$$\n",
        "X^j\\iidsim(1-\\al)\\delta_0+\\al\\rN(1,2)\n",
        "$$\n",
        "$$\n",
        "\\P[Y^j=1]=\\frac{1}{1+e^{-X^j}}\n",
        "$$\n"
      ],
      "id": "853302da"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| output: false\n",
        "ξ0 = [1.0] # True value\n",
        "Σ = [2]\n",
        "n = 1000\n",
        "\n",
        "function sample_SparseData(n::Int64, α::Float64; ρ=MvNormal(ξ0, Σ))\n",
        "    x = []\n",
        "    while length(x) < n\n",
        "        rand() < α ? push!(x, rand(ρ)[1]) : push!(x, 0.0)\n",
        "    end\n",
        "    x = Float64.(reshape(x,1,:))\n",
        "    y = rand.(Bernoulli.(logistic.(ξ0*x)))\n",
        "    y = Float64.(vec(y))\n",
        "    return x, y\n",
        "end\n",
        "\n",
        "α_list = [1, 0.1, 0.01]\n",
        "\n",
        "x_Sparse, y_Sparse = [], []\n",
        "\n",
        "for α in α_list\n",
        "    x, y = sample_SparseData(n, α)\n",
        "    push!(x_Sparse, x)\n",
        "    push!(y_Sparse, y)\n",
        "end"
      ],
      "id": "d5a8e067",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "using JLD2\n",
        "@load \"Logistic2_data2.jld2\" x_Sparse y_Sparse"
      ],
      "id": "64f7b72a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "using Optim\n",
        "\n",
        "a_Sparse(ξ_star, ξ, θ, x, y) = pos(θ * ∇U(ξ_star,x,y)) + C(ξ, θ, x, y) * abs(ξ - ξ_star[1])\n",
        "ξ_star_list = []\n",
        "α_list = [1, 0.1, 0.01]\n",
        "\n",
        "for α in 1:length(α_list)\n",
        "    result = optimize(ξ -> U(ξ, x_Sparse[α], y_Sparse[α]), [0.0], LBFGS())\n",
        "    ξ = Optim.minimizer(result)\n",
        "    push!(ξ_star_list, ξ)\n",
        "end\n",
        "\n",
        "function experiment_Sparse(N, T, dt; ξ0=0.0, θ0=1.0, α_list=[1, 0.1, 0.01, 0.001])\n",
        "    # ESSs_sum_CV = zero(α_list)\n",
        "    ESSs_sum_SS = zero(α_list)\n",
        "    ESSs_sum_IS = zero(α_list)\n",
        "\n",
        "    for _ in 1:N\n",
        "        # ESSs_CV = []\n",
        "        ESSs_SS = []\n",
        "        ESSs_IS = []\n",
        "        for i in 1:length(α_list)\n",
        "            # ab_Sparse(ξ, θ, x, y, ::ZigZag1d) = (a_Sparse(ξ_star_list[i], ξ, θ, x, y), b_Affine(ξ, θ, x, y))\n",
        "            # push!(ESSs_CV, getESSperEpoch_SS(ab_Sparse, ZZ1d_CV, T, dt, x_Sparse[i], y_Sparse[i]; ξ0=ξ0, θ0=θ0))\n",
        "            push!(ESSs_SS, getESSperEpoch_SS(ab_Global, ZZ1d_SS, T, dt, x_Sparse[i], y_Sparse[i]; ξ0=ξ0, θ0=θ0))\n",
        "            push!(ESSs_IS, getESSperEpoch_SS(ab_IS, ZZ1d_IS, T, dt, x_Sparse[i], y_Sparse[i]; ξ0=ξ0, θ0=θ0))\n",
        "        end\n",
        "        # ESSs_sum_CV = [ESSs_sum_CV ESSs_CV]\n",
        "        ESSs_sum_SS = [ESSs_sum_SS ESSs_SS]\n",
        "        ESSs_sum_IS = [ESSs_sum_IS ESSs_IS]\n",
        "    end\n",
        "    # return mean(ESSs_sum_CV, dims=2), var(ESSs_sum_CV, dims=2), mean(ESSs_sum_SS, dims=2), var(ESSs_sum_SS, dims=2), mean(ESSs_sum_IS, dims=2), var(ESSs_sum_IS, dims=2)\n",
        "    return mean(ESSs_sum_SS, dims=2), var(ESSs_sum_SS, dims=2), mean(ESSs_sum_IS, dims=2), var(ESSs_sum_IS, dims=2)\n",
        "end\n",
        "\n",
        "N = 2\n",
        "T = 500.0\n",
        "dt = 0.1\n",
        "\n",
        "ESS_SS, var_ESS_SS, ESS_IS, var_ESS_IS = experiment_Sparse(N, T, dt; ξ0=0.0, θ0=1.0, α_list=α_list)"
      ],
      "id": "d39634e8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "using JLD2\n",
        "@load \"Logistic2_Experiment4_Sparse_IS.jld2\" ESS_SS var_ESS_SS ESS_IS var_ESS_IS\n",
        "@load \"Logistic2_Experiment4_Sparse.jld2\" ESS_CV var_ESS_CV"
      ],
      "id": "5cf7fbd7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-fold: true\n",
        "#| code-summary: プロット\n",
        "using LaTeXStrings\n",
        "p = startPlot(α_list, ESS_SS, sqrt.(var_ESS_SS); label=\"ZZ-SS\", xlabel=L\"Sparsity $\\alpha$\", color=\"blue\"#, background_color=true\n",
        ")\n",
        "p = addPlot(p, α_list, ESS_IS, sqrt.(var_ESS_IS); label=\"ZZ-IS\", color=\"green\")\n",
        "p = addPlot(p, α_list, ESS_CV, sqrt.(var_ESS_CV); label=\"ZZ-CV\", color=\"darkorange\")\n",
        "display(p)"
      ],
      "id": "05416efb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| output: false\n",
        "#| eval: false\n",
        "savefig(p, \"Logistic2_ESS_per_Epoch_Sparse.svg\")"
      ],
      "id": "19187f03",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "ここでは問題にしないが，圧倒的に実行時間が重点サブサンプリングの方が短い．\n",
        "\n",
        "::: {.callout-important title=\"注\" collapse=\"true\" icon=\"false\"}\n",
        "\n",
        "$\\al<10^{-3}$ の領域では動作が不安定になる．論文 [@Sen+2020] でもこの領域は触れられていない．しかし，\n",
        "$$\n",
        "\\#\\Brace{i\\in[n]\\mid y^i=1}\\approx500\n",
        "$$\n",
        "であるため，特に理由は見つからない．\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "## 高次元へのスケーリング\n",
        "\n",
        "さらに Sticky Zig-Zag サンプラー [@Bierkens+2023] により，スパースデータに対する効率化が可能である．\n"
      ],
      "id": "3c45b182"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| code-summary: データを生成して ZZ で実行\n",
        "#| eval: false\n",
        "using StatsFuns\n",
        "using Distributions\n",
        "\n",
        "\"\"\"\n",
        "    U(ξ, x, y)：ポテンシャル関数\n",
        "        ξ: パラメータ空間上の点\n",
        "        (x,y): 観測\n",
        "\"\"\"\n",
        "function U(ξ, x, y)\n",
        "    n = length(y)\n",
        "    U_list = []\n",
        "    for j in 1:n\n",
        "        push!(U_list, U(j, ξ, x, y))\n",
        "    end\n",
        "    return mean(U_list)\n",
        "end\n",
        "function U(j, ξ, x, y)\n",
        "    n = length(y)\n",
        "    product = dot(x[:,j],ξ)\n",
        "    return -n * exp(y[j] * product) / (1 + exp(product))\n",
        "end\n",
        "\n",
        "ξ0 = [1,2]  # True value\n",
        "n_list = [10, 100, 1000, 10000]  # 実験で用いるサンプルサイズの列\n",
        "\n",
        "Σ = [2 0; 0 2]\n",
        "x = rand(MvNormal(ξ0, Σ), n_list[end])\n",
        "y = rand.(Bernoulli.(logistic.(ξ0'*x)))  # BitVector になってしまう\n",
        "y = Float64.(vec(y))  #  Vector{Float64} に変換"
      ],
      "id": "2548ae4b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "using Optim\n",
        "\n",
        "result = optimize(ξ -> U(ξ,x,y), [0.0,0.0], LBFGS())\n",
        "ξ_star = Optim.minimizer(result)"
      ],
      "id": "1307b534",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.12",
      "language": "julia",
      "display_name": "Julia 1.12",
      "path": "/Users/hirofumi48/Library/Jupyter/kernels/julia-1.12"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}