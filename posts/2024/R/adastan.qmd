---
title: "SDE のベイズ推定入門"
subtitle: "YUIMA と Stan を用いた確率過程のベイズ推定入門"
author: "司馬 博文"
date: 5/12/2024
date-modified: 9/19/2024
categories: [Process, MCMC, R, Stan, YUIMA, Bayesian]
bibliography: 
    - ../../../assets/mathematics.bib
    - ../../../assets/bib.bib
    - ../../../assets/bib1.bib
csl: ../../../assets/apalike.csl
image: Files/adaStan1.png
abstract-title: 概要
abstract: SDE のベイズ推定を，R パッケージ YUIMA を通じて実行する方法を紹介する．
code-fold: false
execute:
  cache: false
listing: 
  -   id: lst-adaStan
      type: grid
      sort: false
      contents:
          - YUIMA.qmd
          - Stan1.qmd
          - calculus.qmd
      date-format: iso
      fields: [title,image,date,subtitle]
  -   id: lst-stan
      type: grid
      sort: false
      contents:
          - Stan1.qmd
          - Stan2.qmd
      date-format: iso
      fields: [title,image,date,subtitle]
  -   id: lst-stan2
      contents:
          - Stan2.qmd
      date-format: iso
      fields: [title,image,date,subtitle]
  -   id: lst-R4
      sort: false
      contents:
          - R4.qmd
      date-format: iso
      fields: [title,image,date,subtitle]
  -   id: lst-brms
      sort: false
      contents:
          - ../Computation/brms.qmd
      date-format: iso
      fields: [title,image,date,subtitle]
---

{{< include ../../../assets/_preamble.qmd >}}

R の YUIMA パッケージに関する詳細は，次の記事も参照：

::: {#lst-adaStan}
:::

## ベイズ推定の実行

### はじめに

確率過程の統計推測を行うための R パッケージ `yuima` では多次元の SDE
$$
dX_t=b_t^\theta(X_t)\,dt+\sigma_t^\phi(X_t)\,dW_t,\qquad X_0\in\R^d,
$$
に対してパラメータ $\theta\in\R^{d_\theta},\phi\in\R^{d_\phi}$ の推定を実行することができる（[`YUIMA` の記事](YUIMA.qmd#sec-model-constructor) も参照）．

YUIMA においてこの $\theta,\varphi$ の推定に，`qmle()` による擬似最尤推定量を用いることも，[`adaBayes()`](https://github.com/yuimaproject/yuima/blob/main/R/adaBayes.R) によるベイズ事後平均による推定も実行可能である．

### 確率的プログラミング言語 `Stan` との連携

`Stan` は Hamiltonian Monte Carlo 法を用いた事後分布サンプリングを，確率モデルを定義するだけで実行することができる汎用的な言語である．

加えて，バックグラウンドで C++ を用いているため，非常に高速な MCMC 計算が可能である．

確率的プログラミング言語 Stan については次の記事も参照：

::: {#lst-stan}
:::

`RStan` は確率的プログラミング言語 Stan とのインターフェイスを提供するパッケージであり，これを用いることで Stan を通じた HMC を用いた事後分布からのサンプリングが実行できる．

ここでは，`yuima` から Stan を使うことを可能にする関数 `adaStan()` の実装を試みる．

### `RStan` とのインターフェイス {#sec-adaStan}

具体的には，R において，次のような関数を定義する：

```{r}
#| output: false
library(yuima)
library(rstan)

yuima_to_stan <- function(yuima){  # <1>
  excode <- 'data {\n  int N;\n  array[N+1] real x;\n  real T;\n  real h;\n}
parameters {\n'

  for(i in 1:length(yuima@model@parameter@all)){  # <2>
    excode <- paste(excode, " real", yuima@model@parameter@all[i], ";\n")
  }

  excode <- paste(excode,"\n}")  # <3>

  excode <- paste(excode,'\nmodel {\n  x[1] ~ normal(0,1);\n  for(n in 2:(N+1)){')  # <4>

  excode <- paste(excode,
    "\n  x[n] ~ normal(x[n-1] + h *", gsub("x", "x[n-1]", yuima@model@drift), ",sqrt(h) *", gsub("x", "x[n-1]", yuima@model@diffusion[[1]]),");\n  }")  # <5>

  excode <- paste(excode,'\n}\n')
}

adaStan <- function(yuima){  # <6>
  # To Do: yuima オブジェクトのスロットの存在をチェック
  # 変数名の例外処理

  excode <- yuima_to_stan(yuima)

  sde_dat <- list(N =  yuima@sampling@n,  # <7>
    x = as.numeric(yuima@data@original.data), 
    T=yuima@sampling@Terminal,
    h=yuima@sampling@Terminal/yuima@sampling@n)

  fit <- stan(model_code=excode,
    data = sde_dat, 
    iter = 1000,
    chains = 4)  # <8>

  return(fit)
}
```

1. Stan モデルのコード（パラメータ部分は未定）を文字列として `excode` 変数に格納する．
2. ここからが `adaStan` 関数の本体である．Yuima モデルの全てのパラメータについてループを開始して，`excode` にパラメータの宣言を追加していく．
3. ここでついに Stan モデルのパラメータの定義部分が完成する．
4. 最後はモデルの定義部分を追加して，Stan モデルのコードが完成する．最初の観測値 `x[1]` は $\rN(0,1)$ に従う．
5. それ以降の観測値 `x[n]` は，前の観測値 `x[n-1]` に drift 項と diffusion 項を加えたものに従う．これを実装するために，Yuima モデルの drift 項と diffusion 項の定義文を呼び出し，`x` を `x[n-1]` に置換することで Stan モデルのコードに埋め込む．
6. `adaStan` という関数を定義する．この関数は，Yuima パッケージのオブジェクトを引数として受け取り，Stan での推定を行い，その結果を `fit` オブジェクトとして返す．
7. Stan での推定を実行するために，Yuima モデルのデータを Stan モデルに渡すためのリスト `sde_dat` を作成する．
8. 最後に Stan モデルをコンパイルして実行し，結果を `fit` オブジェクトとして返す．

これが最初に思いつく最も直接的な方法かも知れないが，このままではいくつかの問題がある：

::: {.callout-caution title="問題点"}

関数内部で Stan model のコードを文字列として生成していることが苦しい．

:::

Stan を使う以上，どこかで Stan モデルの情報を受け渡すことは必要になるが，できることならばもっと良い方法を考えたい．

### 問題点 {#sec-exp-OU}

`adaStan()` 関数の挙動を詳しく見るために，次の具体例を考える．

YUIMA を通じて１次元 OU 過程

$$
dX_t=\theta(\mu-X_t)\,dt+\sigma\,dW_t
$$

をシミュレーションをするためには，次のようにモデル定義をする：

```{r}
model <- setModel(drift = "theta*(mu-x)", diffusion = "sigma", state.variable = "x", solve.variable = "x")
```

これだけで，YUIMA は勝手にパラメータを識別してくれる：

```{r}
model@drift
model@diffusion[[1]]
```

これを通じて生成される Stan モデル文は

```stan
data {
  int N;
  real x[N+1];
  real T;
  real h;
}

parameters {
  real<lower=0> theta;
  real<lower=0> mu;
  real<lower=0> sigma;
}

model {
  x[1] ~ normal(0,1);
  for(n in 2:(N+1)){
    x[n] ~ normal(x[n-1] + h * theta * (mu - x[n-1]),
                  sqrt(h) * sigma);
  }
}
```

となるべきであるが，実際その通りになる：

```{r}
x <- setYuima(model = model)
stancode <- yuima_to_stan(x)
cat(stancode)
```

### `CmdStanR` による解決

```{r}
#| output: false
library(cmdstanr)
stan_file_variables <- write_stan_file(stancode)
mod <- cmdstan_model(stan_file_variables)
```

```{r}
mod$print()
```

などとすることで，一時ファイル上で stan ファイルとバイナリファイルを作成・操作することができる．

```{r}
mod$stan_file()
```

## Stan インターフェイス

### `RStan` パッケージ

詳しくは次稿参照：

::: {#lst-stan2}
:::

前述の OU 過程 [-@sec-exp-OU]

$$
dX_t=\theta(\mu-X_t)\,dt+\sigma\,dW_t
$$

で `stan` 関数でベイズ推定を実行してみます．

パラメータは
$$
\begin{pmatrix}\theta\\\mu\\\sigma\end{pmatrix}
=
\begin{pmatrix}1\\0\\0.5\end{pmatrix}
$$
として YUIMA を用いてシミュレーションをし，そのデータを与えてパラメータが復元できるかをみます．

```{r}
#| output: false
sampling <- setSampling(Initial = 0, Terminal = 3, n = 1000)
yuima <- setYuima(model = model, sampling = sampling)
simulation <- simulate(yuima, true.parameter = c(theta = 1, mu = 0, sigma = 0.5), xinit = rnorm(1))
```

```{r}
# シミュレーション結果
plot(simulation)
```

```{r}
#| output: false
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())
fit <- adaStan(simulation)
```

```{r}
print(fit)
plot(fit)
```

```{r}
#| output: false
library("bayesplot")
library("rstanarm")
library("ggplot2")

posterior <- as.matrix(fit)
plot_title <- ggtitle("Posterior distributions",
                      "with medians and 80% intervals")
```

```{r}
mcmc_areas(posterior,
           pars = c("theta", "mu", "sigma"),
           prob = 0.8) + plot_title
```

$\sigma$ の推定はよくできているが $\mu$ の精度はあまりよくなく，$\theta$ はバイアスがある様で，自信を持って間違えることも多い．

### `brms` パッケージ

[`brms`](https://cran.r-project.org/web/packages/brms/index.html) や `rethinking` も，背後で Stan を利用している．これらが文字式をどのように取り扱っているかを調査する．


::: {#lst-brms}
:::

Stan コードを扱っている関数は [`.stancode()`](https://github.com/paul-buerkner/brms/blob/d42adcd22f5af441870038b1d78ad4d9408f344f/R/stancode.R) であった．

最終的に，[`.compile_model_rstan()`](https://github.com/paul-buerkner/brms/blob/d42adcd22f5af441870038b1d78ad4d9408f344f/R/backends.R#L67) と [`.fit_model_rstan()`](https://github.com/paul-buerkner/brms/blob/d42adcd22f5af441870038b1d78ad4d9408f344f/R/backends.R#L145) が呼ばれるようになっている．

最終的にはこれらの関数も，第 [-@sec-adaStan] 節のサンプルコードと同様の要領で `paste0` を使っていた．

::: {.callout-caution title="`paste0` と `paste` の違い" collapse="true" icon="false"}

```{r}
# paste0() の使用例
result1 <- paste0("Hello", "world")
print(result1)  # "Helloworld"

# paste() の使用例
result2 <- paste("Hello", "world")
print(result2)  # "Hello world"

result3 <- paste("Hello", "world", sep = "-")
print(result3)  # "Hello-world"
```

:::

## テンプレート操作

::: {.callout-caution title="R の Expression について" collapse="true" icon="false"}

オブジェクト志向言語ではコード自体もオブジェクトであり，これを R では Expression と呼ぶ．

::: {#lst-R4}
:::

１つのクラスからなるわけではなく，`call`, `symbol`, `constant`, `pairlist` の４つの型からなる．^[[@Wickham2019] [第17章](https://adv-r.hadley.nz/meta-big-picture.html)２節．]

次のような操作ができる^[[@Wickham2019] [第18章](https://adv-r.hadley.nz/expressions.html)]

`rlang::expr` がコンストラクタである：

```{r}
library(rlang)
z <- expr(y <- x*10)
z
```

`expression` オブジェクトは `base::eval()` で評価できる：

```{r}
x <- 4
eval(z)
y
```

`expression` には list のようにアクセス可能である：^[[@Wickham2019] [第17章](https://adv-r.hadley.nz/meta-big-picture.html)２節．]

```{r}
f <- expr(f(x = 1, y = 2))

f$z <- 3
f
```

```{r}
f[[2]] <- NULL
f
```

:::

## To Do List {.appendix}

* `adaStan()` 