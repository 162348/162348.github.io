---
title: "YUIMA 入門"
author: "司馬 博文"
date: 5/17/2024
date-modified: 9/17/2024
categories: [Stan, R, YUIMA, Process]
bibliography: 
    - ../../../assets/mathematics.bib
    - ../../../assets/bib.bib
    - YUIMA.bib
csl: ../../../assets/apalike.csl
abstract-title: 概要
abstract: R パッケージ `yuima` は確率過程のモデリングとその統計推測を可能にするフレームワークです．従来の i.i.d. 仮定の下での統計推測から，一般の確率過程の統計推測への橋渡しを目標としています．鋭意開発中のパッケージですが，すでに広範なクラスの確率微分方程式のシミュレーションが可能です．その機能の全貌と，基本的な使い方を紹介します．
execute:
  cache: true
code-fold: false
code-overflow: wrap
---

{{< include ../../../assets/_preamble.qmd >}}

## はじめに：[YUIMA](https://r-forge.r-project.org/projects/yuima/)とは？

R パッケージ `yuima` は，Lévy 過程または分数 Brown 運動が駆動する確率微分方程式が定める過程という，極めて一般的なクラスの確率過程を扱うための基盤パッケージである．概観には [@Brouste+2014] が良い．

加えて，シミュレーションと推論のためのメソッドが提供されている．

R で通常の統計推測に用いられる [`formula` オブジェクト](R5.qmd) のように，直感的な記法でモデル（`yuima.model`オブジェクト）を定義できる．

`yuima.model`オブジェクトに対して`toLatex()`関数を適用すると，モデルを LaTeX 記法で記述した文字列に変換することもできる．^[[@Brouste+2014] 第７節も参照．]

::: {.callout-tip title="リンク集" icon="false" appearance="simple"}

* [R-Forge](https://r-forge.r-project.org/projects/yuima/)^[R-Forge とは，SourceForge に似た，R 言語のパッケージ開発者向けの協力的な開発環境を提供するプラットフォーム．]
* [Stable version on CRAN](https://cran.r-project.org/package=yuima).
* [GitHub](https://github.com/yuimaproject/yuima)
* [yuimaGUI package](https://cran.r-project.org/web/packages/yuimaGUI/index.html)
* [rdrr.io ページ](https://rdrr.io/rforge/yuima/)^[rdrr は CRAN や GitHub だけでなく，Bioconductor や R-Forge も含めて検索可能にしているサイト．]
* [論文](https://www.jstatsoft.org/article/view/v057i04) [@Brouste+2014]：パッケージ開発者らによるオープンアクセス論文．

:::

::: {.callout-tip title="インストール" icon="false" appearance="simple"}

```r
install.packages("yuima", repos="http://R-Forge.R-project.org")
```

```{r}
#| output: false
#| code-fold: false
library(yuima)
```

```r
??yuima  # Man pageを開く
```

:::

## YUIMA の構造と `setModel()`

### クラス構造

各クラスのが持つスロット（上段）とメソッド（下段），そして継承関係は以下の通りである．

```{dot}
#| fig-cap: "クラス構造．+ は public, - は private．"
digraph ClassDiagram {
    // クラスのスタイル設定
    node [shape=record, fontname=Helvetica, fontsize=10];
    
    // クラス定義
    yuima [label="{yuima|+model: yuima.model\l+sampling: yuima.sampling\l+data: yuima.data\l- characteristic: yuima.characteristic\l- functional: yuima.functional\l|+initialize()\l+show()\l+plot()\l+simulate()\l}"];
    
    yuima_model [label="{yuima.model|+drift: expr\l+diffusion: expr\l+hurst: num\l+time_variable: chr\l+state_variable: chr\l+solve_variable: chr\l- parameter: model_parameter\l|+simulate()\l}"];
    
    yuima_sampling [label="{yuima.sampling|+Initial: num\l+Terminal: num\l+n: num\l- delta: num\l- grid: list[num]\l|}"];
    
    model_parameter [label="{model_parameter|+all: list[chr]\l+common: chr\l+diffusion: chr\l+drift: chr\l+jump: chr\l+measure: chr\l|}"];
    
    // 関係の定義
    yuima -> yuima_model [arrowhead=onormal];
    yuima -> yuima_sampling [arrowhead=onormal];
    yuima_model -> model_parameter [arrowhead=onormal];
}
```

`yuima`クラスは５つのスロット `yuima.model`, `yuima.sampling`, `yuima.data`, `yuima.characteristic`, `yuima.functional` を持ち，それぞれが別のクラスとして実装されている．

`model.parameter` クラスは後述の `setModel()` コンストラクタにより自動で作成され，ユーザーは変更できない．

::: {.callout-important title="クラス構造の全貌" collapse="true" icon="false"}

実際には，`yuima.model` と `yuima.sampling` だけでなく，`yuima` クラスは５つの構成要素を持つ．

```{dot}
#| fig-cap: "クラス構造．+ は public, - は private．"
digraph ClassDiagram {
    // クラスのスタイル設定
    node [shape=record, fontname=Helvetica, fontsize=10];
    
    // クラス定義
    yuima [label="{yuima|+model: yuima.model\l+sampling: yuima.sampling\l+data: yuima.data\l- characteristic: yuima.characteristic\l- functional: yuima.functional\l|+initialize()\l+show()\l+plot()\l+simulate()\l}"];
    
    yuima_model [label="{yuima.model|+drift: expr\l+diffusion: expr\l+hurst: num\l+time_variable: chr\l+state_variable: chr\l+solve_variable: chr\l- parameter: model_parameter\l|+simulate()\l}"];
    
    yuima_sampling [label="{yuima.sampling|+Initial: num\l+Terminal: num\l+n: num\l- delta: num\l- grid: list[num]\l|}"];
    
    yuima_data [label="{yuima.data|+original_data\l+zoo_data\l|}"];
    
    model_parameter [label="{model_parameter|+all: list[chr]\l+common: chr\l+diffusion: chr\l+drift: chr\l+jump: chr\l+measure: chr\l|}"];
    
    yuima_characteristic [label="{yuima.characteristic|+equation_number: int\l+time_scale: num\l|}"];
    
    yuima_functional [label="{yuima.functional|+F\l+f: list\l+xinit: num\l+e: num\l|}"];
    
    // 関係の定義
    yuima -> yuima_model [arrowhead=onormal];
    yuima -> yuima_sampling [arrowhead=onormal];
    yuima -> yuima_data [arrowhead=onormal];
    yuima -> yuima_characteristic [arrowhead=onormal];
    yuima -> yuima_functional [arrowhead=onormal];
    
    yuima_model -> model_parameter [arrowhead=onormal];
}
```

それぞれのクラスについての詳細は

```r
?yuima.model
```

```r
isClass("yuima.model")
```

```r
methods(class = "yuima.model")
```

などの方法で確認可能．

:::

### `setModel()`コンストラクタ {#sec-model-constructor}

[`yuima.model.R`](https://github.com/yuimaproject/yuima/blob/1bbd1291b58d07fed096a2237db7b233081d51f7/R/yuima.model.R#L118)において次の signature を持つ，`yuima.model`オブジェクトのコンストラクタである．

```r
setModel <- function(drift=NULL, diffusion=NULL, hurst=0.5, jump.coeff=NULL, measure=list(), measure.type=character(), state.variable="x", jump.variable="z", time.variable="t", solve.variable, xinit=NULL){...}
```

この `setModel()` 関数により，最も一般的には次の形をした確率微分方程式が定義できる：

$$
dX_t=a(t,X_t,\alpha)dt+b(t,X_t,\beta)dW_t+c(t,X_t,\gamma)dZ_t,\qquad X_0=x_0.
$$

$W$ としては Brown 運動だけでなく，一般の Hurst 指数 $H$ を持った分数 Brown 運動 $W^H$ を取ることができる．

$c\ne0$ とすることでジャンプを導入したモデルを指定することもできる．

## 例で見る YUIMA の使い方

### 1次元の場合

Ornstein-Uhlenbeck 過程
$$
dX_t=\theta(\mu-X_t)\,dt+\sigma\,dW_t,\quad (\mu,\theta,\sigma,X_0)=(0,1,0.5,0)
$$
を定義してシミュレーションを実行するためのサンプルコードは次の通り．^[モデルの左辺 $dX_t$ は `yuima.model` のスロット `solve.variable` が `state.variable` に暗黙のうちに一致させているところから暗黙に読み込んでいる．]

```{r}
#| output: false

# 確率微分方程式モデルの設定
model <- setModel(drift = "theta*(mu-X)", diffusion = "sigma", state.variable = "X")

# サンプリングスキームの設定
sampling <- setSampling(Initial = 0, Terminal = 3, n = 1000)

# yuimaオブジェクトの作成
yuima <- setYuima(model = model, sampling = sampling)

# シミュレーションの実行
simulation <- simulate(yuima, true.parameter = c(mu = 0,theta = 1, sigma = 0.5), xinit = 0.02)
```
```{r}
plot(simulation)
```

### 多次元の場合

まず，所望のモデルを行列の言葉で書く．例えば，2次元の場合で次のようなモデルを考える：
$$
\vctr{dX_t^{(1)}}{dX_t^{(2)}}=\vctr{-3X_t^{(1)}}{-X_t^{(1)}2X_t^{(2)}}dt+\begin{pmatrix}1&0&X_t^{(2)}\\X_t^{(1)}&3&0\end{pmatrix}\begin{pmatrix}dW_t^{(1)}\\dW_t^{(2)}\\dW_t^{(3)}\end{pmatrix}
$$

シミュレーションは次のように，各項の係数をベクトル・行列の形式で `setModel` へと引き渡すことで行える．^[１次元の場合と違って，左辺を明示するために`solve.variable`のベクトルとしての指定が欠かせなくなる．[@Brouste+2014] 第3.4節 pp.12-13．]

```{r}
#| output: false
solve_variable <- c("X1", "X2")
drift <- c("-3*X1", "-X1-2*X2")
diffusion <- matrix(c("1", "X1", "0", "3", "X2", "0"), 2, 3)
model <- setModel(drift=drift, diffusion=diffusion, solve.variable=solve_variable)
simulation <- simulate(model)
```

```{r}
plot(simulation, plot.type="single", lty=1:2)
```

### 分数 Gauss なノイズ

::: {.callout-tip appearance="simple" icon="false"}

標準分数 Brown 運動 $W^H$ とは，Hurst 指数 $H\in(0,1)$ に対して，
$$
\E[W^H_s,W^H_t]=\frac{1}{2}\Paren{\abs{s}^{2H}+\abs{t}^{2H}-\abs{t-s}^{2H}}
$$
という共分散構造を持った中心 Gauss 過程である．

:::

$H\ne1/2$ のとき，もはや Markov 過程でもセミマルチンゲールでもない．特に $H>1/2$ のときに，$W^H$ は長期的な依存を持った振る舞いをしこれが多くの応用を呼んでいる．

この $W^H$ に対して，SDE
$$
dX_t=a(X_t)dt+b(X_t)dW_t^H
$$
で定まるモデルを定義できる．[@Brouste+2014 3.5節 p.15]

例えば分数 OU 過程
$$
dY_t=3Y_tdt+dW_t^H
$$
は次のように定義する：
```{r}
#| output: false
mod4A <- setModel(drift="3*y", diffusion=1, hurst=0.3, solve.var="y")
mod4B <- setModel(drift="3*y", diffusion=1, hurst=0.7, solve.var="y")
sim1 <- simulate(mod4A, sampling = setSampling(n=1000))
sim2 <- simulate(mod4B, sampling = setSampling(n=1000))
par(mfrow=c(2,1), mar=c(2,3,1,1))
```
```{r}
plot(sim1, main="H=0.3")
plot(sim2, main="H=0.7")
```

このシミュレーション法は Cholesky 法と [@Wood-Chan1994] 法から選択が可能である．`simulate` メソッドのキーワード引数 `methodfGn="WoodChan"`, `methodfGn="Cholesky"` によって利用可能である．

### Lévy 過程

[複合 Poisson 過程](../Process/Poisson.qmd) $Z_t$ とは，Poisson 時間に特定の分布に従うサイズの跳躍が起こるという過程である．

複合 Poisson 過程 $Z_t$ を用いて，
$$
dX_t=a(t,X_t,\theta)dt+b(t,X_t,\theta)dW_t+dZ_t
$$
という SDE を通じてジャンプを持つ過程が定義できる．

さらに $Z_t$ の項に係数 $c$ を持たせるには，$X$ のジャンプを定めるランダム測度（≒確率核）
$$
\mu(dt,dz)=\sum_{s>0}1_{\Brace{\Delta Z_s\ne0}}\delta_{(s,\Delta Z_s)}(dt,dz)
$$
により，複合 Poisson 過程が
$$
Z_t=\int^t_0\int_{\abs{z}\le1}z(\mu(ds,dz)-\nu(dz)ds)+\int^t_0\int_{\abs{z}>1}z\mu(ds,dz)
$$
と表せ，ジャンプ過程 $X$ が，一般の関数 $c$ を用いて
$$
dX_t=a(t,X_t,\theta)dt+b(t,X_t,\theta)dW_t+\int_{\abs{z}>1}c(X_{t-},z)\mu(dt,dz)
$$
$$
\qquad+\int_{0<\abs{z}\le1}c(X_{t-},z)(\mu(dt,dz)-\nu(dz)dt)
$$
と表せる．

$\nu\in\cP(\R^d)$ が [**Lévy 測度**](../Process/Levy.qmd) であるとは， $\nu(\{0\})=0$ かつ
$$
\int_{\R^d}(1\land\abs{z}^2)\nu(dz)<\infty
$$
を満たすことをいう．

例えば，強度 $\lambda=10$ で Gauss 分布を跳躍測度に持つ Lévy 過程は，`measure.type="CP"` によって指定する．

平均 $0$ のジャンプ OU 過程
$$
dX_t=-\theta X_tdt+\sigma dW_t+dZ_t
$$
は次のように定義できる：

```{r}
#| output: false
mod5 <- setModel(drift=c("-theta*x"), diffusion="sigma", jump.coeff="1",
      measure=list(intensity="10", df=list("dnorm(z,0,1)")), measure.type="CP",
      solve.variable="x")
sim5 <- simulate(mod5, true.p = list(theta=1, sigma=3), sampling=setSampling(n=1000))
```
```{r}
plot(sim5)
```

一方で，逆正規分布の大きさのジャンプを持つ Lévy 測度 $\nu$ をもち，Poisson 成分を持たない OU 過程
$$
dX_t=-xdt+dZ_t
$$
は次のように定義できる：

```{r}
#| output: false
mod6 <- setModel(drift="-x", xinit=1, jump.coeff="1",
      measure.type="code", measure=list(df="rIG(z,1,0.1)"))
sim6 <- simulate(mod6, sampling=setSampling(Terminal=10, n=10000))
```
```{r}
plot(sim6)
```

## シミュレーションとサンプリング

### `simulate()` 関数の使い方

`simulate()` は `yuima` または `yuima.model` で定められたモデルから，Euler-Maruyama 法によるシミュレーションを実行する関数．^[ただし，分数 Gauss ノイズが仮定された場合は Cholesky 法または [@Wood-Chan1994] の手法による．]

ソースコードは [`simulate.R`](https://github.com/yuimaproject/yuima/blob/1bbd1291b58d07fed096a2237db7b233081d51f7/R/simulate.R#L4)．ポリモーフィックな実装がなされている．

```r
simulate(object, nsim=1, seed=NULL, xinit, true.parameter, space.discretized = FALSE, increment.W = NULL, increment.L = NULL, method = "euler", hurst, methodfGn = "WoodChan", sampling=sampling, subsampling=subsampling, ...)
```

返り値は `yuima` オブジェクトである．しかし，その `yuima.data` フィールドにはシミュレーション結果が格納されており，それに対して `plot()` を使う．

#### 時間離散化 Euler-Maruyama 法

最も広く使われているシミュレーション法である．

時間にグリッド $0=\tau_0<\tau_1<\cdots<\tau_j<\cdots$ を導入し，連続過程 $\{X_t\}_{t\in\R_+}$ の離散化 $\{\wt{X}_{\tau_j}\}_{j\in\N}$ を
$$
\wt{X}_{\tau_{j+1}}:=\wt{X}_{\tau_j}+b(\tau_j,\wt{X}_{\tau_j})(\tau_{j+1}-\tau_j)+c(\tau_j,\wt{X}_{\tau_j})(W_{\tau_{j+1}}-W_{\tau_j})
$$
と定義する．

$W_{\tau_{j+1}}-W_{\tau_j}\iidsim\rN(0,\tau_{j+1}-\tau_j)$ を利用してサンプリングできる．

#### 空間離散 Euler-Maruyama 法

`simulate` メソッドはこの方法も（ジャンプを持たない過程について）実装している．ただし，**現状，駆動過程が1次元のSDEに対してのみである**．

これは，時間離散化 $\{\tau_j\}_{j\in\N}\subset\R$ は次のように取る方法である：
$$
\tau_0:=0,\quad\tau_{j+1}:=\inf\Brace{t>\tau_j\mid\abs{W_t-W_{\tau_j}}=\ep}
$$
ただし，実装の上では
$$
\ep^2:=\frac{T}{n}=\Delta_n
$$
としている．

この方法は通常の時間離散化法よりも3倍高速になることが経験的に知られている．

これは `space.discretized=TRUE` で指定できる．デフォルトは `=FALSE` となっており，時間離散化の方である．

他にも [@Iacus2008] のシミュレーション法が実装予定である．

### `setSampling`コンストラクタ

`simulate` 関数は `yuima.sampling` オブジェクトも引数として `sampling = samp` と取れる．

そしてこのサンプリングスキームは出力にそのまま引き継がれる．

```{.r filename="setSampling.R"}
setSampling(Initial = 0, Terminal = 1, n = 100, delta, 
   grid, random = FALSE, sdelta=as.numeric(NULL), 
   sgrid=as.numeric(NULL), interpolation="pt" )
```

#### 例

例えば次の2次元モデルを考える

$$
dX_t^{(1)}=-\theta X^{(1)}_tdt+dW_t^{(1)}+X_t^{(2)}dW_t^{(3)}
$$
$$
dX_t^{(2)}=-(X_t^{(1)}+\gamma X_t^{(2)})dt+X_t^{(1)}dW_t^{(1)}+\delta dW_t^{(2)}
$$

時区間 $[0,3]$ 上のグリッドから $n=3000$ の粒度で観測するサンプリングオブジェクトは次のように定義する：

```{r}
#| output: false
sol <- c("x1", "x2")
b <- c("-theta*x1", "-x1-gamma*x2")
s <- matrix(c("1", "x1", "0", "delta", "x2", "0"), 2, 3)
myModel <- setModel(drift=b, diffusion=s, solve.variable=sol)
samp <- setSampling(Terminal=3, n=3000)
```

```{r}
sim2 <- simulate(myModel, sampling=samp)
str(sim2@sampling)
```

これは`samp`そのものであり，確かに出力に引き継がれている．

### `subsampling`関数の使い方

２つの独立な指数分布を指定することで，Poisson 到着時間を用いてサンプリングすることができる．

このような `yuima.sampling` オブジェクトは次のように定義する：

```{r}
newsamp <- setSampling(random=list(rdist=c(function(x)
      + rexp(x, rate=10), function(x) rexp(x, rate=20))))
```

これを用いてサブサンプリングを実行できる：

```{r}
newdata <- subsampling(sim2, sampling=newsamp)
plot(sim2, plot.type="single", lty=c(1,3), ylab="sim2")
points(get.zoo.data(newdata)[[1]], col="red")
points(get.zoo.data(newdata)[[2]], col="green", pch=18)
```

赤が $X_t^{(1)}$，緑が $X_t^{(2)}$ の見本道でどこがサブサンプリングされたかを示している．

このサンプリング法はランダムに行った．これを示すフラグが`regular`である：

```{r}
str(newsamp@regular)
```

一方で，決定論的に，決まった周波数でサブサンプリングもできる：

```{r}
newsamp2 <- setSampling(delta=c(0.1, 0.2))
newdata2 <- subsampling(sim2, sampling=newsamp2)
plot(sim2, plot.type="single", lty=c(1,3), ylab="sim2")
points(get.zoo.data(newdata2)[[1]], col="red")
points(get.zoo.data(newdata2)[[2]], col="green", pch=18)
```

赤色のサブサンプリングは，緑色の２倍の頻度（半分の周波数）で行われている．

### サンプリングとサブサンプリングの組み合わせ

シミュレーション研究で，よく高頻度のサンプリングを行った後，推定のためにより低い頻度でのデータを抽出する，ということが行われる．これは１行で表現できる：

```{r}
#| output: false
Y.sub <- simulate(myModel, sampling=setSampling(delta=0.001, n=1000), subsampling=setSampling(delta=0.01, n=100))
Y <- simulate(myModel, sampling=setSampling(delta=0.001, n=1000))
```

```{r}
plot(Y.sub, plot.type="single")
points(get.zoo.data(Y.sub)[[1]], col="red")
points(get.zoo.data(Y.sub)[[2]], col="green", pch=18)
```

### 今後の発展

#### `zoo`との依存関係

サンプリングとサブサンプリングにおいて，`zoo`というパッケージ [@Zeileis-Grothendieck2005] が時系列データを保存するために内部で用いられている．

より柔軟な時系列データの保存法ができたら，この dependency は脱したいと考えられているようである．

## 漸近展開と `setFunctional()`

確率変数の期待値を近似するのに Monte Carlo 法は普遍的な方法であるが，漸近展開もこれの代替手法である．精度さえ良ければ，計算時間は比較にならないほど速い．

### 場面設定

例えば，$d$-次元拡散過程 $X=(X^{(\ep)}_t)_{t\in[0,T]},\ep\in\ocinterval{0,1}$ を次のように定める：
$$
X^{(\ep)}_t=x_0+\int^t_0a(X_s^{(\ep)},\ep)ds+\int^t_0b(X_s^{(\ep)},\ep)dW_s.
$$

ただし，$W_t$ は $r$-次元 Wiener 過程とした．そして，その汎函数

$$
F^{(\ep)}=\sum_{\al=0}^r\int^T_0f_\al(X_t^{(\ep)},\ep)dW_t^\al+F(X_T^{(\ep)},\ep),\quad W^0_t=t
$$

を決めたいとする．例えば，Black-Scholes モデル
$$
dX_t^{(\ep)}=\mu X_t^{(\ep)}dt+\ep X_t^{(\ep)}dW_t
$$
において，利子率が零である場合のアジアオプションの価格は
$$
\E\Square{\max\paren{\frac{1}{T}\int^T_0X_t^{(\ep)}dt-K,0}}
$$
と表せる（これは線型である）．これは
$$
F^{(\ep)}=\frac{1}{T}\int^T_0X_t^{(\ep)}dt,\quad r=1
$$
と定めた場合に相当する．また，$F^{(\ep)}=X^{(\ep)}_T$ とした場合に当たる
$$
\E[(X^{(\ep)}_T-K)\lor0]
$$
がヨーロピアンコールオプションの価格になる．この値は閉じた形を持っているが，Asian option についてはこの線型な設定においてさえ数値計算法が要請される．

### 渡部理論

ここでは，$\ep\searrow0$ の極限で系が決定論的であるとする．すなわち，
$$
b(-,0)=0
$$
$$
f_\al(-,0)=0\quad(\al\in[r])
$$
とする．すると $X_t^{(0)}$ は次の常微分方程式
$$
\dd{X_t^{(0)}}{t}=a(X_t^{(0)},0),\quad X_0^{(0)}=x_0
$$
の解であるから，$F^{(0)}$ も定数
$$
F^{(0)}=\int^T_0f_0(X_t^{(0)},0)dt+F(X_T^{(0)},0)
$$
で与えられる．

さらに，$a,b,f_\al,F$ がしかるべき正則性条件を満たすとき，汎函数 $F^{(\ep)}$ にはある版が存在して $\ep\in\cointerval{0,1}$ に関して殆ど確実に滑らかである．特に，
$$
\wt{F}^{(\ep)}:=\frac{F^{(\ep)}-F^{(0)}}{\ep}
$$
は次の確率展開を持つ：
$$
\wt{F}^{(\ep)}\sim\wt{F}^{[0]}+\ep\wt{F}^{[1]}+\ep^2\wt{F}^{[2]}+\cdots\quad(\ep\searrow0)
$$

この展開は，Malliavin 解析の Sobolev 空間において厳密に成り立つ．これを導くのが [@Watamane1987] の理論である．

これに基づき，汎函数 $F^{(\ep)}$ の近似を構成する機能が `yuima` に実装されている．この漸近展開をオプションの価格付けに応用したのが [@Yoshida1992] である．

### `setFunctional`コンストラクタ

Black-Scholes モデル
$$
dX_t^{(\ep)}=\mu X_t^{(\ep)}dt+\ep X_t^{(\ep)}dW_t
$$
が定める幾何 Brown 運動 $(X_t)$ のパラメータが $\mu=1,x_0=1$ を満たす場合において，Asian call option の価格は，汎函数
$$
g(x):=\max\paren{F^{(0)}-K+\ep x,0}
$$
を計算すれば良い．

$F^{(\ep)}$ の極限 $F^{(0)}$ の値は，関数 `F0` を `yuima.functional` スロットが埋まった `yuima` オブジェクトに適用することで得られる．

```{r}
#| output: false
model <- setModel(drift="x", diffusion=matrix("x*e", 1, 1))
K <- 100
yuima <- setYuima(model=model, sampling=setSampling(Terminal=1, n=1000))
yuima <- setFunctional(yuima, f=list(expression(x/T), expression(0)), F=0, xinit=150, e=0.5)
F0 <- F0(yuima)
```
```{r}
print(F0)
```

```{r}
#| output: false
g <- function(x) {
  tmp <- (F0 - 100) + (0.5*x)
  tmp[(0.5*x) < (100-F0)] <- 0
  tmp
}
asymp <- asymptotic_term(yuima, block=10, expression(0), g)
```
```{r}
str(asymp)
```

これを適切な和をとれば良い．

```{r}
e = 0.5
asy1 <- asymp$d0 + e*asymp$d1
asy2 <- asymp$d0 + e*asymp$d1 + e^2 * asymp$d2
```

は Asian call price の，それぞれ１次と２次の漸近展開を与える．

### CIR 過程の推測

$X_t$ が幾何 Brown 運動の場合にしか [@Levy1992] の近似は用いることはできない．例えば CIR 模型
$$
dX_t=0.9X_tdt+\ep\sqrt{X_t}dW_t,\quad X_0=1,
$$
の場合でも，漸近展開は有効である．この状態での European call option の価格は，２次までの漸近展開が与える値が，100万データ数による Monte Carlo 推定量の精度に匹敵し，当然計算量は圧倒的に少ない．

## 推論と `setYuima()`

ほとんどの手法が，$N\to\infty,\Delta_n\to0$ の極限で得られるデータ（高頻度データ）にも応用可能な手法になっている．

### `setYuima`コンストラクタ

`model`, `sampling` のみから作れば，サンプリングをし，その結果を`yuima.data`オブジェクトとして格納する．

一方で，`data`を`yuima`オブジェクトに持たせる方法でもある：

```r
my.yuima <- setYuima(data=setData(myData), model=myModel)
```

```r
data <- read.csv("http://chart.yahoo.com/table.csv?s=IBM&g=d&x=.csv")
x <- setYuima(data = setData(data$Close))
str(x@data)
```

### 擬似最尤推定^[[@Brouste+2014 第6.2節]]

$r$-次元 Wiener 過程 $\{W_t\}$ が定める拡散過程

$$
dX_t=a(X_t,\theta_2)dt+b(X_t,\theta_1)dW_t
$$

のパラメータ $\theta_1\in\Theta_1\subset\R^p,\theta_2\in\Theta_2\subset\R^q$ の推定を考えたい．データ
$$
\b{X}_n:=(X_{t_i})_{i=0}^n,t_i:=i\Delta_n
$$
に関する対数尤度は次の**擬似対数尤度**を用いて近似できる：

$$
\ell_n(\b{X}_n,\theta)=-\frac{1}{2}\sum_{i=1}^n\paren{\log\det(\Sigma_{i-1}(\theta_1))+\frac{1}{\Delta_n}\Sigma_{i-1}^{-1}(\theta_1)\Paren{(\Delta X_i-\Delta_na_{i-1}(\theta_2))^{\otimes2}}}
$$
ただし
$$
\Delta X_i:=X_{t_i}-X_{t_{i-1}},\Sigma_i(\theta_1):=\Sigma(\theta_1,X_{t_i})
$$
$$
a_i(\theta_2):=a(X_{t_i},\theta_2),\Sigma:=b^{\otimes2},A^{\otimes2}:=AA^\top
$$
とした．これに対して
$$
\wh{\theta}:=\argmax_{\theta}\ell_n(\b{X}_n,\theta)
$$
と定めるのである．

実は，高頻度極限 $\Delta_n\to0,n\to\infty$ において，$\wh{\theta}_1$ は漸近的に混合正規である [@Genon-Catalot-Jacod1993]．$\wh{\theta}_2$ も一致性を持つには，条件 $T=n\Delta_n\to\infty$ が必要である．これは $T$ が有限であるとき $\theta_2$ のFisher情報量も有限であり，それゆえこの設定したでは
一致推定量が存在しないためである．$T\to\infty$ の下でエルゴード条件を仮定すれば，一致性だけでなく漸近正規性も達成される．局所Gauss近似を成立させるためには $n\Delta_n^2\to0$ が必要であるが，これでは条件が強すぎる．任意の $p\ge2$ に対して条件 $n\Delta_n^p\to0$ しか満たさない場合での適応的推定法が [@Uchida-Yoshida2012] によって，大偏差原理による議論に基づいて提案された．

$T$ が大きくない場合， $\theta_2$ には小標本的な影響が現れる．これは適応的Bayes推定でも議論する．適応的**Bayes事後平均推定量は，上述の $\wh{\theta}_1,\wh{\theta}_2$ と全く同じ漸近的性質を持つ**．

これを実装する`qmle`関数が，`stats4`標準の`mle`関数に似せて作られている．
```r
qmle(yuima, start, method = "L-BFGS-B", fixed = list(),
print = FALSE, envir = globalenv(), lower, upper, joint = FALSE, Est.Incr ="NoIncr",
aggregation = TRUE, threshold = NULL, rcpp =FALSE, ...)
```
`start`は最適化を始める初期値を，名前に対応づける辞書の形で与える．`yuima`オブジェクトは`model`と`data`のスロットが埋められていなければならない．最適化は`BFGS`によって行われる．

ジャンプ過程への応用も今後予定されている．

### QMLEの例

例えば，次のモデル
$$
dX_t=(2-\theta_2X_t)dt+(1+X_t^2)^{\theta_1}dW_t,\quad X_0=1,
$$
を考え，真値を $\theta_1=0.2,\theta_2=0.3$ としてデータを生成する．

```{r}
#| output: false
ymodel <- setModel(drift="(2-theta2*x)", diffusion="(1+x^2)^theta1")
n <- 750
ysamp <- setSampling(Terminal=n^(1/3), n=n)
yuima <- setYuima(model=ymodel, sampling=ysamp)
yuima <- simulate(yuima, xinit=1, true.parameter=list(theta1=0.2, theta2=0.3))
```

これに対して，QMLEを実行してみる：

```{r}
param.init <- list(theta2=0.5, theta1=0.5)
low.par <- list(theta1=0, theta2=0)
upp.par <- list(theta1=1, theta2=1)
mle1 <- qmle(yuima, start=param.init, lower=low.par, upper=upp.par)
summary(mle1)
```

$\theta_2$ の推定の方が圧倒的に難しいらしいことがよくわかる．

### 適応的Bayes推論

$r$-次元モデル

$$
dX_t=a(X_t,\theta_2)dt+b(X_t,\theta_1)dW_t
$$

の**擬似対数尤度**

$$
\ell_n(\b{X}_n,\theta)=-\frac{1}{2}\sum_{i=1}^n\paren{\log\det(\Sigma_{i-1}(\theta_1))+\frac{1}{\Delta_n}\Sigma_{i-1}^{-1}(\theta_1)\Paren{(\Delta X_i-\Delta_na_{i-1}(\theta_2))^{\otimes2}}}
$$

を考える．

まず，任意に初期値 $\theta^\star_2\in\Theta_2$ を取り，$\theta_1$ に事前分布 $\pi_1$ を導入して，これに基づいてBayes事後平均推定量を
$$
\wt{\theta}_1:=\frac{\int_{\Theta_1}\theta_1\exp(\ell_n(\b{X}_n,(\theta_1,\theta_2^\star)))\pi_1(\theta_1)d\theta_1}{\int_{\Theta_1}\exp(\ell_n(\b{X}_n,(\theta_1,\theta_2^\star)))\pi_1(\theta_1)d\theta_1}
$$
と定める．$\pi_1$ は $\Theta_1$ 全域を台に持つならば，高頻度極限で良い漸近的性質を持つ．続いて，$\theta_2$ に事前分布 $\pi_2$ を導入して，$\wt{\theta}_1$ からBayes事後平均推定量を
$$
\wt{\theta}_2:=\frac{\int_{\Theta_2}\theta_1\exp(\ell_n(\b{X}_n,(\wt{\theta}_1,\theta_2)))\pi_2(\theta_2)d\theta_2}{\int_{\Theta_2}\exp(\ell_n(\b{X}_n,(\wt{\theta}_1,\theta_2)))\pi_2(\theta_2)d\theta_2}
$$

### `adaBayes`の例

同様のモデル
$$
dX_t=(2-\theta_2X_t)dt+(1+X_t^2)^{\theta_1}dW_t,\quad X_0=1,
$$
を考え，真値を $\theta_1=0.2,\theta_2=0.3$ としてデータを生成する．

```{r}
#| output: false
ymodel <- setModel(drift="(2-theta2*x)", diffusion="(1+x^2)^theta1")
n <- 750
ysamp <- setSampling(Terminal=n^(1/3), n=n)
yuima <- setYuima(model=ymodel, sampling=ysamp)
yuima <- simulate(yuima, xinit=1, true.parameter=list(theta1=0.2, theta2=0.3))
```

加えて，一様事前分布を用意する．

```{r}
prior <- list(theta2=list(measure.type="code", df="dunif(theta2,0,1)"),
      theta1=list(measure.type="code", df="dunif(theta1,0,1)"))
bayes1 <- adaBayes(yuima, start=param.init, prior=prior, mcmc=1000)
summary(bayes1)
summary(mle1)
```

```{r}
str(bayes1)
```

#### バグについて

1. `coef(summary(bayes1))`はエラーを生じる．
> Error in object$coefficients : $ operator is invalid for atomic vectors
> Calls: .main ... eval_with_user_handlers -> eval -> eval -> coef -> coef -> coef.default
2. `adaBayes`の後ろの方に必須の引数`mcmc`がある．Manpageを読む限り`iteration`と同じ役割では？

#### 小標本性がドリフト推定に与えるバイアス

ドリフト係数 $a(X_t,\theta_2)$ に関する推定は，$[0,T]$ の長さに強い影響を受けることが理論的にも知られている．数値実験では $n=750$ かつ
$$
T=n^{\frac{1}{3}}\approx9.09
$$
と取った．これをさらに $n=500,T\approx7.94$ とすると，
```{r}
#| output: false
n <- 500
ysamp <- setSampling(Terminal=n^(1/3), n=n)
yuima <- setYuima(model=ymodel, sampling=ysamp)
yuima <- simulate(yuima, xinit=1, true.parameter=list(theta1=0.2, theta2=0.3))
mle2 <- qmle(yuima, start=param.init, lower=list(theta1=0, theta2=0), upper=list(theta1=1, theta2=1))
bayes2 <- adaBayes(yuima, start=param.init, prior=prior, mcmc=1000)
```

```{r}
summary(mle2)
str(bayes2)
```

小標本でも適応的Bayes推定量はよく振る舞う．一方で，QMLEでは劣化が激しい．$\wh{\theta}_1$ は小標本の影響を $\wh{\theta}_2$ ほどは大きく受けない．

### 非同期共分散推定^[[@Brouste+2014 第6.4節]]

伊藤過程が非同期に離散観測する設定を考える．

### 変化点解析^[[@Brouste+2014 第6.5節]]

### LASSOモデル選択^[[@Brouste+2014 第6.6節]]

## Bayes推論

### `adaBayes`モジュールについて

SDEモデル内のパラメータに対して適応的Bayes推論を実行するためのモジュールである．

* R-Forge上の[Documentation](https://rdrr.io/rforge/yuima/man/adaBayes.html)
* R-Forge上の[Source](https://rdrr.io/rforge/yuima/src/R/adaBayes.R)
* GitHub上の[Source](https://github.com/yuimaproject/yuima/blob/main/R/adaBayes.R)

