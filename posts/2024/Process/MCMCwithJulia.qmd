---
title: "Julia による MCMC サンプリング"
subtitle: "新時代の確率的プログラミング環境の構築に向けて"
author: "司馬 博文"
date: 7/3/2024
categories: [Process, Simulation, Julia, MCMC]
image: ZZ2D.svg
bibliography: 
    - ../../../mathematics.bib
    - ../../../bib.bib
csl: ../../../apa.csl
abstract-title: 概要
abstract: Zig-Zag サンプラーの挙動を，Julia 上での実装を通じて詳細に解析する．
code-fold: false
---

{{< include ../../../_preamble.qmd >}}

## `AdvancedHMC.jl`

Cauchy 分布に HMC を適用するとぶっ壊れる！？

```{julia}
#| fig-cap: "スタート地点を 50 にした場合"
using AdvancedHMC, ForwardDiff
using LogDensityProblems
using LinearAlgebra
using Plots

struct LogTargetDensityCauchy
    loc::Float64
    scale::Float64
end

# Define the target distribution (1D Cauchy) using the `LogDensityProblem` interface

LogDensityProblems.logdensity(p::LogTargetDensityCauchy, θ) = -log(π) - log(p.scale) - log(1 + ((θ[1] - p.loc)/p.scale)^2)
LogDensityProblems.dimension(p::LogTargetDensityCauchy) = 1
LogDensityProblems.capabilities(::Type{LogTargetDensityCauchy}) = LogDensityProblems.LogDensityOrder{0}()

function HMC_sample(initial_θ)

    # Choose initial parameter value for 1D
    initial_θ = [initial_θ]

    # Define the Cauchy distribution with location and scale
    loc, scale = 0.0, 1.0
    ℓπ = LogTargetDensityCauchy(loc, scale)

    # Set the number of samples to draw and warmup iterations
    n_samples, n_adapts = 2_000, 1

    # Define a Hamiltonian system
    metric = DiagEuclideanMetric(1)
    hamiltonian = Hamiltonian(metric, ℓπ, ForwardDiff)

    # Define a leapfrog solver, with the initial step size chosen heuristically
    initial_ϵ = find_good_stepsize(hamiltonian, initial_θ)
    integrator = Leapfrog(initial_ϵ)

    # Define an HMC sampler with the following components
    #   - multinomial sampling scheme,
    #   - generalised No-U-Turn criteria, and
    #   - windowed adaption for step-size and diagonal mass matrix
    kernel = HMCKernel(Trajectory{MultinomialTS}(integrator, GeneralisedNoUTurn()))
    adaptor = StanHMCAdaptor(MassMatrixAdaptor(metric), StepSizeAdaptor(0.8, integrator))

    # Run the sampler to draw samples from the specified Cauchy distribution, where
    #   - `samples` will store the samples
    #   - `stats` will store diagnostic statistics for each sample
    samples, stats = sample(hamiltonian, kernel, initial_θ, n_samples, adaptor, n_adapts; progress=true)

    # Print the results
    sample_values = [s[1] for s in samples]

    p = plot(1:length(samples), sample_values,
                label="HMC trajectory",
                title="1D HMC Sampler (Cauchy distribution)",
                xlabel="t",
                ylabel="X",
                linewidth=2,
                marker=:circle,
                markersize=2,
                markeralpha=0.6,
                color="#80c4ac")
end

HMC_sample(50.0)
```

```{julia}
#| fig-cap: "スタート地点を 0 にした場合"
HMC_sample(0.0)
```

```{julia}
#| fig-cap: "スタート地点を 500 にした場合"
HMC_sample(500.0)
```

```{julia}
#| fig-cap: "スタート地点を 100 にした場合"
HMC_sample(100.0)
```



## `AdvancedMH.jl`

### `AdvancedMH.jl` とは

* [`Turing.jl`](https://github.com/TuringLang) [@Ge+2018] による

### MALA

```{julia}
using AdvancedMH
using Distributions
using MCMCChains
using ForwardDiff
using StructArrays
using LinearAlgebra
using LogDensityProblems
using LogDensityProblemsAD

# Generate a set of data from the posterior we want to estimate.
data = rand(Normal(0, 1), 30)

# Define the components of a basic model.
struct LogTargetDensityCauchy
    loc::Float64
    scale::Float64
end

LogDensityProblems.logdensity(p::LogTargetDensityCauchy, θ) = -log(π) - log(p.scale) - log(1 + ((θ[1] - p.loc)/p.scale)^2)
LogDensityProblems.dimension(p::LogTargetDensityCauchy) = 1
LogDensityProblems.capabilities(::Type{LogTargetDensityCauchy}) = LogDensityProblems.LogDensityOrder{0}()

# Use automatic differentiation to compute gradients
model_with_ad = LogDensityProblemsAD.ADgradient(Val(:ForwardDiff), LogTargetDensityCauchy(0.0, 1.0))

# Set up the sampler with a multivariate Gaussian proposal.
σ² = 0.01
# spl = MALA(x -> MvNormal((σ² / 2) .* x, σ² * I))
spl = RWMH(MvNormal(zeros(2), I))

# Sample from the posterior.
chain = sample(model_with_ad, spl, 100000; initial_params=ones(2), chain_type=StructArray, param_names=["μ", "σ"])

```